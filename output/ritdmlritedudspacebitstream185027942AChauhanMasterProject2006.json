{
    "title": "Routing in Anhinga Master's Project Report",
    "publication_date": "2002-11",
    "authors": [
        {
            "full_name": "Aakash Chauhan",
            "firstname": "Aakash",
            "lastname": "Chauhan",
            "affiliations": [
                {
                    "organization": "Department of Computer Science, Rochester Institute of Technology",
                    "address": {}
                }
            ]
        },
        {
            "full_name": "Hans-Peter Bischof",
            "firstname": "Hans-Peter",
            "lastname": "Bischof",
            "affiliations": [
                {
                    "organization": "Department of Computer Science, Rochester Institute of Technology",
                    "address": {}
                }
            ]
        },
        {
            "full_name": "Kaminsky Alan",
            "firstname": "Kaminsky",
            "lastname": "Alan",
            "affiliations": [
                {
                    "organization": "Department of Computer Science, Rochester Institute of Technology",
                    "address": {}
                }
            ]
        },
        {
            "full_name": "Date",
            "firstname": "",
            "lastname": "Date",
            "affiliations": [
                {
                    "organization": "Department of Computer Science, Rochester Institute of Technology",
                    "address": {}
                }
            ]
        },
        {
            "full_name": "Sidney Marshall",
            "firstname": "Sidney",
            "lastname": "Marshall",
            "affiliations": [
                {
                    "organization": "Department of Computer Science, Rochester Institute of Technology",
                    "address": {}
                }
            ]
        }
    ],
    "abstract": "N/A",
    "full_text": "Anhinga project with Many-to-Many Protocol (M2MP) takes fundamentally different approach to resolve dynamic network topology in ad hoc networks. Instead of trying host-address based networking and routing to make work in ad hoc network environment, M2MP removes device address and groups. All messages goes to all devices within proximal area and each device decides whether and how to process the message based on message's content. [1] This project expands on this infrastructure by delivering these messages beyond sender device's broadcast range. The project implements Dynamic Source Routing (DSR) protocol based controlled flooding techniques. It also provides functionality for node-to-node communication based on IETF draft for DSR [13] in Anhinga infrastructure.\n\nThe Anhinga Project is the distributed computing infrastructure designed with supporting collaborative applications running in mobile ad hoc networks.\n\nAnhinga provides infrastructure for mobile wireless computing devices such as laptop computers, cell phones, pocket PCs that runs completely on the mobile device. Unlike traditional middleware infrastructure for networking technologies which require central servers and wired connections, anhinga runs on mobile devices and does not require central server to run collaborative applications in mobile environment.\n\nAnhinga is built on two major components, Many-to-Many Protocol (M2MP) and Many-to-Many Invocation (M2MP). M2MP is a message broadcasting protocol designed with serverless ad hoc networks of small devices in mind. M2MI is built on top of M2MP. M2MI is object oriented abstraction of broadcast method invocation. M2MI allows a method invocation across the devices and through out the network. M2MI can simply be described as \"All the devices out there who implement this interface, execute this method.\"\n\nThe architecture of Anhinga and M2MP & M2MI in particular is described in detail in later sections.\n\nThere is extensive amount of research done about routing in ad hoc networks.\n\nMajority of work concentrates on routing in network based on the host address (such as IP Address). Anhinga with M2MP and its broadcast mechanism eliminates the host address requirement to communicate within a network. But anhinga do not really route packets across nodes between geographically dispersed networks.\n\nThis project takes aim at combining these two. Meaning putting an existing MANET routing protocol into anhinga and make two nodes in geographically dispersed network communicate via M2MP.\n\nAd hoc network is a collection of wireless mobile hosts that dynamically form a temporary network where any node can join or leave the network without any prior notification. It has no fixed infrastructure. It is formed and deformed on the fly, depending on the need of the mobile users. There is extensive research being done in routing in these Mobile Ad Hoc Networks (MANET). In such mobile networks battery power and bandwidth are very limited. The research done concentrates on minimum protocol overhead with quick adaptability to rapidly changing network topology.\n\nMajor categorization of MANET protocols is as follows:\n\nPro-active (Table-driven) protocol tries to maintain consistent view of routes to all possible nodes from a given node. The protocol tries to maintain these routes even before they are ever needed or used. The Destination-Sequenced Distance-Vector Routing (DSDV) protocol is a table driven algorithm that modifies the Bellman-Ford routing algorithm to include timestamps that prevent loop-formation. The Wireless Routing Protocol (WRP) is a distance vector routing protocol which belongs to the class of path-finding algorithms that exchange second-to-last hop to destinations in addition to distances to destinations. Since these type of protocol try to keep track of all the changes in network topology, there is significant routing overhead is attached to this class of MANET routing protocols.\n\nOn-demand routing protocols try to reduce control overhead, thus decreasing bandwidth and power usage. These protocols limit the amount of bandwidth consumed by maintaining routes to only those destinations for which a source has data traffic. Therefore, the routing is source-initiated as opposed to table-driven routing protocols that are destination initiated. This type of protocol also avoids heartbeats between nodes since they do not try to maintain complete network topology. There are several examples of this approach (e.g., DSR, ABR, AODV, TORA, SSA, ZRP) and the routing protocols differ on the specific mechanisms used to reduce flood search packets and their responses, cache the information heard from other nodes' searches, determine the cost of a link, and determine the existence of a neighbor.\n\nHybrid Routing, is a mix of distance-vector routing and link-state routing. It tries to balance the overhead by sharing mix of local and global knowledge about network with other nodes. Enhanced Interior Gateway Routing Protocol (EIGRP) is an example of this type of protocol.\n\nThe Dynamic Source Routing protocol (DSR) is a simple and efficient on-demand (reactive) routing protocol. Unlike lot of other protocols DSR does not maintain network topology, which allows the network to be completely self-organizing and self-configuring, without the need for any existing network infrastructure or administration. There are two major mechanisms in DSR, 'Route Discovery' and 'Route Maintenance'. These two together allow nodes to discover and maintain routes to any destinations in an ad hoc network. Since this protocol works completely on-demand, the overhead scales automatically to changes in the network and nothing else. This allows overhead less protocol when all nodes are stationary in the topology and scales up with topological changes. The protocol allows multiple routes to any destination and allows each sender to select the route used in routing its packets. The route discovery mechanism guarantees loop-free routes. DSR also works in networks with unidirectional link.\n\nThe protocol was designed with mobile ad hoc networks in mind, where battery power and bandwidth are expensive. To restrict unnecessary bandwidth usage and processing power, DSR does not initiate a route discovery until it is needed and initiated by a node. Similarly once a route is found there is no effort is put in maintaining that route. Route availability or new route search is only initiated when a route error occurs for existing route and some node initiates a new route discovery process to that same destination. Unlike other reactive routing protocols like ABR or SSA, DSR does not require heart beat message between neighbors to maintain network topology.\n\nDSR is based on the Link-State-Algorithms which mean that each node is capable to save the best way to a destination. Also if a change appears in the network topology, then the whole network will get this information by flooding.\n\nAs discussed earlier there are two major components of DSR, 1) Route Discovery, which consists of a. Route Request b. Route Reply 2) Route Maintenance General workings of these are discussed in the following section. A detailed discussion about implementation and working of these mechanisms is done in section 4.\n\nWhen a node wants to send a message, it first checks its route cache table for a route to destination. If no route found then an automatic route discovery process is initiated.\n\nThe node seeking the route sends out route request message. When a node receives a route request message, it adds itself to the source route and rebroadcasts the request.\n\nOnce the request reaches the intended destination node, destination node adds itself to the route and initiates a route reply message. Section 4 discusses the detail working of route request and route reply.\n\nFor example, suppose a node A is trying to find a route to node E. The Route Discovery initiated by node A in this example would proceed as follows: a) Node A (initiator) sends a RouteRequest packet by flooding the network b) If node B has recently seen another RouteRequest from the same target or if the address of node B is already listed in the Route record, then node B discards the request. c) If node B is the target of the Route Discovery, it returns a RouteReply to the initiator. The RouteReply contains a list of the \"best\" path from the initiator to the target. When the initiator receives this RouteReply, it caches this route in its Route Cache for use in sending subsequent packets to this destination. d) Otherwise node B isn't the target and it forwards the RouteRequest to his neighbors (except to the initiator).\n\nIn DSR every node confirms that the next hop in the Source Route receives the packet it sent. When a node can not successfully transmit a packet to its next intended neighbor after multiple tries, a Route Error message is sent to the initiator, so that it can remove that Source Route from its Route Cache. If there is no route in the cache, a RouteRequest packet is broadcasted. Also if there was any other route in the route cache that was using exact same broken link then all those routes are invalidated. Figure 5 shows an example, 1. If node C does not receive an acknowledgement from node D after some number of requests, it returns a RouteError to the initiator A.\n\n2. As soon as node receives the RouteError message, it deletes the broken-linkroute from its cache. If A has another route to E, it sends the packet immediately using this new route.\n\nDetails about this route process are discussed in section 4.\n\nA B C D E Error 4.1 Existing M2MP Architecture 3\n\nThe Many-to-Many Protocol is designed for the wireless proximal ad hoc networking environment. Following points highlight major features of M2MP architecture:\n\n• There are no device addresses. M2MP works in broadcast medium. Consequently, devices can enter and leave the network in an ad hoc fashion without having to do network configuration.\n\n• Messages are broadcast to all devices. Instead of point to point communication, all the messages in M2MP are broadcasted taking inherent advantage of wireless communication medium in wireless ad hoc network.\n\n• A message's relevancy is determined by its contents. A node determines if a particular message is of its interest based on its content.\n\n• When an application on one device sends an M2MP message, the application writes a stream of bytes with the message's contents to the M2MP layer. The M2MP layer breaks the byte stream into a sequence of packets and broadcasts each packet. On the receiving side, the M2MP layer puts content of each packet back into corresponding message input stream which is used by the application to read the content. In order to receive a particular message an application needs to register a message filter, a fixed length byte string with the M2MP layer. When M2MP layer receives any message it matches the initial content of that message to these filters. If the initials match then the message is passed to the upper layer application that registered for that filter.\n\nThe message is passed to upper layers only when they match a certain filter, otherwise the M2MP layer discards the message. An application that uses M2MP, such as M2MI, can use this filtering mechanism to weed out unwanted messages and separate itself from other M2MP based application. For further information and detailed architecture of M2MP protocol please refer to, http://www.cs.rit.edu/~anhinga/m2mp.shtml Figure 3: M2MP Architecture 3 4.2 Existing M2MI Architecture 3 Many-to-Many Invocation (M2MI) allows building collaborative systems that run in wireless proximal ad hoc networks of fixed and mobile computing devices. M2MI provides an object oriented method call abstraction based on broadcasting. An M2MI invocation means \"Every object out there that implements this interface, call this method.\" An application on top of M2MI is built by defining one or more interfaces, building objects that implement those interfaces, and broadcasting method invocations to all the objects on all the devices. M2MI works on top of above discussed Many-to-Many Protocol (M2MP), which broadcasts messages to all nearby devices over wireless network instead of routing messages from device to device. M2MI builds remote method invocation proxies dynamically at run time, eliminating the need to compile and deploy proxies ahead of time. Because of dynamic proxy, central servers are not required; which eliminates lot of network administration. Also since M2MI works in pure broadcasting environment, complicated, resource-consuming ad hoc routing protocols are not required. 4.3 Project Architecture As discussed above, the main constraint with existing anhinga architecture is that two nodes separated by geographically dispersed network can not communicate with each other. They have to be within each others broadcast range in order to  Figure 6: Routing Layer Architecture 16 As shown in Figure 6 above, once the routing engine receives routing protocol packets from outside, it process it as per protocol rules, updates local tables and rebroadcasts them back if necessary. Figure 7 shows all the class level details of routing layer and what routing rules are implemented. Routing Engine DSRM2MP (Forwards Packets) Daemon Process / Channel Routing Protocol Processes Packet In Packet Out Forwarding Table Updates\n\nFor a new route reply message received from node other then self, the source route is extracted out of the message. After that if this node was the intermediate intended receiver of this message then it rebroadcasts it back for final destination.\n\nRoute error packets are used to clean up faulty route from cache. All the routes in route cache are checked for given sequence of broken route. Based on max hop count criterion a rebroadcast is done.\n\nThis section discusses different packages in the API of the framework. As explained in the architecture there are four major layers / components in the implementation, DSR\n\nThis class processes incoming DSR ACK message. It first checks if this message ID is already processed. If yes then discards it. Otherwise adds it to recently processed messages to avoid re-processing duplicate message. If this message was broadcasted by this node itself then discard it. If this node is final intended receiver of this message, the node is processing it and this router engine do not need to worry about it. Otherwise update the hop count and rebroadcast this packet.\n\nClass DSRReceiverThread provides a thread for receiving and processing incoming messages. This receiver thread constantly scans incoming message queue. As soon as a message is received, this class finds out type of the message and hands it off to appropriate handler. For e.g. if an incoming message type is DSR Route Reply then a DSRRouteReplyHandler object is created and this MessageInputStream is passed to it to process the message appropriately.\n\nIf the M2MI property \"edu.rit.m2mi.debug.ReceiverThread\" is 1 or higher, then whenever an exception is thrown while receiving or processing an incoming M2MI invocation message, the receiver thread will print the exception stack trace on the standard error stream. The receiver thread will continue running, however.\n\nIf the M2MI property \"edu.rit.m2mi.debug.ReceiverThread\" is 2 or higher, then the receiver thread will print a message on the standard error stream whenever the receiver thread receives an incoming M2MI invocation message.\n\nThis class processes incoming DSR Route Error message. It first checks if this message is already processed. If yes then discards it. Otherwise based on the faulty route reported, route table is updated.\n\nThis class is the starting point of DSR Router. It initializes the DSRM2MP Layer and starts the receiver thread by passing it the DSRM2MP layer object. This class contains the main method that starts the DSR Routing engine and keeps it alive till killed.\n\nThis class processes incoming DSR Route Reply message. For non-duplicate messages it will add the route to its own route cache if this node is part of the source route of route reply message. The route reply message is rebroadcast if this node was not original sender and the next intended receiver for this route reply was this node.\n\nThis class processes incoming DSR Route Request message. For a new request, if this node is the sender then discards the request. If this node is the final destination for which the route request is initiated, then a route reply is sent. Otherwise if there is a route in local route cache to the destination, an appropriate route reply is sent. As last resort, if the maximum hop count for the route request is not exceeded then route request is rebroadcasted.\n\nThis class provides common useful functionality across the DSR Routing layer.\n\nClass DuplicateRouteRequestException indicates that the upper layer is trying to initiate a duplicate route request.\n\nThis interface defines the contract for receiving services provided by DSR Routing layer.\n\nThe original M2MP class has been updated to make it aware of DSR data packet aware.\n\nA method \"sendRouteRequest\" is added so that M2MI like upper layer can take advantage of DSR Routing mechanism and request a route to some destination. It is also modified to add a listener for DSR routing related messages by upper layer like M2MI using method \"addRouteReplyReceiver\". To allow upper layers to send DSR specific packets other methods like, \"sendDSRDataPacket\", \"sendDSRACKPacket\", \"sendDSRErrorPacket\" have also been added. Method \"receiveIncomingPacket\" inside M2MP class is also modified to make it aware of DSR Routing related specific message processing. This method based on the type of incoming message sets the MessageInputStream's message type which is later used by router and other layers to process a particular message.\n\nThe\n\nVarious methods like \"dsrServiceReceiver\" were added to M2MI class. This was done to allow abstraction between applications working on top of M2MI and M2MP layer. In future there can be better exposed API either from M2MI or from M2MP to address this issue more cleanly.\n\nReceiver thread was modified to provide extra facilities to application layer working on top of M2MI. These changes were in regards with processing DSR specific messages.\n\nClass ChatObject is exact same as in chat1 package. Except that it adds extra functions to manage route request and route discoveries received from lower levels.\n\nThis class provides a frame that displays all the nodes that are alive in the network. It\n\nshows names of all the nodes to which a private message can be sent.\n\nThis section describes user manual for routing protocol implemented.\n\nThe system is tested on following configuration.\n\n• Sun Solaris OS running on SUN SPARC architecture\n\n• J2SDK 1.4.2 • M2MP/M2MI library version 2004/03/02 System will run on any other OS with java version 1.4.2 or higher running on it. DSR router is note tested for M2MP / M2MI APIs version later then 2004/03/02. 6.2 How to Configure DSR protocol uses M2MP's configuration file \"m2mp.properties. This is a typical M2MP configuration file that includes DSR router settings. Properties highlighted in red box are DSR specific. Figure 8: Configuration file (m2mp.properties) For specifics about configuring M2MP layer please refer to respective documentation at, http://www.cs.rit.edu/~anhinga/m2miapi20040302/doc/edu/rit/m2mp/package-summary.html#configuring Following three properties are very important in deciding behavior of DSR router. • edu.rit.m2mp.deviceid -The globally unique device ID of the device on which the M2MP Layer is running. It is same as mentioned in configuration for M2MP layer. It must be a 48-bit hexadecimal integer in the range 000000000000 through FFFFFFFFFFFF. Every device in the world must use a different device ID. The suggested value is the Ethernet MAC address of the device's network interface. This should be the same as the device ID in the M2MI properties file. Be sure to specify a different device ID on each different machine that is running M2MP! The Same device ID is used by DSR Router 6.3.3 Running Test Application After starting Daemon channel and DSR Router in sequence, any M2MP or M2MI based application can be started. To start Chat Demo application, developed as part of this project to test APIs can be started as follows, >java edu.rit.m2mi.chat2.ChatDemo2 <user name>\n\nSystem was tested in Computer Science lab on Sun Solaris operating system with Java 1.5.0.\n\nA custom chat application was written based on Chat application from Anhinga. The chat application allowed sending messages using a GUI as well as programmatically. At startup of chat application a window shows available neighbors a node can chat with in the network.\n\nTo broadcast a message to all the nodes in the network, simply type the message in chat window. The message will be re-broadcasted based on the default max hop count mentioned in property file. To send a private message to a specific target, message is prefixed with \"pc -<neighbor-name> -.\" For private chat if a route is not known to the destination host, a route discovery message is automatically initiated. Once the route is discovered, a targeted data message is sent using the route. Cases where no route is found or a message delivery is failed appropriate messages are displayed by chat application which it receives from DSR layer. A node can receive messages only from its neighbors. These neighbors are provided from that node's configuration file. Please refer to configuration section for further details. The application was tested on 2 different network topologies. One is the diamond like network topology as shown in Fig 18. Second was linear network as shown in Fig. 19. 7.1.1 Diamond Configuration Figure 15 shows the network configuration of test performed. Node # Node Address Neighbors Neighbors Address\n\n9 Future Works"
}