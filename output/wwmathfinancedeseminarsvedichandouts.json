{
    "title": "Highlights of Computing: From the Ancient Indian Vedic Literature to Modern Practical Cryptography",
    "publication_date": "2010-02",
    "authors": [
        {
            "full_name": "Uwe Wystup",
            "firstname": "Uwe",
            "lastname": "Wystup",
            "affiliations": []
        }
    ],
    "abstract": "N/A",
    "full_text": "The Base 10 is in no way special except that\n\n• The Mayas also used the feet (base=20), see http://en.wikipedia.org/  wiki/Maya_numerals.\n\n• Computers use a dual system (power off or on, base 2) or a hexadecimal system (0, 1, 2, . . . , 9, A, B, C, D, E, F ) for memory size: 1 byte = F F .\n\n• More on http://en.wikipedia.org/wiki/Numeral_system\n\nWrite the hexadecimal number CAF E in the dual, decimal and Maya number system.\n\n2 Vedic Mathematics\n\nExample with working base 10: ) + ab Origin of the ×-sign comes from this method Example with working base 100: 91 -9 × 96 -4 87 / 36 = 8736 111 + 11 × 109 + 9 120 / 99 = 12099 108 + 8 × 97 -3 105 / 24 = 10476 Other working bases (division case) 100/2=50 49 -1 × 49 -1 2)48 / 01 24 / 01 = 2401 100/2=50 54 + 4 × 46 -4 2)50 / 16 25 / 16 = 2484 Other working bases (multiplication case) 10× 2=20 19 -1 × 19 -1 × 2)18 / 1 36 / 1 = 361 10× 6=60 62 + 2 × 48 -12 × 6)50 /2 4 300 /2 4 = 2976 2.2.1 Exercises Multiply the following a 94 × b 97 × c 87 × d 87 × e 87 × f 95 × g 79 × h 98 × i 92 × j 88 × k 97 × l 97 × m 92 × Multiply the following mentally a × 998 b × 997 c × 998 d × 997 e × 998 f × 6 g × 989 h × 9996 i × 9997 j × 99994 k × 99997 l × 9989 Multiply the following mentally a 133 × 103 b 107 × 108 c 171 × 101 d 102 × 104 e 132 × 102 f 14 × 12 g 18 × 13 h 1222 × 1003 i 1051 × 1007 j 15111 × 10003 k 125 × 105 l 10607 × 10008\n\nUsing the sutra Ekadhikena Purvena (\"by one more than the previous one\") we get\n\n• Lots of tricks are available. We do only some highlights.\n\n• Find the exact decimal representation of 1 19 . • Standard methods are cumbersome.\n\n• Using the \"Ekadhika Purva\" Sutra it is easy:\n\n• Start with 1 and then work from right to left multiplying by 2.\n\n. 0 5 2 6 3 1 5 7 8\n\n• A further shortcut is the insight that . 0 5 2 6 3 1 5 7 8   + 9 4 7 3 6 8 4 2 1 = 9 9 9 9 9 9 9 9 9\n\n• The same works for all periodic decimals, e.g.\n\n1 7 . 1 4 2 + 8 5 7 = 9 9 9 2.4.1 Exercises Compute the exact decimal number of a 1 29 b 1\n\n• Use Ekadhika as an osculator.\n\n• For 9, 19, 29, 39 etc. the Ekadhikas are 1, 2, 3, 4, etc.\n\n• For 3, 13, 23, 33 etc. multiply them by 3 and you get 1, 4, 7, 10, etc. as the Ekadhikas.\n\n• For 7, 17, 27, 37 etc. multiply them by 7 and you get 5, 12, 19, 26, etc. as the Ekadhikas. • For 1, 11, 21, 31 etc. multiply them by 9 and you get 1, 10, 19, 28, etc. as the Ekadhikas. • Now test if 112 is divisible by 7 osculating by 5: 2 × 5 + 11 = 21, which is divisible by 7. • Therefore: yes Is 2774 divisible by 19? Osculate by 2: 2 7 7 4 + 8 2 8 5 + 1 0 3 8 + 1 6 1 9 • One more example: Is 5293240096 divisible by 139? • The Ekadhika (osculator) is 14. 5 2 9 3 2 4 0 0 9 6 139 89 36 131 29 131 19 51 93 • Answer: yes 2.5.1 Exercises Using the osculation method, check if a 32896 is divisible by 29 b 93148 is divisible by 29 c 4914 is divisible by 39 d 14061 is divisible by 43\n\n2.6 Square Roots (Vargamula)\n\n• 1, 5, 6 and 0 at the end of a number reproduce themselves as the last digits in the square.\n\n• Squares of complements from 10 have the same last digit; thus 1 2 and 9 2 end in 1, 2 2 and 8 2 end in 4 etc.\n\n• 2, 3, 7 and 8 are out of court altogether.\n\n• If the given number has n digits, then the square root will contain n 2 or n+1 2 digits. • Systematic computation of an exact square root requires the Dvandvayoga (Duplex) process. 49 -D(7) = 0, so 37 is the exact square root of 1369.\n\nFind the square root of the following.\n\nGiven a differentiable function f (x) we want to determine x such that\n\nStarting with x 0 we take the tangent to the curve through the point (x 0 , f (x 0 )) and use its intersection with the x-axis x 1 as a new starting point. We repeat this method until no further changes occur. The recursive relation is\n\nand the result is\n\n) Newton's Method -graphically 3.1.1 Problems Problems can occur due to 1. multiple solutions 2. non convex f , reflection points 3. solutions at extreme values 4. |f | = ∞ 5. pathological cases\n\nConsidering all these problems, why is Newton's method still so popular? The reason lies in the rate of convergence. Define the error by\n\nFrom the definition of the Newton iteration, we have\n\nBy Taylor's Theorem, we have\n\nwhere ξ n is a number between x n and x. A rearrangement of this equation yields\n\nPutting this in (10) leads to\n\nThis equation tells us that e n+1 is roughly a constant times e 2 n . This desirable state of affairs is called quadratic convergence.\n\n• Goldman Sachs standard interview question: Find the square root of 17.\n\n• The Greek Engineer Heron who lived sometime between 100 B.C. and 100 A.D. had used the recursion\n\nto find the square root of R.\n\n• This is based on Newton's method.\n\n• Taking R = 17 and starting with x 0 = 4 we find x 4 = 4.123105625617660549821409856 which is correct to 28 figures.\n\n• Use Newton's method to determine an algorithm that computes the reciprocal of a given number x, without ever performing any division.\n\n• apply your method to compute 1 19 exact to 8 decimal places.\n\nWe follow An Introduction to the Mathematics of Money by Lovelock, Mendel and Wright [3]. • Add the checksum 3 to the 82 and obtain 85.\n\n• If the new total is divisible by 10, then the credit card number has passed the validation test.\n\n• our number fails, whereas 9876 BIN 5432 1987 654 cardholder ID 8 checksum passes.\n\n• Note: Amex has one digit less and starts with the second digit.\n\nProfessor Leonard Adleman Department of Computer Science University of Southern California http://www.usc.edu/dept/molecular-science/fm-adleman.htm\n\nWe follow Francis Litterio' instructions on http://world.std.com/ ~franl/  crypto/rsa-guts.html.\n\n1. Find P and Q, two large (e.g., 1024-bit) prime numbers.\n\n2. Choose E ∈]1, P Q[, no prime factors in common with (P -1)(Q -1).\n\n3. Compute D (the multiplicative inverse) such that DE = 1 mod (P -1)(Q -1). (Find an integer X which causes D = (X(P -1)(Q -1) + 1)/E to be an integer, then use that value of D.)\n\n4. The encryption function is C = T E mod P Q, where C is the ciphertext (a positive integer), T is the plaintext (a positive integer). The message being encrypted, T , must be less than the modulus, P Q.\n\n5. The decryption function is T = C D mod P Q, where C is the ciphertext (a positive integer), T is the plaintext (a positive integer).\n\nYour public key is the pair (P Q, E). Your private key is the number D (reveal it to no one). The product P Q is the modulus (often called N in the literature). E is the public exponent. D is the secret exponent.\n\nYou can publish your public key freely, because there are no known easy methods of calculating D, P , or Q given only (P Q, E) (your public key). If P and Q are each 1024 bits long, the sun will burn out before the most powerful computers presently in existence can factor your modulus into P and Q.\n\nprime 1 P 5 11 37 prime 2 Q 7 7 41 public modulus N = P Q 35 77 1517 P -1 4 10 36 Q -1 6 6 40 (P -1)(Q -1) 24 60 1440 public exponent E 5 7 7 inverse of E D 5 43 823 check DE 25 301 5761 check DE -1 24 300 5760 check [DE -1]/[(P -1)(Q -1)] 0 0 0 plaintext T 5 6 100 encryption function C = T E mod P Q 10 41 1062 decryption function T = C D mod P Q 5 6 100 5.4 Exercise 1. Set up an RSA tool in Excel/VBA and verify the examples.\n\n2. Take two prime numbers P and Q between 100 and 200, e.g. from http:  //primes.utm.edu and compute E and D.\n\n3. Based on a plain text of your choice compute its ciphertext.\n\n4. Give your public key and the ciphertext to the next group and determine the plaintext of another group.\n\n6 Definitions\n\na number that can only be divided evenly by 1 and the number itself.\n\nFor integers K, R and N the equation\n\nmeans that R is the remainder of the division of K by N or alternatively there exists an integer L such that\n\n) Index bank identification number (BIN), 21 BIN, 21 division, 11, 13 dual system, 3 duplex, 15 dvandvayoga, 15 ekadhika, 13 Heron's Square Root Finder, 21 hexadecimal system, 3 Luhn algorithm, 22 Maya numerals, 3 modulus, 28 multiplication, 6 Newton's Method, 18 numeral systems, 3 osculator, 13 prime number, 28 quadratic convergence, 20 RSA-Algorithm, 24 square root, 14 squares, 10 sutras, 5 vedas, 4\n\n6. If one is in ratio the other is zero 7. By addition and by subtraction 8. By the completion or non-completion 9. Differential calculus 10. By the deficiency 11. Specific and general 12. The remainders by the last digit 13. The ultimate and twice the penultimate 14. By one less than the one before 15. The product of the sum 16. All the multipliers 2.1.2 Jagadguru Swami Sri Bharati Krsna Tirthaji Maharaja Explained the sutras in his books.\n\nHans Peter Luhn\n\nThe Luhn algorithm or Luhn formula, also known as the modulus 10 or mod 10 algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers and Canadian Social Insurance Numbers.\n\nIt was created by IBM scientist Hans Peter Luhn and described in US Patent 2,950,048, filed on January 6, 1954, and granted on August 23, 1960."
}