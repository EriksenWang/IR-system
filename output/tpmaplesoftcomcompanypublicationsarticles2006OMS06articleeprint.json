{
    "title": "Global Optimization Toolbox for Maple: an introduction with illustrative applications",
    "publication_date": "2002",
    "authors": [
        {
            "full_name": "János D Pintér",
            "firstname": "János D",
            "lastname": "Pintér",
            "affiliations": [
                {
                    "organization": "CHIN ‡ †PCS Inc",
                    "address": {
                        "city": "Halifax Waterloo",
                        "country": "Canada",
                        "postcode": "N2V 1K8"
                    }
                }
            ]
        },
        {
            "full_name": "David Linder",
            "firstname": "David",
            "lastname": "Linder",
            "affiliations": [
                {
                    "organization": "CHIN ‡ †PCS Inc",
                    "address": {
                        "city": "Halifax Waterloo",
                        "country": "Canada",
                        "postcode": "N2V 1K8"
                    }
                }
            ]
        }
    ],
    "abstract": "This article presents a concise review of the scientific-technical computing system Maple and its application potentials in Operations Research. The primary emphasis is placed on non-linear optimization models that may be formulated using a broad range of components, including e.g. special functions, integrals, systems of differential equations, deterministic or stochastic simulation, external function calls, and other computational procedures. Such models may have a complicated structure, with possibly a non-convex feasible set and multiple, global and local, optima. We introduce the Global Optimization Toolbox to solve such models in Maple, and illustrate its usage by numerical examples.",
    "full_text": "In today's competitive global economy, government organizations and private businesses all aim for resource-efficient operations that deliver high quality products and services. This demands effective and timely decisions in an increasingly complex and dynamic environment. Operations Research (O.R.) provides a scientific approach and methodology to assist analysts and decision-makers in finding 'good'(feasible) or 'best'(optimal) solutions. O.R. has undergone remarkable progress since its beginnings: for example, the 50th anniversary issue of the journal Operations Research [1] reviews an impressive range of real-world applications.\n\nTo motivate the present discussion, we shall review the key steps of model development and optimization in the analysis of complex systems. A formal procedure aimed at making optimized decisions consists of the following main steps.\n\n1. Conceptual description of the decision problem at a suitable level of abstraction, retaining only the essential attributes, while omitting secondary details and circumstances. 2. Development of a quantitative model (or system of connected models) that captures the key elements of the problem. The mathematical model is defined in terms of decision\n\n*Corresponding author. Email: jdpinter@hfx.eastlink.ca Optimization Methods and Software ISSN 1055-6788 print/ISSN 1029-4937 online © 2006 Taylor & Francis http://www.tandf.co.uk/journals DOI: 10.1080/10556780600628212\n\nvariables and the relevant functional relationships among these, expressed by constraints and objectives. 3. Development and/or adaptation of an algorithmic solution procedure, in order to explore the set of feasible solutions and to select the best decision (or a list of good alternative decisions). 4. Numerical solution of the model and its verification; interpretation and summary of results. 5. Posterior analysis and implementation of the decision(s) selected.\n\nSteps 1 and 2 arguably require an element of modeling art, in addition to technical knowledge.\n\nStep 3 requires also a certain 'taste' to select a suitable, computationally tractable approach to solve the optimization problem. Steps 1, 4 and 5 will greatly benefit from interaction with the actual decision-makers or users of the decision support system developed. The importance of these aspects, in order to obtain meaningful solutions to real-life decision problems, and thereby also to increase the visibility that the field of O.R. rightly deserves, cannot be overemphasized.\n\nThe problems tackled by O.R. and the related disciplines are often so complex that the correct model and solution procedure may not be clear at the beginning. Furthermore, drawbacks to a modeling or solution approach that looked promising in steps 2 and 3 may only become apparent at steps 4 and 5, either because the proposed solution failed to capture the key attributes of the decision problem identified in step 1, or because the solution approach was not computationally tractable. Therefore, modelers and decision-makers often must carry out the steps listed above in an iterative fashion. That is, the model developer (team) repeatedly has to modify and refine the model formulation and solution procedure until the model captures the essence of the problem, it is computationally tractable, and its solution is deployable in a real setting.\n\nThe above reviewed 'standard' steps of model development and optimization put into perspective the advantages of using high-level, integrated software tools that can effectively assist their users in performing the listed tasks.\n\nThe integrated computing system Maple [2] enables the development of interactive documents that seamlessly combine the technical description, computing, and visualization with additional features. Maple includes an extensive mathematical library: its more than 3500 built-in functions cover virtually all research areas in the scientific and technical disciplines. Maple also incorporates numerous supporting features and enhancements such as detailed on-line documentation with hyperlinks, a built-in mathematical dictionary with definitions for more than 5000 mathematical terms, debugging tools, automated (ANSI C, Fortran 77, Java, Visual Basic and MATLAB) code generation, and document production (including HTML, MathML, TeX, and RTF converters). Note furthermore that Maple is portable across all major hardware platforms and operating systems (Windows, Macintosh, Linux, and Unix versions). All these capabilities accelerate and expand the scope of the model development and solution process.\n\nTo emphasize the key features pertaining to systems modeling and optimization, a concise listing of these is provided below. Maple\n\n• supports rapid prototyping and gradual model development • performance scales well to modeling large, complex problems • offers context-specific 'point and click' (essentially syntax-free) operations, including various 'Assistants' (windows and dialogs that help to execute various tasks)\n\n• has an extensive set of built-in mathematical and computational functions\n\n• has comprehensive symbolic calculation capabilities • supports advanced computations with arbitrary numeric precision • is fully programmable, thus extendable by adding new functionality • has sophisticated visualization and animation tools • supports the development of graphical user interfaces (by using 'Maplet' applications) • supports advanced technical documentation, desktop publishing, and presentation • provides links to external software products. Further details regarding Maple's features will be presented in sections 5, 6, and 7. For additional information on topics that are outside of the scope of the present discussion, we refer to Maplesoft's website [2] which provides a wealth of information. See also the Maple application center (www.mapleapps.com) which offers over 2500 freely downloadable resources including ready-made materials from simple classroom demos to curricula for entire courses, as well as a range of tutorials and examples. At the time of this writing, nearly two hundred books and many thousands of articles have been written on Maple and its applications.\n\nWithin the broad context of systems modeling and optimization, we see a particularly strong case for using an integrated computing system, such as Maple, to analyze non-linear systems. Such systems are often defined by individually formulated functional relations. Some of the model functions may also require the execution of computational procedures defined by special functions, integrals, systems of differential equations, external function calls, deterministic or stochastic simulation, and so on. Examples of non-linear models that are possibly defined by computationally 'expensive' functions are abundant in various scientific and engineering applications. For detailed examples and discussions, consult refs.  for related discussions.\n\nTo illustrate this point with a relatively simple, but not quite trivial, numerical example, consider the following optimization problem:\n\nIn (1) (x) denotes the gamma function defined by (x) = ∞ 0 exp(-t)t x-1 dt. Figure 1 shows the picture of the objective function f (x). (Let us note that all numerical examples presented in this paper have been formulated, solved, and visualized using the features of Maple and the Global Optimization Toolbox.)\n\nThis example illustrates two types of difficulty. First, there is an embedded integral in the optimization model that has to be evaluated for algorithmically selected arguments x. Second, the model could have a multi-extremal structure, and this fact requires (or justifies) the application of a global scope optimization strategy. Note that, unlike in this relatively simple, merely one-dimensional model example, one often cannot directly explore the model functions, thereby verifying model convexity or non-convexity. With the exception of (important, but limited in scope) special cases, it is not easy to verify the unimodal structure in complex non-linear models. (As it is well-known, unimodality is guaranteed e.g. by a convex feasible set, and a strictly convex objective function). Hence, if we are interested in the best possible solution, then it is prudent to approach such models as global optimization (GO) problems. In order to formalize the general GO paradigm discussed here, we shall use the following notation:\n\n• x decision vector, an element of the real Euclidean n-space R n • f (x) objective function, f : R n → R • D non-empty set of feasible decisions. Specifically, D is defined by the following information:\n\n• x l , x u explicit, finite bounds of x • g(x) m-vector of constraint functions, g: R n → R m .\n\nApplying the notation given above, the GO model can be stated as min f (x) x ∈ D := {x: x l ≤ x ≤ x u g(x) ≤ 0}.\n\n(2)\n\nNote that, all inequalities in (2) are interpreted component-wise. Observe furthermore that the model statement (2) covers a broad class of formal and more general models. For example, instead of ≤ relations, arbitrary combinations of inequality and equality relations could be used with respect to the functions in g; one could state explicit bounds also on the constraint function values; and one could even use a combination of continuous and discrete (finitely bounded) decision variables. Under fairly general analytical conditions, the GO model (2) has a global solution(s): for example, if D is non-empty, and functions f , g (the latter component-wise) are continuous, then the model has a non-empty global solution (set). However, if we use 'traditional' local scope search methods, then, depending on the starting point of the search, we will find only locally optimal solutions of varying quality, recall figure 1. In order to find (i.e. to properly approximate) the 'true' solution, a genuine global scope search effort is needed.\n\nIn higher dimensions, complexity could increase rapidly as shown by the next example. Assume that we wish to find a numerical solution to the following system of equations in a given variable range: e x-y + sin(2x)cos(y) = 0 4xe -y + 5 sin(6xy) + 3 cos(3xy) = 0\n\nFigure 2 shows the least squares (l 2 -norm based) error function induced by the problem statement (3). Without going into details, note that, as discussed by Pintér [14], an arbitrary system of equations and inequalities can be reformulated as a global optimization model, applying a norm-based objective function that expresses the violation of the model relations.\n\nNon-linear models are literally ubiquitous, for example, in engineering design, biotechnology, computational physics and chemistry, data analysis, econometrics, environmental management, financial modeling, medical and pharmaceutical research, process control, risk management, and in many other areas. The solution of complex non-linear models often requires a global scope search approach such as the software implementation discussed in this paper.\n\nFor GO related details outside of the scope of the present paper, consult [31,32] that discuss the most frequently used model types and solution strategies, with information on software and various application areas.\n\nThe core of the Global Optimization Toolbox is the customized implementation of the LGO solver suite. LGO abbreviates Lipschitz(-continuous) Global Optimizer, originally named after one of its key solver components. The theoretical foundations of LGO are discussed in ref. [14], together with some implementation details, test examples, and detailed case studies. The proprietary LGO software has been discussed in subsequent works, and it has been used in commercial applications, in research, and in educational environments for more than a decade, see refs. [15][16][17]24,25].\n\nLGO offers a fully integrated implementation of global and local scope non-linear solvers. The current solver suite includes the following components that can be optionally selected by the user: It is emphasized here that LGO's global search methods do not require derivative (or higher order) information; only the local search phase uses gradient approximations based on central differences. We plan on extending the features of this phase by adding an option for automatic differentiation: however, this may not always be appropriate (namely, in cases when analytical derivatives in fact could not be produced).\n\nA few words regarding the theoretical convergence properties of the listed algorithm components are in order: see ref. [14] for details. First of all, the global search strategies in LGO are indeed globally convergent: that is, these methods are aimed at finding numerically the global solution set, either deterministically (BB), or with probability 1 (GARS and MS). To guarantee such theoretical global convergence, BB requires Lipschitz-continuous model structure; the stochastic search methods require only continuous model functions. Note also that, again, theoretically, the local search method GRG requires continuously differentiable model structure.\n\nThe actual LGO solver suite implementation is based on a numerical approximation of the underlying theory (as it is always the case). In principle, global search should be used ad infinitum, to guarantee exhaustive search and global convergence. Instead of this, LGO applies a limited global search effort that works with an aggregated merit (exact penalty) function. This approach assumes at least 'reasonable' model scaling: that is, all model function values are supposed to vary in similar ranges (e.g. between -1000 and 1000). Furthermore, the 'switch point' from global to local search and a number of other parameter settings represent heuristic elements in LGO (again, similar to all other numerical optimization methods). To mention another practically relevant point, the 'best possible' Lipschitz-information, for each model function, is typically unknown, and poor estimates may lead to inefficiency, or to missing the global optimum.\n\nIn spite of the caveats mentioned above, the LGO solver suite typically will provide good quality, globally optimized solutions when applying a reasonable computational effort (that is controllable by the user). This is true, even if the model functions are merely computable, assuming at least 'overall' continuity, with possible exceptions. In solving smooth and 'nonpathological' models, the LGO solver run will produce at least a high-quality feasible local solution when completed, assuming that the model has such solution(s) indeed. More details regarding numerical performance can be found in refs. [14][15][16][17]24,25]. For example, the computational study [25], that has been conducted with assistance from the GAMS Corporation, using third-party GAMS models and a fully automated evaluation methodology, shows the relative advantages of LGO over state-of-the-art local solvers when solving GO models. The models in that study are defined by up to hundreds of variables and constraints.\n\nThe largest models solved by various LGO implementations so far had a few thousand variables and general (in principle, arbitrary) constraints, in addition to explicit variable bounds. The corresponding runtimes, on today's personal computers, are (or would be) in the range of minutes or hours. Of course, this should be interpreted only as a qualitative statement: for example, the model function evaluations themselves may require significant computational effort. The general theoretical complexity of GO is known to be NP-hard. (For example, it is easy to generate model-classes with an exponentially increasing number of local optima as a function of model dimensionality.) Let us also remark that in practice, some GO model instances can be numerically far more difficult than others, even in the same (possibly very low) dimension. Acceptable precision and computational effort, as well as solver mode and option settings also play a role in performance evaluation, see ref. [26].\n\nThe optional choice of global search methods in LGO often helps to find good quality numerical solutions in difficult models, as BB, GARS, and MS apply different algorithmic strategies. The parameterization of these solvers (e.g. intensified global search) can also help, although the internally set default search effort typically leads to a close numerical approximation of the global solution. The latter statement has been verified by solving some difficult GO challenges, in which the known or putative globally optimal solution is publicly available, and it has been reproduced by LGO, see refs. [15,17,24,25].\n\nMaple's mathematics engine consists of two main components. The kernel, which is written in the C language, is responsible for all basic 'low-level' operations. The library, which contains most of the mathematical algorithms in Maple, is written in the Maple language itself. External libraries and applications, often implemented in the C language, can be linked to Maple through its external calling mechanism. On top of the mathematics engine is the user interface that offers interactive model development, solution, visualization functionality, including contextsensitive menus and the Maplet system which allows customization of the Maple environment.\n\nThe Global Optimization Toolbox implementation of LGO [27] offers a powerful combination of Maple's sophisticated user interface, numerical and visualization capabilities with the robustness and efficiency of the LGO solver suite. The Toolbox is seamlessly integrated with Maple and, after installation, it appears within Maple as the Global Optimization package. A package is generally a collection of related routines and data implemented using a Maple module. Maple provides packages for various mathematical topics, such as linear algebra, geometry, and group theory. Let us remark that Maple (since version 9.5) also includes the Optimization package: the latter is based on the NAG Optimization Library, and it serves for local optimization in models defined by continuously differentiable functions.\n\nThe following Maple command allows the subsequently issued commands in the Global Optimization Toolbox to be invoked directly:\n\nThe Toolbox automatically sets default parameter values for its operations, partly based on the model to solve: these are suitable in most cases, but the user can assign (i.e., override) them. Namely, one can select the following options and parameter values:\n\n• minimization or maximization model • search method (BB+LS, GARS+LS, MS+LS, or stand-alone LS)\n\n• initial solution vector setting (used by the LS operational mode, if available) • constraint penalty multiplier: this is used by BB, GARS, and MS, in an aggregated merit function; the LS method handles all model functions individually • maximal number of merit function evaluations in the selected global search mode • maximal number of merit function evaluations in the global search mode, without merit function value improvement • acceptable target value for the merit function, to trigger a 'switch over' to LS • feasibility tolerance used in LS mode • Karush-Kuhn-Tucker local optimality tolerance in LS mode • solution (computation) time limit.\n\nFurther basic information regarding the Toolbox can be found on the product web page [27], and in the related Maple help system entries. Maplesoft and the first author of this paper have been developing a growing collection of detailed test examples and case studies that illustrate toolbox functionality in a large variety of contexts. We will cite some of these examples below, with added examples provided by the second and third authors.\n\nThe GlobalSolve command is used below first to solve two illustrative GO problems. The function calls, set in Courier bold fonts, will be immediately followed by the corresponding results, set in Courier. We do not wish to go into Maple programming details here, and thus will assume that the key ideas shown by the illustrative code snippets will be understandable to readers with some programming experience. Let us also remark that all runtimes to solve the examples presented are in the order of seconds (or less) except in cases when the function evaluations themselves require a more significant runtime.\n\nIn the first illustrative example, we wish to find an optimized argument value of the BesselJ function. As it is well-known, BesselJ(v, x) is a function that satisfies Bessel's differential equation\n\nHere  > points:=[[0,0],[1,2],[2,-3],[3,0],[4,2],[5,-1],[6,0],[7,5], [8,-4],[9,10],[10,5]]; Figure 4 shows the spline curve constructed (and it can serve to verify the solution of this illustrative example).\n\nBoth the examples presented above are relatively simple, as they are only box-constrained and involve a single optimization variable. However, the examples highlight some key advantages of Maple and the Global Optimization Toolbox. Namely, it is easy to use the full power of the Maple library, including special function evaluations (in the first example) and specialized functionality (computation of a spline interpolating function, given as list of points, in the second case). The model visualization capabilities are also of obvious use in the present context, as well as in many other studies. The second example also illustrates one of the options available to control the behavior of the Toolbox: the option 'maximize' indicates that maximization, rather than (the default) minimization, is attempted.\n\nAn overall advantage of the Maple platform is that the user can provide optimization model functions and constraints as high-level algebraic or functional expressions, thus focusing on the mathematical modeling aspects, rather than on 'lower level' programming details. Note in this context that the GlobalSolve command allows the model input to be provided as Maple procedures, in those cases where the objective or constraint functions cannot be easily written as a simple algebraic expression. A more complex form of input, called 'MatrixForm', which uses procedures involving vector and matrix parameters, is available for those users whose primary goal is efficiency rather than ease-of-use. An interactive Maplet application, which requires no knowledge of the command-line syntax, is also available and will be described later.\n\nThough the optimization model input may be provided in symbolic form, the underlying computation is numeric. Maple supports both hardware floating-point computation and software (arbitrary precision) floating-point computation. Generally, all computations in the Global Optimization Toolbox are performed with hardware floats whenever possible, and the (LGO) solver engine itself uses hardware floats exclusively. However, it is possible to specify an arbitrary number of digits to be used for computation outside the solver engine: this includes also the evaluation of the model functions, thereby frequently leading to more accurate results.\n\nBy default, only the final objective value (estimated optimum) and the corresponding (estimated global) solution vector is returned. However, it is possible to get Toolbox output that provides more information about default settings and computed results, by setting an information level option.\n\nThe LGO solver engine used by Maple Global Optimization Toolbox is a dynamic library of compiled routines rather than a Maple language implementation. The solver engine is accessed by the Toolbox through Maple's external call mechanism. This communication is not directly visible to the Maple user, who interacts with the Global Optimization Toolbox either through the GlobalSolve command (as illustrated above) or through the interactive Maplet graphical interface (this option will be discussed later).\n\nThe information passed to the solver engine consists of the values for LGO's optional settings along with handles to Maple procedures for the optimization model functions. During each evaluation of the objective and constraint functions, the solver engine makes a callback to Maple. These callback actions consist of passing the numerical coordinates of the current evaluation point to Maple through the appropriate handle, and receiving a floating-point result in return. The Toolbox's user-level routine GlobalSolve automatically provides the solver engine with Maple procedures to be used as callback handles: the user can provide the model objective and constraint functions as algebraic expressions, procedures, or matrices.\n\nThere are two principal callback types that an external function can make to Maple, in order to obtain the necessary floating-point evaluations. One type of callback performs evaluation using Maple's double-precision evalhf function, while the other makes use of Maple's arbitrary precision evalf function. In evalhf mode, evaluation is performed at double-precision using the machine's available hardware floating-point precision. In contrast, evaluation done in evalf mode consists of entirely software floating-point computation, which may be done at arbitrary precision. The primary benefit of hardware floating-point evaluation is the speed of execution. The benefits of arbitrary precision evaluation include avoidance of round-off error, and complete access to all of Maple's numeric and symbolic functionality. Note however, that evalf computations are slower than working in evalhf mode.\n\nThe Global Optimization Toolbox will automatically manage the provision of callback modes on the user's behalf. The behavior is modified according to the value of the environment variable Digits, which is used in Maple to control the precision of its radix-10 floating-point computations. The default behavior within the Global Optimization Toolbox is to attempt hardware floating-point evaluation first and to fall back to software floating-point computation, if the objective or constraints are found to not evaluate in Maple's evalhf mode. If the value of Digits is more than the cut-off value for evalhf mode calculation (14 or 15 on most current computer systems) then only software floating-point computation is attempted.\n\nThe simple basic restrictions on the Maple procedures that can be passed to the external LGO solver engine, namely, that they accept numeric data and return a floating-point scalar value, allow for a truly wide variety of 'black-box' type problems to be solved, including problems which perform intermediate symbolic analysis. For example, one can also use Maple's evalM environment to make function calls to the MATLAB [28] software product, if present, to evaluate arbitrary expressions or functions defined in that product's language or source file format. Such calls can also be directly included in Maple procedures that are then passed to GlobalSolve, as components of an optimization model formulation.\n\nMaple's external calling mechanism can evaluate precompiled external functions (e.g. those written in C), and these can also be used in model functions passed to the Global Optimization Toolbox. For example, suppose that we compiled the C source of function fun1 shown below and linked this to a dynamic link (Windows) or shared (Unix, Linux, Macintosh) library, using a suitable C compiler and linker. In the example below, we will use the name libfun1.so for this dynamic shared library object. Then a Maple procedure can be defined which calls the external function, and this procedure can be used e.g., as the objective function passed to the Toolbox. The next example illustrates this approach. (Let us remark that Maple comment lines start with the symbol #: this should not be confused with its usage in the C language as shown in the code example below, when listing fun1.c by the 'cat' system command.) > # Print the simple C source file that defines the function > # fun1. This function will be precompiled, to generate > # libfun1.so. One can also verify by plotting the objective function that the Toolbox has found indeed one of the two global optima (the function x•sin(x) is symmetric in the interval [-20, 20]). Again, such verification would not be possible for more complicated models including 'black box' systems: however, the Toolbox could handle such models. Evidently, the key advantage of the external model function(s) based approach is that the LGO solver engine can pass handles to compiled versions of the functions. Although this approach requires external code development and a compilation procedure, it leads to the fastest optimization when compared to both the evalhf and evalf based approaches. Therefore, this modeling and solution strategy is most appropriate for problems whose objective or constraints are CPU-intensive to evaluate numerically, assuming that the model functions can be expressed e.g. in the C language. (Let us remark also that in many large-scale studies, including legacy applications, the external code may already be in place.) Combined with the ability of Maple's CodeGeneration package to automatically translate Maple procedures and expressions to C source code (as well as to several other programming languages), the Global Optimization Toolbox becomes part of a powerful hybrid symbolic-numeric system for model prototyping, analysis, and efficient numerical solution.\n\nIt is also possible to handle expressions of procedures which may not always evaluate to a numeric value in Maple. There are several situations in which this can occur: the request to Maple for evaluation may return a complex numeric value when real is expected; it may return a non-numeric value; or in some situations, an unevaluated Maple procedure call is returned. Although the Global Optimization Toolbox is not guaranteed to work on such problems (after all, the theory only applies to continuous or Lipschitz models) but it may be worth a try. The actual solver behavior will be problem-dependent in such cases, and it will also depend on the actual sequence of sample points generated.\n\nTo illustrate this point, in the next example we will use Maple's capability to return a floatingpoint infinite value, whenever the underlying expression has not evaluated to a numeric result. The Maple symbol Float(infinity) will be used to indicate a floating-point value that is too large to be represented otherwise. (Note that it does not represent the mathematical concept of infinity; rather, it is used as an \"emergency exit\" in the example.) Assume that we wish to minimize a given parameterized function (defined by the procedure prob shown below that depends on the parameter a) that includes the evaluation of an integral. The procedure output value, for each given argument a, is stored in the local variable sol, including the floating-point infinite return option for unevaluated cases. The runtime limit is set in seconds: this is an optional exit from the embedded numerical evaluation procedure. As mentioned earlier, all other examples presented here are solved in seconds or less time.\n\nIn the examples below, we shall illustrate some of the Toolbox usage options; full details are provided in the related interactive Maple documentation.\n\nFirst, let us recall and solve the model stated in (1) using the Global Optimization Toolbox: this is done by the command below that also selects the single-start (GARS) global solver option Let us point out here that the local solver (activated by the Minimize command in the Optimization package that now comes with Maple) typically returns one of the sub-optimal solutions displayed in Figure 1. Interestingly, in this example this is true, even if the 'hand-picked' initial point happens to be very close to the global solution: In fact, the built-in local search method of the Toolbox has been successful in handling dense non-linear (local) optimization models, without a postulated special structure. This point is demonstrated by detailed results presented in the computational study [25].\n\nConsider Note that in this model formulation the absence of the objective function is substituted by the constant function f (x) = 0. Let us also remark that multiple solutions could be found sequentially in a straightforward fashion (assuming their existence), e.g., by adding linear constraints to exclude a 'sufficiently small' δ-neighborhood of the solution(s) found. This approach obviously assumes that a suitable δ > 0 can be given without the risk of discarding possible global solutions (that should be considered numerically different), but then it could be automated within a Maple procedure that incorporates the GlobalSolve function.\n\nFor illustration, the next statement shows another solution found by adding a global search stopping criterion (option) in GlobalSolve. (Let us note that the added option is different from the default setting, that depends on the number of model variables and functions, as otherwise the Toolbox would exactly reproduce the previous result.) Closing the discussion of this example, notice that one could easily add further constraints to the model statement above, and then apply the same solver methodology directly. This illustrates the broad range of applicability of the Toolbox, not only to solve systems of equations and inequalities, but in the context of an incremental model development process.\n\nConsider now another illustrative optimization model that has a multimodal objective and two non-convex constraints as shown below: minimize (sin(2x 2 + xy 2 )) 2 + (sin(4y + x 2 -12xy)) 2 subject to log(1 + x 4 ) + 8 sin(x 2y) ≤ 0.01\n\nThe next two Maple statements and the corresponding answers show again the possible difference between local and global search results. Notice the constraint definitions that, for added emphasis, we placed on the second line of the Maple input commands; the variable bounds are on the third line of the function calls. As one can see, the global solver has found a (numerical) global solution, whereas the local search approach has led to a sub-optimal solution. The command shown above (that now uses the Interactive function instead of GlobalSolve) opens the Optimization Assistant dialog, as displayed in figure 5. This assistant is part of the Global Optimization Toolbox graphical user interface. The modeler can directly formulate an optimization model through the dialog: this feature supports fast model prototyping and subsequent model analysis options. After solving the model, a model visualization option can also be activated. The Optimization Plotter dialog (figure 6) supports visualization in model variable sub-spaces, defined by variable pairs for n ≥ 2. (In the one-dimensional case a standard function plot is displayed.) The variable sub-spaces can be interactively selected by the modeler, while keeping all other variables at the computed optimum. The plots themselves can also be flexibly adjusted: in addition to the objective function, constraints can be shown as planes orthogonal to or as lines on the surfaces of the projected objective function; these figures can also be rotated, and so on. The graphics features outlined can effectively help users within the context of the model development and verification process.  Numerous other examples, including challenging tests and illustrative applications with a practical flavor, are described in the Toolbox documentation at the product page, in our collections of examples, and also in the forthcoming book [17].\n\nAs mentioned earlier, the LGO solver system has been used for over a decade in a significant variety of commercial, research, and educational applications. Non-linear/GO models with up to a few thousand variables and constraints have been solved (so far) using LGO implementations. In addition to the case studies available from the Toolbox product page, we mention here only two other recent studies with a significant practical motivation. Isenor et al. [29] describe a novel laser design application; Tervo et al. [30] present a detailed model and its solution in relation to cancer therapy planning. For further details, see ref. [24] and the numerical study [25]: in the latter article, over one hundred -including many practically motivated -models are solved, in a reproducible manner, from the publicly available GAMS model library.\n\nWe see strong application potentials for the Global Optimization Toolbox in the analysis of non-linear systems. Several broad (and obviously overlapping) classes of application areas, with a potential need for GO, are:\n\n• models with a provably non-convex structure • optimization of complex 'black box' systems with an unknown structure • optimal control of dynamic systems • decision-making under uncertainty (stochastic modeling and optimization). Models belonging to these broad categories are ubiquitous in research and commercial applications of mathematics, sciences, engineering, econometrics, and finance. Indeed, the user base of the Toolbox includes researchers from world-class engineering, biotechnology, healthcare, and financial organizations, as well as from top universities and research centers.\n\nIn addition to the ones already illustrated or mentioned, a few recent GO application examples (from our practice) are listed below:\n\n• acoustic engineering (speaker and transducer design) In conclusion, Maple's integrated environment and the solver capabilities of the Global Optimization Toolbox can be put to good use in a rapidly growing range of professional applications, as well as in research and education."
}