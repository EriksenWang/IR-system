{
    "title": "Dynamic Label Placement for Improved Interactive Exploration",
    "publication_date": "2005",
    "authors": [
        {
            "full_name": "Thierry Stein",
            "firstname": "Thierry",
            "lastname": "Stein",
            "affiliations": [
                {
                    "organization": "Phoenix Interactive, Grenoble Universities",
                    "address": {
                        "country": "INRIA"
                    }
                }
            ]
        },
        {
            "full_name": "Xavier Décoret",
            "firstname": "Xavier",
            "lastname": "Décoret",
            "affiliations": [
                {
                    "organization": "Phoenix Interactive, Grenoble Universities",
                    "address": {
                        "country": "INRIA"
                    }
                }
            ]
        }
    ],
    "abstract": "Figure 1: An example of dynamic labeling for a complex scene. See accompanying video for better demonstration.",
    "full_text": "One striking characteristic of humans is the ability to communicate rich and complex information. We have invented several abstractions to communicate complex information simply-writing and drawing being natural examples. It is impressive indeed, that many tools available for expressing information today were, at best, works of science fiction decades ago. As Hanrahan [Hanrahan 2005] pointed out at his keynote speech at Eurographics 2005, charts, pictorial graphs, diagrams, and spreadsheets are examples of such tools.\n\nThe challenge when creating representations for communication is that of abstraction and expressiveness. While the former enables simplicity in communication by accounting for context, the latter allows emphasis of certain ideas over others. The sheer bulk of data that is available from more recent inventions such as the internet have posed yet another challenge. Classification, organization, indexes, comments and annotation are essential elements of presenting what would otherwise be merely raw data, as information.\n\nOf the many recent tools for effective communication, our interest lies in 3D representations. Expressing information through 3D visualization has become popular for a wide gamut of applications ranging from entertainment (video games e.g. World Of Warcraft, Quake, etc) to serious applications (geolocalization, virtual tours, cartography, medical visualization, etc). In addition, 3D graphical communication has created a new form of social interaction (e.g. Second Life). However, in most of these applications, the 3D visualization alone is generally insufficient to effectively and comprehensively convey the information. While the 3D representation is useful for presenting a view and helps immersion and localization it is often overwhelming in terms of the amount of information conveyed. A key aspect in this communication with 3D representations is labeling, or visibly attaching text that provides more information about certain regions. Labeling has been a standard tool that enables attaching information and also drawing attention to certain regions. (e.g. life points of other players in WoW, name of avatars in Second Life, description of shops in Google Maps and indicating organ dimensions in medical applications). While labeling has been extensively used in 2D illustration, it is indeed challenging to extend and automate the labeling process for images of 3D representations. Figure 2 shows a typically cluttered view in WoW where the text indications enormously simplify quick comprehension. In this paper, we tackle the problem of displaying such information more optimally, which relates to labeling as reviewed in Section 2.\n\nThe key point here is that the viewpoint is \"inside\" the scene. A consequence of being immersed is that label placement poses more challenges than when labels have to be layed out \"around\" an annotated object, as typically the case in most existing work.\n\nRather than to produce aestethic (i.e close to what talented illustrators can do) layouts for particulars view, our goal is to guarantee that all annotations relevant for the current viewpoint are adequately presented to the user, while attempting to minimize interferance with the 3D experience of scene navigation. In particular, we pay attention to enforce temporal coherence.\n\nThis work is mainly related to the one of map labeling, where algorithms try to place annotations around points, lines or regions. Finding an optimal solution to this problem has been proven to be NP-hard [Marks and Shieber 1991]. The map labeling problem has been extensively studied in the static 2D case. A good survey of the most efficient solutions can be found in [Christensen et al. 1995]. Recently, [Daiches 2006] adressed the problem of zooming in the map with consistent labeling.\n\nExternal labeling is introduced by [Fekete and Plaisant 1999] as an alternative to internal labeling for dense sets of points. Labels are placed on the border of a circle containing anchor points. Their algorithm is limited to the 2D case. A good formalization of the static 2D case is found in [Bekos et al. 2005]. Labels are positioned around an axis-aligned bounding box, and the length of leader lines is minimized. The major limitation is that labels need to have a common size. In [Vollick et al. 2007] the problem is cast as a minimization of an energy function. The motivation was to capture style from a user-specified example, and reuse it to generate labels on novel inputs. They use simulated annealing for resolution, which needs a few minutes, and the approach is consequently non interactive.\n\nAn early mention of 3D external labeling is found in [Preim et al. 1997] where the authors present an algorithm for coherent zooming. Additionaly, [Strothotte 1998] explain the problem of temporal coherence, and show two simple cases where there is no solution to prevent popping for a rotation. In [Bell et al. 2001], authors present an algorithm for real-time 3D label placement using a view-management strategy introduced in [Bell and Feiner 2000]. The scene is approximated by a set of bounding boxes, and labels are interatively placed in the nearest empty rectangle. They also introduce hysteresis to minimize temporal discontinuity. [Hartmann et al. 2004] model the problem using potential fields. Labels are positionned by diffusion of an energy, starting from the middle of the scene. However, this algorithm does not manage all the constraints, and in particular, cannot prevent leader lines intersections. They solve it by permutation of labels, which is not always valid for labels of different sizes. [Ali et al. 2005] present a flexible pipeline including different style. They are also limited to single line text and they don't manage objects with holes. Finally, [G ötzelmann et al. 2007] present a solution for animated 3D models. The main restriction is that they need to analyze the entire animation, so it is not applicable to interactive navigation.\n\nWe start with a 3D scene with points of interest tagged with semantic information. The user navigates the scene, and the information is rendered overlayed on the 2D view. As an example, imagine a virtual model of a museum gallery exposing statues. The pedestal of each statue is tagged with its name, and the name of the artist that committed it. On the Venus de Milo, the shoulders are tagged with an explanation on why the arms are missing. On the David's head, a tag indicates that proportions are not anatomically correct, but chosen so that they appear correct when seen from ground level. When the user enters the gallery, all statues are visible, and only the names are shown. When she moves closer to one statue, the related information appears gradually. This example scenario is what we call dynamic labeling. The term \"label\" is ambiguous. It refers both to the semantic information (e.g. the text explaining what a point of interest indicates), and to the rendering of that information (e.g. the marks that are overlayed on the 2D view to display the text with a particular font and alignment). Let's first clarify the terminology we use.\n\nWe call label the semantic information attached to a point of interest, which is called the label's anchor. The anchor is a 3D point in the scene. The semantic information must contain a displayable content, but it can also contain other information such as a category id, an importance, etc. For a given view of the scene, a label's anchor projects to a given 2D position that we call anchor point. The label is rendered inside a 2D axis-aligned box that we call the label box. The position and size of this box is what is to be determined by our system. However, the aspect ratio of the box is fixed by the content. We do not consider dynamically layed out content such as [Jacobs et al. 2004]. We instead assume the content is given as an \"image\" of given proportions by the user. Consequently, the size of a label box can only controlled by a scale factor. Finally, we call leader line the line that connects the anchor point to the center of the label box. Figure 3  The problem is thus as follows. Given a set of n labels'contents and associated anchor points, how to best overlay label boxes onto the scene view. For that, we must define what \"best\" means. We choose the following criteria. Label boxes must not intersect each other, or some information would not be visible. Leader lines must neither intersect other leader lines nor label boxes, or the anchor/label relation would not be immediately perceived. The label boxes should not hinder the navigation: they should hide as less as possible of the 3D scene, and they should move coherently over time. The anchor/label relation should be as direct as possible: leader lines should not be too long, so that the anchor point and the label box are visually closed; and leader lines should be oriented along priviledged directions. Finally, the label boxes scales should be as close to 1 as possible.\n\nThe two first criteria are hard constraints (\"must\"). The last ones are recommendations (\"should\"). Consequently, we model the problem as an minimization under constraints. We search over the space of all possible {xi, yi, si}i=1...n such that:\n\nwhere B is an axis-aligned 2D rectangle specified by its center and its diagonal vector. We minimize an energy function:\n\nwhere f is a positive real function defined (in image space) over the current view, and whose role is explained in a moment. The first term controls the length of leader lines. The second controls that the labels are not scaled to 0. The third term is used to favor leader lines that are horizontal or vertical, θi being the angle that the leader line i does with the horizontal axis. The fourth term is used to mesure how much the labels occludes the 3D scene underneath. The function f is called occupancy function, and is obtained as follow. Each surface in the scene is attached a user-specified scalar value in [0, 1] that indicates how important it is that this surface be not occluded by labels. For example, we would put 0 on walls, and 1 on objects. This importance value can be view-dependent, for example decreasing with the depth value of pixels. We render a view of the scene from the current viewpoint using this value as surfaces's colors. The resulting image gives f . By integrating the value of f over the label boxes, we have a measure of how the scene is occluded by labels. By using this in the energy function, instead of adding it as a constraint, we allow the algorithm to place labels that hide some parts of the scene when it is not possible to find a better placement. Yet, it will strive to occlude parts that are less important first.\n\nMinimizing eq.( 4) under constraints eq.(1-3) is a complex task (NPhard) that cannot currently be done in real time. Our approach is to solve it greedily. For each label whose anchor point is visible in the current view, we choose (xi, yi, si) so that the contribution to E is minimum, and so that the constraints are respected. This approach does not yield the exact minimum, because the ordering of labels matters. Moreover, this approach has in principal two drawbacks. First, even if we reduce the dimension of the search space from 3n to 3, it is still a large space to explore. Second, as common with greedy algorithm, if we do not order labels adequately, we may end up with the last labels highly increasing E, or worst, being impossible to place without violating the constraints, which would require backtracking the previously placed labels. Figure 4-top/right shows such a poor placement. We address these two problems as follows.\n\nWe reduce the search space by removing si from the minimization. We simply fix the scale of label box i based on the distance to the observer. This is a very crude simplification of our general formulation, and the reader may argue that we should have omitted it in the first place. Yet, we believe that adjusting the scale gives a lot of flexibility to find an ideal label placement. Hence a general formulation should include it, even if the solution presented in this paper cannot yet take it into account. Indeed, reducing the dimension of the search space to 2 is the key to interactivity. This allows to use the GPU to very efficiently evaluate the cost of each candidate (xi, yi), and then retrieve the minimum through matrix reduction, as shown in Section 5.\n\nFurther, we carefully chose the ordering of labels so that we first place those that are a priori hard, leaving the easiest ones for the end. Hopefully, and we observe it in practice, this should help to alleviate the inherent drawback of the greedy approach mentioned above. Intuitively, the hardest labels are those for which there are few candidates (x, y) that meet the constraints, or only candidates for which the contribution to E would be high. We identify two situations that generate such labels. The first situation is when the anchor point is surrounded by other anchor points. If we place the outer labels first, there will be no room left for the inner one. The second situation is when the anchor point is \"deep inside\" an occupied region, that is, the closest point x for which f (x) is small is not that close. In other words, the leader line will be long.\n\nHere is a way we could solve the first problem alone. We compute a Voronoi diagram of the anchor points. We then \"peel\" layers of anchor points from the \"outside\" to the \"inside\". More mathematically, we take all unbounded cells of the diagram. By property of Voronoi, each such cell has exactly two adjacent unbounded cells. This yields a circular ordering of the cells. We push the corresponding anchor points in that order in a LIFO queue. We then recompute the Voronoi diagram of the remaining anchor points and repeat the process until no anchor point is left. Popping the queue would now traverse the labels from the most surrounded one to the less surrounded one.\n\nHere is now a way to solve the second problem alone. Starting with the function f , we compute a distance field. That is, for each x, we find the distance to the closest pixel at which f is 0. Such a distance field can be computed very efficiently on GPU as shown in Section 5. We now evaluate the distance field at each anchor point and sort in decreasing order.\n\nThe two solutions above yield different orderings and have complementary advantages and drawbacks. Consequently, we need a way to somehow merge them into one. Our solution is to use the peeling algorithm described above, but with an Apollonius diagram, also known as Additively weighted Voronoi diagram [Karavelas and Yvinec 2002]. The Apollonius diagram of a set of site points ci with weight wi is a subdivision of the plane into connected regions, called cells, associated with the sites. As for Voronoi diagram, the cell of a site (ci, wi) is the locus of points on the plane that are closer to ci than any other cj. But this time, the distance of a point x in the plane to a site ci is defined as |x -ci|wi. In other words, within a cell, the most important point around is the associated site.\n\nThe weight for each point is set to the value of the distance function.\n\nIn other words, each anchor point is \"considered\" a disc tangent to the closest silouhette, and we compute the Voronoi diagram of these discs. Figure 4-left shows such a diagram and the resulting ordering of anchor points.\n\nNow that the anchor points are ordered, we traverse them and for each label i, we consider all possible locations (x, y) for the label box (there is a finite number of pixels in an image so we can enumerate these locations). At each location, we test if the label box can be placed there without violating the constraints. This can be done in one operation using morphological operators, as now described. We traverse all previously placed labels j. For each, we compute the shadow region of the label box j and leader line j for a point light source at anchor point i. This gives us the location where there would be intersection between the leader line of label i and other labels. We then perform a dilatation by the size of the label box i, which is straighforward knowing the vertices of the shadow region. We finally render all these regions in an offscreen texture as a binary image. The resulting binary image contains 0 where we can place label box i without violating constraints, and 1 elsewhere. Figure 5 illustrates the process. There are two important points here. First, the constraint checking information is available as a texture. Second, the use of dilation allows to test validity using one texture lookup. Both properties allows to integrate the constraint testing gracefully into a GPU implementation based on matrix reduction as described in Section 5. Once this is checked, we evaluate the contribution to E that would result from placing the label box there. One interesting aspect of this approach, besides making the test atomic, is that we can prevent label boxes to be too close from each other by dilating by a larger rectangle than the actual label box.\n\nLooking at eq. ( 4), we see that we have to compute an integral with the scene, which is potentially costly. To do it efficiently, we compute a Summed Area Table (SAT) of the scene. SAT has been originally introduced by [Crow 1984] as an alternative to mipmapping for texture filtering. It allows to compute the integral on an axis-aligned boxes with only four arithmetic operations. Recently, [Hensley et al. 2005] has presented a fast algorithm to compute SAT on the GPU. Once again, if we want a \"band\" between objects silhouettes and label boxes, we can integrate on enlarged domains.\n\nAs mentioned earlier, we want the displayed label not to hinder the navigation experience. The user should not be distracted by popping or fast-moving labels. Intuitively, the label box placement should be continuous, that is, if the user changes slightly the viewpoint, the label box should be only slightly translated. The algorithm we just described does not account for temporal coherence, because the optimisation only involves the current viewpoint. To address this, we add an extra term to the cost function, that penalizes a label's position that would be too far from the label's previous position. This favors continuity whenever a solution exists.\n\nUnfortunately, there are cases where continuity is not achievable.\n\nAs shown in [Strothotte 1998], there are discontinuities inherent to the problem. Figure 6 shows another example.\n\nFigure 6: Placement of labels can not be continuous. The three images above shows three consecutive views (zooming out, then rotating) of a torus with one label attached. In the first view, the label must be placed inside the torus. In the last view, it cannot. There will necessary be a time when the label needs to be \"teleported\"\n\nTo address this problem, we interpolate between the previous position of a label box, and its next position. That is, each label box continuously tries to reach the position it has been placed too, but its velocity is bounded, and it may need several frames to reach this position. Fundamentally, the problem is not solved and the label is actually \"teleported\", but the process \"smoothes\" the teleportation to avoid visual discontinuity. It serves only as a last resort, when the configuration has no continuous solution.\n\nAnother source of discontinuities comes from the treatment of invisible anchor points. As mentioned in first paragraph of Section 4, we only place labels for those anchor points that are visible. But what happens when the visibility of an anchor point changes, for example from visible to hidden? At the very moment before the anchor point becomes hidden, the label box it still completely visible. If placement were continuous, at the moment after the anchor point becomes hidden, the label box would be still largely visible. If we simply remove the label when the anchors becomes hidden, we will have a visual discontinuity because the anchor point is punctual (with a null area) while the label box is not. This problem is well known in NPR when attaching strokes to seed points on a mesh [Vanderhaeghe et al. 2007].\n\nOur solution to that problem is to make the point non-punctual.\n\nThat is, we test the visibility of a small 3D sphere around the anchor point. Using occlusion queries, we can count how much of this sphere is visible, and we use that to blend the label box with the background. In other words, we no longer have a binary visibility status, but a continuously varying one. This has the extra benefit of avoiding the precision issue that would occur when testing the visibility of a single point. The drawback, however, is that in certain situations, such as an anchor seen through fencing or through folliage, the label will sort of \"blink\" with alternate fade-in and fade-out.\n\nPrevious section described our approach and its motivation. In this section, we provide the details of implementation, and in particular how well our approach maps to the GPU. The steps are: All these computations are performed on the GPU, typically rendering a full screen quad with a specific fragment shader, in order to transform an offscreen texture to another offscreen texture.\n\nThe key point is that there is very limited transfer to the CPU. Indeed, we never need to transfer back the whole offscreen textures.\n\nWe compute Summed Area Table and Distance  Another keypoint is that the offscreen texture resolution is completely decorellated from the resolution of the observer's window. Its size only influences the number of (x, y) samples considered to place the label boxes. Since the cost of our algorithm is directly proportional to the resolution (through fill rate and matrix reduction passes), we can scale the quality to the power of the graphic cards. Note however that too small a resolution will cause flickering during the navigation.\n\nWe implemented this approach using non-optimized C++ and OpenGL code. Our tests were ran on a GeForce 7800, using an offscreen resolution of 512 × 512. We are able to interactively place up to 20 labels at 30Hz (but the scene itself can contains much more labels, if not all of them have visible anchor points). Note that the number of polygons in the 3D scene is not relevant for performance measurements. Indeed, we need to render the scene once to obtain the occupancy function. Every subsequent step is entirely in image space and no longer depends on the geometric complexity of the scene, but only on the offscreen resolution chosen.\n\nThe user can control globally the weighting coefficients α, . . . , γ of eq.( 4). In the future, the values of those coefficients could be specified per label. This would allow to force certain labels to be vertical/horizontal, while letting other free. The user can also tag the surfaces with an importance value. In our demos, we have simply split the scene in two files, one with objects of importance 0 (typically walls) and one with objects of importance 1 (typically furniture). Figure 7 shows some results. The accompanying video shows how our algorithm behaves dynamically.\n\nOur approach does have limitations. The main one is inherent to the greedy approach. The last labels may be placed very far from their anchor point, or in the worst case, may not be placed. Even if our ordering heuristic greatly reduces this problem, there are typical cases that fail for our algorithm. Because we peel anchor points from the outside to the inside, the heuristic will be inefficient in the case shown by Figure 8-left, where anchor points should intuitively be peeled in the inverse order. Another bad configuration is that of an extremely dense set of points. Even if we try to respect a circular order in label insertion, we can have an anchor point that is blocked between two previously placed labels. Finally, for large number of labels, there may not exist a valid solution, unless we also optimize over the sizes of the labels, which we do not handle for the moment.\n\nWe have presented a general formalization of dynamic labeling of interactive scenes, together with a pratical greedy approach to solve the NP-hard optimization problem. Our main contribution is to use Apollonius diagrams to select labels in an appropriate order and compensate the drawback of the greedy approach. Our second contribution is an efficient implementation on the GPU, through the use of SAT and morphological operations to make the evaluation of constraints and costs atomic operations. As can be seen in the video, this allows interactive navigation of 3D scenes with annotations.\n\nOur formulation is very general, even though we do not exploit it entirely for the moment. In the future, we would like to optimize also the sizes of the labels. We would also like to test offline optimization algorithms and compare the solution found with the approximate one found by our heuristic. Finally, we would like to investigate recent advances in greedy approaches such as GRASP [Cravo et al. 2008] to improve optimization without sacrificing performance."
}