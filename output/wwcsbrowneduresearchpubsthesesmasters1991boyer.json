{
    "title": "N/A",
    "publication_date": "1988",
    "authors": [],
    "abstract": "N/A",
    "full_text": "The Operating System Development Environment project provides libraries and run-time code that support the development of prototype operating systems. The primary goals of the project are:\n\n1. to simulate a realistic machine architecture entirely in software, without being intrusive or causing unwanted side-effects in the operating system being developed.\n\n2. to allow operating system code to be written entirely in a high-level language; initially \"C\" will be supported.\n\n3. that the operating system and simulator should run native mode code generated by the host system's compilers. While running, the operating system should appear to the host system's kernel and development tools as a normal, user-mode application.\n\nBy building a machine simulator in this way, all existing development, debugging, and profiling tools supplied with the host system can be used to create, debug, and analyze the prototype operating system. No modifications are required to the host system's operating system, and performance is substantially improved as compared to an interpretive approach.\n\nIn order to simulate the actions of architecture-specific trap and interrupt handling, a machine independent, C-callable interface is exported to the operating system writ~r The simulator interface emulates the behavior of traps and interrupts in terms of the resulting How of control between the different pieces of operating system code. For example, a trap function is provided that causes control to immediately transfer to the operating system's trap handler. Before making this control transfer, the simulator switches to a privileged mode and supervisor stack, emulating the way many hardware architectures respond to a trap instruction [6].\n\nOther simulator functions are provided to manipulate privileged simulator registers, access sim ulated peripheral devices, and manage multiple process contexts. The simulator is structured so that the asynchronous, event-driven environment created by a typical multiple-device hardware system is emulated as closely as possible. Writing code to run in the simulator involves dealing with issues that must be faced when writing an operating system for such environments -such as handling multiple device priority levels, creating and switching between process contexts, handling hardware exceptions, and dealing directly with device I/O registers for both DMA and non-D:MA type devices.\n\nIn the following section, the general machine model presented by the simulator is discussed. Then. the low-level interface that exists between the simulated machine and the Prototype Operating System that logically runs within the simulated machine is presented. The design for a UNIX based 1 implementation of the simulator is then outlined, followed by the design for an OSF /1-based 2 implementation. The OSF /l-based design avoids many of the limitations found in the UNIX-based design, and provides additional functionality mostly related to virtual memory support. In each of the two design sections, the current status, limitations, and possible improvements for each implementation are also discussed. Finally, a summary of the project is provided, followed by appendices that contain the actual simulator programmable interface, and notes related to existing implementations.\n\nIn order to avoid confusion, the operating system that is being developed to run in the simulator is termed the prototype operating system, or POS. The operating system that is running on the host machine is referred to as the host operating system. The host operating systems that have been used in the project are SunOs 4.1, VAX-ULTRIX V4.0, and OSF/1 (Mach 2.5 + OSF extensions).\n\nThe machine that is emulated by the simulator combines features found in many existing hardware architectures [6]. Certain design decisions are mandated because the simulator runs native-mode code, and all simulator, pas, and user-mode code running in the pas must execute as a normal (non-privileged, user-mode) application on the target machine.\n\nThe simulated machine is based on a single-CPU modeP. The CPU is logically attached to physical memory that is loaded with machine instructions and data accessed by the CPU. A fixed number of privileged and non-privileged registers are present in the machine. Privileged registers are employed to store addresses or constants that are used by the machine in order to perform system-level functions, and to control devices present in the simulated system. The non-privileged registers are the same general-purpose registers that exist on the host system and are accessed by both user-level and supervisor-level code.\n\nDirect memory access (DMA) and non-DMA devices may be configured into the simulated system. The device interface is primitive, requiring direct manipulation of device registers to complete I/O operations. Devices may be set to interrupt when the I/O is complete, and the machine will then cause an interrupt service routine (ISR) to execute on the simulated machine's CPU.\n\nSince the simulated machine will run native-mode code (i.e. code generated by the host system's compilers) as a user-mode application on the host system, the supported instruction set consists of the majority of non-privileged machine instructions available on the host machine. Code generated by the host system's compilers will run in the simulator without alteration 4 • The simulator is designed so that the pas and the user-mode code running within the pas can be written entirely in a high-level language, such as C.\n\nPrivileged and \"special\" machine instructions are emulated via a procedural interface. The simu lator provides routines that perform the same logical functions as these instructions would perform on an actual machine. In this category are the following instructions:\n\n• user-mode trap (controlled access to supervisor mode)\n\n• return from trap, exception or interrupt (REI)\n\n• process context creation, saving, loading, and modification\n\nThe simulated machine supports two execution modes -supervisor and user. The machine is in supervisor mode when pas code is running, and in user-mode when non-privileged code is running within the pas. Physical pages and their containing memory regions are assigned protections based JIn section 6.1, an possible extension to the simulator is discussed that would allow certain types of parallel machines to be simulated. on execution modes 5 . For example, POS code and data can be protected from read or write access by user-mode code, while at the same time allowing read/write access to supervisor-mode code (see section 2.6 for more information).\n\nEach process context running within the POS has two program counters and two stack pointers -one of each for supervisor and user modes. There is currently no support for a system-wide interrupt stack. When a device interrupt occurs, the supervisor stack of the currently executing process context is used to deliver the interrupt handler.\n\nSimulator privileged instructions (see below) can only be issued from supervisor mode, otherwise a privileged-mode exception occurs.\n\nThe simulated machine contains the following \"privileged\" registers: PSRthe processor status register. Contains the current execution mode and interrupt priority level (IP L). MMRsa configurable number of memory management r~gisters a.H~ available that can be used to support the particular memory management architecture being simulated. The use of these registers is described further in section 2.6.3.\n\nAdditionally, device registers are used to provide a low-level device interface as described in sec tion 2.4.\n\nSimulated terminal, disk, and clock devices are supported. The number of each type of device is configurable. Associated with each device is an interrupt priority level, or IPL. IPLs range from 0 -15, with 0 being reserved. The simulated machine stores the current IPL in the processor stat us register (PSR).\n\nAn interrupt hierarchy is supported using IPLs. When a device completes I/O, its IPL is compared with the current IPL of the simulated machine in the PSR. If the device IPL is higher, the code is interrupted, its state saved, and the interrupt handler for the device is run on the supervisor stack. If the current IPL is lower than the device IPL, the interrupt is deferred by setting a bit in the pending interrupt register (PIR).\n\nWhen the IPL drops lower than the pending device's IPL, the interrupt handler is invoked through the \"rei\" mechanism (return from exception or interrupt). A special simulator instruction (SIMrei) must be issued whenever an interrupt, trap, or exception handler exits. During SIMrei processing in the simulator, the PIR is scanned to determine whether a pending interrupt can be delivered when the IPL is restored to its previous value. If so, the pending interrupt's IPL becomes the \"page protection is not supported in the UNIX implementation of the simulator. current machine IPL, and the interrupt is delivered immediately; otherwise the IPL is restored to the value that existed prior to the original interrupt. Control then resumes at the point the interrupt handler originally interrupted.\n\nTt. is also possible for supervisor-mode code to directly change the current IPL by issuin~;:,., 1JriY;~-:o~d machine instruction (SIMsetipl), so that critical code regions can be protected from interrupts. When the setipl instruction is used to lower IPL, the same checks for pending interrupts are made as with SIMrei.\n\nA simple system control block is used by the simulator to locate the interrupt, trap, and exception handling routines supplied by the POS. The address of the SCB is contained in a simulator register, and may be accessed via privileged instructions. The format of the SCB is shown in figure 1.\n\n.\\ single interrupt handler exists for each IPL, even though multiple devices can use the same IPL. The interrupt handler can determine which specific device is interrupting by checking the first parameter supplied to the interrupt service routine. This argument is a longword uniquely identifying the interrupting device.\n\nThe memory management subsystem is designed with flexibility in mind. It is intended that various memory management architectures can be supported by replacing a single module of the simulator containing relatively few routines with simple interfaces. This module is termed the pmap module and is discussed in conjunction with the OSF /1-based implementation in section 5.2.1. Here, the general architecture of the memory management subsystem is presented.\n\nThe simulated machine can run with memory management enabled or disabled 6 . When the simu lator starts up, memory management is disabled -this state is known as real mode. While in real mode, there is no virtual memory translation. Every referenced address directly maps to the same address in simulated physical memory. Ideally, physical addresses start at zero and extend to the size of physical memory configured into the machine minus one. However, certain host machine limitations may require that the physical address space start elsewhere.\n\nAt some point during system startup, the POS may enable virtual memory, at which point the machine enters virtual mode. While in virtual mode, referenced addresses are mapped to physical addresses via the data structures and address translation mechanisms supported by the pmap. The writer of the POS is responsible for providing the page-fault handling code, and for maintaining the page-mapping tables required by the architecture. (As mentioned above, the simulator allows alternate memory management architectures and data structures to be supported by replacing the pmap module.)\n\nPhysical memory is divided into page-sized pieces known as frames. Page frames are numbered starting at zero, and extend to cover the amount of physical memory in the simulated machine. Page frame numbers are uE:eu durilLg the virtual memory mapping process to support a non-contiguous memory allocation scheme [6]. Normally, page frame numbers will appear in the memory manage ment data structures that are used to provide virtual mapping.\n\nThe simulated machine allows both user-mode and supervisor-mode page sharing. Multiple process contexts may map the same page frame to different virtual address ranges. It is up to the memory management architecture to manage protection and keep track of multiple references to the same page -the simulated machine merely provides a mechanism that allows multiple contexts to map the same region of physical memory.\n\nThe simulated machine does not have a fixed page size. Instead, various page sizes can be configured by changing a compile-time constant and rebuilding the simulator.\n\nA configurable number of longword registers are supplied for use with the memory management subsystem of the simulator; it is up to the pmap module (and thus the simulated machine's \\\"irtual memory architecture) to use and interpret their contents. For example, a register could be used as the system page table's system virtual address, and another could be used to contain the maximum system virtual page number. The simulator merely provides these registers at a known address and logically accesses them when required during the address translation process. 6The memory management functionality described in this section is only supported in the OSF II-based imple mentation of the simulator\n\nWhile the simulated machine is in virtual mode, the following page protection modes are supported: read, write, and none. These protections are combined with the current execution mode to deter mine whether access is actually permitted. For example, a page may be protected user-mode read, supervisor-mode read/write; meaning user-mode code may read the page, but only supervisor-mode code may modify the page. The pas has complete control over page protection through the data structures employed to support the memory management architecture. If the paging architecture supports it, the granularity of protection may be a single page. The simulated machine does not support different protections for regions within the same page.\n\nThe simulated machine provides four (logical) booleans associated with each page that may be supported in various degrees by the virtual memory architecture being simulated. The mapped flag indicates whether the page is mapped. A valid flag is used to indicate whether the page is currently present in memory (resident). A modified flag is provided that allows the pas to determine if a page has been written in to. Finally, a referenced flag allows the pas to determine if the page has been read or written. The specific paging architecture supported by an incarnation of the simulator's pmap module determines whether all or a subset of these flags are actually used. The mapped and valid flags, however, must be support<>d hy all memory management architectures.\n\nThe simulated machine supports the creation, saving, and loading of process contexts through special privileged simulator instructions. The inclusion of context manipulation support at this level serves the following purposes:\n\n• It relieves the pas writer from dealing with many of the low-level operations that must typically be performed to support multiple contexts. This same rationale can be found in the design of certain elSe architectures, such as the VAX, which include similar high-level context manipulation instructions.\n\n• It provides a mechanism for the simulator to be notified whenever a context is created, loaded, or saved. The simulator may need to know when this occurs because of the way multiple contexts are implemented on the host machine (for an example, see section .5.1.2).\n\n• It provides a host-machine independent way for performing these functions. Most, if not all, of the machine-dependent operations required during context creation and switching are performed by the simulator's context-related procedures.\n\nProcess context manipulation is discussed further in the following section concerning low-level prototype operating system components.\n\nThis section describes components of a typical prototype operating system (POS) that interact with or are used directly by the simulated machine. The routines and data structures described here provide an illustrative example of the low-level machine support contained in a typical POS. There is no requirement that the code running in the simulator include all the routines discussed here, but a POS designed to support the features found in the majority of existing operating systems would include most, if not all, of them. Similarly, all of the data structures that are recognized by the simulated machine and described in section 3.3 would typically be used within a full-featured POS.\n\nThe POS would normally include initialization (system startup), trap-handling, exception-handling, and interrupt-handling routines. The POS code and static data are loaded into (simulated) phys ical memory, and portions may optionally be paged if virtual memory mode is supported in the implementation, and the paging data structures are set up correctly.\n\nIt is intended that POS code be written in a high-level language. After the POS is \"bootstrapped\" , the POS initialization, or main routine gains control in supervisor mode. If virtual memory is to be supported, the POS main routine typically sets up page tables and enables v;rt'nl memory by issuing a special simulator instruction. The main routine also allocates and mitlalizes supervisor data structures from the POS free memory area (described below), starts any I/O operations on devices that are used by the POS (such as a clock), and creates and loads the initial process context. When the initialization is complete, control may be transferred to the initial process context.\n\nAfter initialization, the POS is event-driven. POS routines are invoked when:\n\n• user-mode code issues a trap instruction. When this occurs. the simulator transfers control to the POS trap handler in supervisor mode.\n\n• user-mode code causes an exception, such as a page fault. floating point exception, access violation, etc. In this case, the simulator transfers control to the appropriate POS exception handler in supervisor mode.\n\n• a (simulated) device completes I/O and the simulator causes an interrupt handler in the POS to be invoked.\n\nPointers to the trap, exception, and interrupt handlers are contained in a system control block (SCB) located in the POS free memory area (see next section). The POS initialization routine is responsible for setting up the SCB and storing its address in a simulator register.\n\nData structures accessed by the simulated machine would normally be contained in the free memory area. The free memory area is the memory left over in (simulated) physical memory after the prototype operating system code and data are loaded by the bootstrap procedure. The POS is responsible for allocating the required data structures from the free memory area. Supervisor stacks, process control blocks, I/O buffers, and the system control block (section 2.5) are allocated from this region. If a page-mapped virtual-memory system is being implemented, then a physical page frame cache and any page-mapping data structures (such as page and/or segment tables) will also have to be allocated from this region.\n\nThe POS free memory area is fixed in size and can not be dynamically grown, since its size is directly determined by the amount of physical memory configured into the simulated system.\n\nMultiple process contexts are managed through the use of a data structure known as the context information block (Cm). A new context is created (in supervisor mode) by using a simulator priv ileged instruction SIMcreatectx O. SIMcreatectx 0 writes the new cm to an address supplied by the caller. The cm is an opaque data type whose contents are used by the simulator to load the context when SIMsaveloadctxO is called.\n\nSIMcreatectxO is callable by supervisor-mode code and requires the following as arguments:\n\n• a supervisor and user stack pointer that are to be used by the new context.\n\n• the address of a POS routine called the context initialization routine. When a process context is loaded for the first time, the context initialization routine gains control immediately in supervisor mode, using the new supervisor stack.\n\n• a single longword argument that is supplied to the context initialization routine.\n\n• a user-mode program counter that control is initially transferred to when the new context enters user mode. This address should be in the user-mode virtual address space of the simulated machine.\n\n• an address that the newly-created cm is to be copied to. This should be a location somewhere in the POS free memory area (typically, it would be part of a process control block).\n\n• the address of a longword array that contains initial values for the memory management registers that will be set when the context is loadedfoot_3 .\n\nThe context initialization routine could be used to install page-mapping tables for the user-mode address space, and to complete the setup of the user-mode part of the context.\n\nAn initial version of the simulator has been designed and implemented using BSD4.x ( [3] and [4]) as the host operating system. This implementation supports most of the components of the model as presented in the previous section, with the exception of virtual memory.\n\nIn the UNIX-based version of the simulator, all simulator routines are loaded into the same ex ecutable image as the prototype operating system. Thus the simulator and POS run as a single UNIX process. UNIX signals are used to simulate device interrupts and traps, and to detect ex ceptions. Host machine-specific code is required in the UNIX-based simulator to alter and restore signal contexts during interrupt, trap, and exception handler delivery and also to support context switching.\n\nDisk, terminal, and clock devices are simulated using standard UNIX system calls. Disks are implemented using read/write/seek calls within a single container file (a standard UNIX file that contains the data that is stored in the sim'1htf'd disk). Clocks are implemented directly off the internal virtual timer described below. Termmals are implemented using either an X-window with polling [1] or the default tty the simulator was started from.\n\nDevice access is handled via a small number of simulator procedures that allow device registers to be read or written. The device is identified to these routines via a handle, which is an opaque data type corresponding to the device. In the UNIX implementation, the handle is simply the address of a data structure corresponding to the device.\n\nAn internal, periodic virtual timer is started during simulator boot. The timer interval is adjustable via a compile-time constant; the default is 10ms. The virtual timer handles device I/O completion, and polls the simulator terminal devices for any characters typed in the corresponding windows. When a device operation is initiated, an I/O delay is implemented by queuing the request to an I/O pending queue. There is a separate queue for each IPL. A delay timeout is associated with each request, and is configurable per device. In most cases, even though a delay is present, the actual I/O is completed immediately (synchronously) before the I/O request is inserted in the I/O pending queue. However, the appropriate status bits in the device registers are not set, and an interrupt is not delivered, until the I/O request completes its delay in the I/O pending queue.\n\nWhenever the virtual timer expires, a VTALRM signal is delivered to the process, which in turn invokes the simulator's timer handler. The timer handler examines the I/O pending queues, starting with the highest IPL queue. If a request is found that is due to be delivered, the return signal context is modified so that the appropriate interrupt handler will be invoked. The previously interrupted context is stored on an internal \"interrupt stack\". Each entry on the interrupt stack contains the UNIX sigcontext structure for the interruption point, plus some additional information used by the simulator (such as the PSR at the time of the interrupt).\n\nIf an I/O request's delay has expired, but the current IPL of the simulated machine is too high to deliver it, the timer handler sets a bit in the PIR register and exits. Whenever an SHirei or SIMsetipl instruction is executed, the simulator checks the PIR register to see if any pending inter rupts can now be delivered. Since the simulator's SIMrei and SIMsetipl routines are also initiated by sending UNIX signals, they also save and alter signal context when delivering previously-pending interrupts.\n\nSince the default simulator terminal uses a simple X-window to provide terminal emulation, it is necessary to poll the window for any characters that may have been typed in it. In order to support polling, a special request is inserted in the I/O pending queues during terminal device configuration. This request is never removed from the queue; it is simply there to make sure the associated device is polled every virtual time-out interval. If a character is found during terminal device poll, and the appropriate bits are set in the control and status registers, the I/O is completed. This mayor may not result in an interrupt, depending on whether interrupts are enabled for the device.\n\nWhen the pas issues a trap instruction, a simulator routine sends a UNIX signal (using the kill system service) to the process. The signal handler alters the return signal context so that the trap handler is invoked; using the same methods described in the previous section. In this sense, a trap is analogous to an IPL 0 interrupt.\n\nDuring simulator startup, a special signal handler is defined to catch allY I'}{,:eption-related signals (such as SIGSEGV, SIGBUS, and SIGFPE) generated by the running process. This signal handler again alters the return signal context so that the pas exception handler is invoked. When the exception handler returns, the instruction that caused the exception is executed again.\n\nProcess context switching is supported via simulator procedures that create, save, and load contexts. The save and load operation is done within a single procedure, SIMsaveloadctxO.\n\nThe create context procedure SIMcreatectxO sets up the initial supervisor stack for the new context, and stores context state in a block of memory provided by the caller (usually the context block would be part of a process control block). Along with the context block's address, the caller supplies the initial supervisor-mode pc and sp for the new context, the initial user-mode pc and sp, and a single longword argument that is supplied to the initial supervisor-mode function. The supervisor-mode stack is used as the starting point to build the new context's supervisor stack.\n\nProcess context is normally switched while in an interrupt or trap handler, just before return to user mode. As described in the sections above, a signal initiated the interrupt or trap, and therefore the signal context to restore when the handler completes is stored on the simulator's interrupt stack.\n\nDuring context switch, this saved return context is modified according to the context state saved in the context block being loaded. The current context state is also saved in a different context block provided by the caller, so that it can be reloaded at a later time.\n\nOne final simulator routine exists for modifying an active context: SIMsetusrctxO. This routine allows modification of the user-mode portion of the context, specifically all the general-purpose registers. SIMsetusrctxO serves two purposes; it allows return status to be set for a trap in struction (by setting the register that normally contains return status; this is dependent on the host system's compiler), and setting the arguments to the initial user-mode routine that runs in a context. Since SIMsetusrctx 0 allows direct modification of machine registers, its use is highly host-machine dependent.\n\nThe UNIX implementation of the simulator was designed and implemented in approximately 3 months by a single grad student, with faculty assistance during the design phase. All functionality (except for virtual memory support) is present, and the resulting simulator library is currently being used in the operating systems course at Brown. The entire simulator library required only 20 C modules with a total of approximately 3300 lines of code. The most difficult part of implementing the library was providing the host machine-specific signal context modification routines.\n\nSupported host machines are the SPARCstation (sun4) [10] running SunOs 4.1 and the VAX running VAX-ULTRIX V4.0. MIPS [2] support could be added quite easily, but was not completed due to time constraints.\n\nThe UNIX-based implementation described in the previous section allows many machine features to be simulated in a way that is relatively non-intrusive to the prototype operating system. However, the virtual memory capabilities presented in section 2.6 can not be easily simulated using the functionality available on standard UNIX systems. Notably absent from the UNIX system call interface are functions that allow direct manipulation of a process' address space -such as explicit mapping of address ranges, reading from or writing to another process' address space, and user mode (application-level) detection of page-faults.\n\nOSF /1, on the other hand, provides the system calls and memory management support required to implement the virtual memory architecture of the simulator. By using Mach memory management features present in OSF/1, the simulator can be built in a way that minimizes host machine-specific code, and avoids the necessity of leaving user-mode to perform virtual memory mapping and page fault detection.\n\nOther features of Mach and OSF/1foot_4 that are used to improve the implementation of the simulator are threads ( [11]) and dynamic loading. Threads allow a a single simulator server task to logically divide its work so that a unique thread deals with each logical type of request. For example, separate threads are used within the simulator server task to simulate I/O on devices that are configured into the simulated machine. Mach system calls [8] allow the state of the single thread running the prototype operating system (POS) to be modified so that trap and interrupt handlers can be invoked. The dynamic b<l.di!!g capability available in OSF/1 allows code to be dynamically mapped into the simulator environment in a host machine-independent manner. The use of threads and dynamic loading is described further in the following sections.\n\nThe OSF /l-based implementation is envisioned to eventually contain the following components 9 :\n\n• a simulator task that handles simulated machine startup, device I/O, context creation and switching, simulator instructions, and serves as a Mach external memory manager in order to provide simulator virtual memory support.\n\n• a simulator library that is linked with POS code to produce one or more process-context task(s). The simulator library is also linked against any user-mode images written to run within the POS.\n\n• a console monitor routine (CMR) that is used during the startup sequence. One of the CMR's main functions is to start the boot sequence when the appropriate command is entered on the console terminal. The CMR also allows clean exit from the simulator via an \"exit\" command.\n\nThe CMR could easily be extended to provide additional functions, such as commands to peek, poke, or dump physical or virtual memory locations in the simulated machine.\n\nThe OSF /1-based version of the simulator is implemented using multiple tasks (Mach and OSF /1 terminology), otherwise known as processes (UNIX terminology). The first task to execute is the Sim task, which performs most simulated machine functions and manages all other tasks that are part of the simulator environment. The tasks controlled by the Sim task are called process context tasks, because each of them corresponds to a single process context created by the POS.\n\nOnly one process-context task is active at any given time. The Sim task activates (resumes) and deactivates (suspends) process-context tasks whenever the POS issues the simulator's context switching instruction.\n\nThe overall architecture of the simulator is shown in figure 2. The small boxes represent threads that execute within the Sim task. The lines between task boxes and triangles indicate the use of :\"lach memory objects to simulate physical memory, as described in section 5.2.\n\nThe Sim task is essentially a multi-threaded, user-mode server that handles all simulator device I/O, privileged and special instructions, process context creation and switching, and process context memory management functions. Mach message passing, memory, task, and thread management kernel calls are used extensively by the Sim task. Additionally, the dynamic load functionality provided in OSF /1 is used by the Sim task to load the CMR and POS image files into the initial process context task (see below). The OSF /1 load interface allows these images to be read into a target task's address space, and thus obviates the need for special-purpose, host machine-specific loader code to be part of the simulator.\n\nThe Sim task also serves as an external memory manager, or pager, for the process-context task(s).\n\nIn this way the Sim task can be notified whenever a process context task accesses a page that is not logically resident in the simulated machine. This process is described in section 5.2.\n\nThe different types of routines that execute within the Sim task are shown in figure 2. The boxes containing thread routines indicate that the associated routines execute as a distinct thread or threads within the Sim task.\n\nIn order to provide the same virtual address space to all process contexts running within the POS, a separate task is created on the host system for each distinct process context created by the POS.\n\nThe Sim task will control the process-context tasks; activating the appropriate one when context switches occur. Only one process-context task will be active at any given time; the rest will be suspended. The process-context tasks run POS code, as well as code loaded by the POS. When the simulator is booted, the Sim task creates (forks) a single initial process context task running the console monitor routine (CMR) and later (after the \"boot\" command is issued to the CMR), the POS. Whenever a new process context is created by the POS, a new task will be forked (by the creating process-context task) in which the new context will run. If no new contexts are ever created, there will only be a single process context task. An example of the simulator task hierarchy with four active process-context tasks is shown in figure 3. The curved arcs in the figure represent the remote procedure call communication path between each process-context task and the Sim task, as described in section 5.1.3.\n\nEach process-context task contiguously maps the same supervisor address range to the POS code and data areas. Thus supervisor-mode address space can be viewed as a shared memory segment existing between the process-context tasks and the Sim task.\n\nUnlike the Sim task, each process-context task has only one thread. The state of this thread may be modified by the Sim task so that interrupt, trap, or exception handlers can be invoked. This procedure is described in section 5.4.4.\n\nThe code that runs within a process-context task is shown in figure 4. A process-context task runs prototype operating system code, as well as code dynamically loaded by the POS as part of the process context. The simulator interface library consists of remote procedure call interface routines that are used to communicate with the Sim task (see section 5.1.3).\n\nThe Sim task and process-context task(s) communicate through shared memory (see section 5.2.2) and by issuing remote procedure calls (RPCs). Mach and OSF/l support the RPC interface by supplying the Mach Interface Generator tool (MIG) [7]. MIG allows the interface between communicating tasks to be defined in a way that relieves the programmer from worrying about encoding or decoding messages.\n\nRPCs are issued to ports (see [8]). Normally, the Sim task listens on several ports for messages explicitly or implicitly sent by a process-context task. Explicit messages are sent when a process context task issues a simulator instruction, such as SIMtrap () or SIMflushpmt (). Implicit messages are sent to the Sim task by the OSF /1 kernel when a page fault or exception occurs in a process context task. prototype operating system code simulator library routines context-specific code (loaded by paS) Most RPCs sent from the process-context task to the Sim task are bidirectional -Le. the process context task sends a request message, and then waits for a response from the Sim task. During the wait, the process-context task is in a synchronous wait state. However, even though the single thread within the process-context task is waiting for a response, the Sim task may suspend and then abort it. This results in the RPC call being cancelled, so that the state of the process context thread can be modified to invoke pas interrupt, trap, or exception handlers as described in section 5.\n\nPractical examples of the use of MIG and rerode l-'r0c~ei.ure calls on Mach-based systems can be found in [9].\n\nIn this section, the complete design for supporting various virtual memory architectures in the aSFII-based simulator is presented. The main design goal of the virtual memory component is to allow alternative memory management architectures to be implemented with minimal effort.\n\nThe Sim task contains a replaceable module that is dependent on the type of memory management architecture that is to be supported by the machine being simulated. This module is called the pmap module because it (roughly) serves a purpose similar to the Mach kernel module of the same name. For example, the a segmented, forward-based paging architecture could be replaced by a scheme that uses inverted page tables by replacing the Sim task's pmap module (and by changing the pas that interacts with it). The pmap module is discussed in the following sections on memory management where relevant.\n\nA typical address space layout is shown in figure 5. In this configuration, user-mode code and data starts at STARLUSER3A, supervisor-mode code and data at START-SUPER_VA. The privileged register area is contained within supervisor-mode space. The console monitor routine is also present in supervisor-mode space -this area, and the privileged register area are presumed to be always resident and accessible while in supervisor mode. Any access is prevented while in user mode.\n\nThe values for STARLUSER_VA, START...SUPER_VA, START-REGS_VA, and STARLCMR_VA are defined in the pmap module. These values are constrained by the host machine's available user-mode address space; that is, all simulator-defined address ranges must fit within the user-mode address range of the hosting machine.\n\nThe Sim task and all the process context tasks share the simulated machine's physical memory, privileged register, and CMR regions by mapping ranges of their address space to a single Mach memory object representing the simulated system's physical memory. This memory object is re ferred to in this document as the physical memory object (PMO). The process context tasks map the PMO (contiguously) using the supervisor-mode address range, and may map portions of it (non-contiguously) to pageable user-mode or supervisor address ranges. Thus, any given page of the PMO may be simultaneously mapped more than once by a process context task, depending on the mappings set up in the page mapping tables.\n\nThe Sim task will always be able to directly access locations mapped to the physical memory object, since it (the PMO) will be mapped to a contiguous region of the Sim task's virtual address space.\n\nIf possible, the physical memory object will be mapped using the same supervisor-mode address range that maps the object in the process context tasks. Mapping to the same address range will simplify DMA operations, since the Sim task performs the \"real\" I/O initiated by a process context task. If a particular host architecture precludes using the supervisor-mode address region in the Sim task, conversion routines will be needed to convert a process context td,s~ ::>l1pervisor-mode address to the corresponding address in the Sim task. The conversion should be straightforward; all that is required is the addition of an offset to the address in the process context tasks to get the Sim task's address for the same location\" in the physical memory object.\n\nThe following two conversion routines will be used: PMAPpostosimO and PMAPsimtopos (). In the case where no conversion is necessary, these routines will be defined as null macros.\n\nWhile in both real and virtual modes, the physical memory object is mapped into the initial process context task starting at the beginning of supervisor-mode address range and extending to the size of configured physical memory. The CMR and privileged register areas are also mapped to the PMO in both real and virtual modes. However, references to addresses outside of these ranges (such as user-mode addresses) are always invalid while in real mode. Virtual mode allows page mapping tables to be defined so that these non-physical ranges can be mapped to page frames in simulator physical memory. Supervisor-mode ranges that are not mapped to actual physical memory, CMR, or privileged register areas can also be made pageable in the same way -if the pmap supports system page table mapping.\n\nWhen virtual memory is enabled, different process context tasks may map the same physical page frame at different addresses. In this way, page sharing can be accomplished. Mapping a portion of the single physical memory object is done using the offset and size parameters of the Mach vmJl\\ap 0 system call, which allows part of a memory object to be mapped to a specified task address range.\n\nThe size parameter will normally be set to the simulated machine's page size.\n\nFigure 6 illustrates how two process contexts can share pages by mapping a range of their virtual address space to the same offset within the physical memory object.\n\nThe system page mapping tables and any other data structures required by the memory manage ment architecture must be created and installed by the POS before the simulator is switched from real to virtual memory management mode. Installation of page tables is usually accomplished by setting memory management registers with the addresses and lengths of the tables (supervisor and user -see next subsection). Switching to virtual memory management mode is done by calling SIMenablevmO.\n\nCalling SIMenablevm 0 results in an remote procedure call (rpc) to the SIM task's service port .\n\n.-\\ thread in the Sim task receives the message and calls a routine (PMAPenablevmO) in the pmap module. PMAPenablevmO performs whatever remapping is required to set the correct memory management environment for virtual mode. Normally, this means scanning the page tables pointed to by the designated memory management registers, and performing mapping operations (Mach system calls) based on the entries found in the tables.\n\nOSF/1 and Mach provide an interface that allows a user-mode server to manage memory objects mapped by one or more processes [8]. By using this interface, the Sim task is able to detect access to non-resident pages (among other duties. the Sim task acts as a Mach external pager for the memory objects representing the simulator's physical memory). The Mach kernel essentially acts as a cache for pages mapped to memory objects. When the cache needs updating or flushing, the appropriate routine in the external pager is invoked.\n\nThe Mach external pager interface also allows pages cached by the Mach kernel to be locked from read or write access, and the external pager to be notified when either type of access is attempted. The server can then optionally unlock the referenced pages so that access will succeed. This feature is used by the Sim task to support the referenced and modified bits that are part of the generic memory management architecture supported by the simulator.\n\nIn the following sections, certain Mach memory management remote procedure calls (routines whose names start with the prefix memory _obj ect_) are referenced. These routines are part of the external pager interface supported by Mach and described in [8].\n\nPages that are mapped by the active POS page tables, but are not resident, are mapped by the Sim task to a particular offset of a dummy memory object (DMO) that is also managed by the Sim task through the Mach external memory management interface. The protection of the the DMO is set to the protection value found in the POS page tables, but data is never actually provided for any page of the DMO. The reason for using a dummy memory object in this way is to cleanly detect attempted access of a non-resident page and, at the same time, handle protection violations.\n\nWhen a non-resident page is accessed in a process-context task, and the protection value permits access, the Sim task is notified (via the external pager routine memory _obj ect_data.xequest) and supplied with the offset within the DMO that plOduced the fault. The Sim task can then initiate page-fault processing in the faulting process-context task. When the page is made resident by the POS page-fault handler (see below), the Sim task unmaps the page from the DMO and maps it to an offset within the PMO that corresponds to the pfn used to hold the page's data.\n\nIf a non-resident page is accessed, and the protection value does not permit access, Mach will send a message to the task's exception port. A thread in the Sim task listens on this port, and changes the state of the process context task so that the exception handler is invoked (see section .5A.3).\n\nThe detection of a page fault has been described in the previous section. Figure 7 illustrates the sequence of events that occur after the Sim task determines a page fault has occurred.\n\nAs shown in figure 7, normal page fault processing performed by the Simulator proceeds as follows:\n\n1. The Sim task determines that a page fault has occurred because the Mach kernel issues a memory _obj ecLdata.xequest 0 RPC to the Sim task specifying a page mapped to the DMO.\n\nabout the accessed page from the page mapping tables.\n\n3. If the page is not resident, the process context task's state is saved, and then modified so the POS page fault handler is invoked when the process context task is resumed. The page fault handler's address is obtained from the system control block (see section 2.5). Arguments to the page fault handler include the faulting address.\n\npage-fault occurs 1 Mach kernel sends memorY.Dbject..data.request message . ---v_e_s-<b>N_O -, resident? Provide demand-zero page DONE Modify pas state to invoke page-fault handler Figure 7: Page fault processing POS issues flush page mapping table instruction Yes unmap from DMO map to PMO No set new protection lock page for read access 4.\n\nThe process context task is resumed. If the page-fault handler is invoked, it performs whatever actions are required to obtain the page data and update the page-mapping tables. When complete, the page fault handler must call SIMflushpmt (). SIMflushpmt () is described in the following section.\n\nAny time the data structures used by the memory management architecture are modified, the Sim task must be notified so that the required changes in page protection and mapping can be performed. Therefore whenever the POS modifies the page tables, it should call SIMflushpmt (), which does the following (see figure 8):\n\n1. It issues an fpC call to the Sim task's service port.\n\n2. The Sim task receives the \"flush\" message, and calls PMAPflushpmt (), a routine in the pmap module. PMAPflushpmt () determines which pages have been changed in terms of validity, protection, or reference bit state. (Note that this may require the pmap to maintain a copy of the previous page-mapping tables for comparison with the newly-modified tables).\n\n3. If a page has become invalid, the offset within the physical memory object to which the address range was mapped must be unmapped. The page is unmapped by calling the Mach routine vm_deallocate O.\n\nIf a page has become valid, it must be mapped. The physical memory object is mapped using the Mach call vm...map (). The pfn found in the page table entry is multiplied by the page size to determine the offset argument of the vm...map () call. Page access is set to the protection argument, and PMAPreferencedO is called for the page so that the reference bit is set, if supported by the pmap module. Finally, memory _obj ect-lock...request 0 is called so that the Sim task is notified when write access is attempted to the page.\n\nIf a page's protection has been changed by the POS, and the page is valid, the Mach vm_protect () routine is called to set the new protection for the address range mapped to the page(s).\n\nIf the protection is changed for an invalid page, no actions are required.\n\n6. If the reference bit has been cleared by the POS, the page is locked from any access so that the mach kernel will call a memory manager routine (memory_object-lock...request) when access is attempted. The actions taken in this routine are described in the next section.\n\nAs implied in the previous section, the referenced and modified flags will be implemented using the cache management routines provided by Mach. The basic idea is to lock a logically mapped, resident page so that the memory manager (i.e. the Sim task) is notified whenever a read or write access is attempted to the page. The locking only has to be applied until the first read or write attempt, after which the page can remain unlocked until the POS or pmap resets the bits in the page table entry indicating the access has occurred, or until the page is invalidated and later revalidated.\n\nr pon notification of a lock request, the Sim task calls a routine in the pmap module that deals with the reference (typically by setting a bit in a page table entry). Afterwards, the page is unlocked so that when the process context task that caused the reference is resumed, the page will be accessed successfully.\n\nThe following describes, in detail, how the referenced and modified flags will be supported (also see figure 8):\n\n1. When a page is made valid by the POS, the POS updates the page table entry within the page-mapping tables, and calls the SIMflushpmt 0 routine to flush the page tables. The Sim task receives the flush notification, and calls PMAPflushpmt 0 as described in the previous section. If the page has just switched from being invalid to being valid, go to step 2. If the referenced bit has just been cleared for a valid page, go to step 3.\n\nIf the page is protected so that write access is allowed, the Sim task then calls the Mach routine memory_object-lock-requestO so that read access is permitted on the page, but any write access causes a lock request notification to be delivered to the memory manager (i.e. the Sim task). The routine PHAPclearmodifiedO is called so that the modified bit in the PTE is cleared.\n\n3. If the referenced bit has just been cleared in a page table entry for a valid page, and read access is permitted to the page, then the memory _obj ect-lock-request 0 call is issued so that read (and write, if the page is protected r jw) attempts cause a lock notification to be delivered to the memory manager.\n\nThe modified flag is supported in a similar manner:\n\n1. When code running in a process context task attempts a write to the page, the Mach kernel calls the memory_object_data_unlockO routine in the memory manager (Le. the Sim task) in order to deliver the write-lock request notification. This routine calls the PHAPmodifiedO routine, which will cause the referenced and modified bits in the page table entry to be set, if such bits exist in the architecture. Then, the Sim task releases all locks on the page, using memory_ob j ect-lock-request 0 .\n\nTo summarize; if a page allows write access, then a write lock will be placed on the page when its PTE is changed from invalid to valid, and the modified bit will be cleared in the PTE. When a write access is attempted, the lock will be released and the pmap notified so that the modified bit can be set in the PTE. Once set, the modified bit remains set until the page is invalidated and revalidated.\n\nAlso, when a PTE changes from invalid to valid, the referenced bit in the PTE is set. If the pas later clears the referenced bit for a valid page, a read lock will be placed on the page so that a subsequent read attempt will result in the referenced bit being reset.\n\nNote that if a write attempt is made to a page that is protected read-only, an address exception will occur instead of a lock notification. Lock requests for write notification will never be issued to read-only pages.\n\nThe pas code is responsible for loading user-mode code, usually from image files stored in a simulated disk device. User-mode code can not call any of the simulator-supplied routines, with the exception of SIMtrapO, which is used to emulate a trap instruction. If a privileged simulator instruct is called from user mode, a privileged instruction exception is delivered to the process.\n\nUser-mode code is subject to paging, and therefore the pas must ensure that the required page mapping tables exist before any user-mode code is executed.\n\nThe simulated machine supports two execution modes (also called access modes): supervisor and nser. Page protection is based on the current execution mode; for example a page could be protected user-mode no access, supervisor mode read access. In order to support different protections for each mode, the simulator has to be notified whenever the simulated machine is switching between the two modes, and has to issue Mach system calls to change the protection on pages that have different protections for each mode.\n\nThe simulated machine switches mode whenever a trap instruction is issued from user mode, or when the return from trap, exception, or interrupt instruction is returning to user mode. In both cases, the Sim task is notified via an rpc call from the active process context task (see sections 5.4.2 and 5.4.4). The Sim task calls PMAPmodeswitch( protect...rtn ) whenever the mode is being changed. PMAPmodeswitchO must scan the page mapping tables and call protect...rtn for each page or range of pages that need their protections changed. protect...rtn calls the Mach routine vm..protect 0 to actually accomplish the protection switch.\n\nWhen a device register is updated in a way that semantically results in the commencement of an I/O operation, the Sim task detects the update, notifies a thread in the Sim task to process the I/O operation, and updates a device register when the I/O is completed. If an interrupt is to be delivered, the active process context task is suspended and one of the following is done:\n\n1. If the current IPL of the machine is less than the IPL of the device, then the state of the POS thread is altered so that the interrupt handler for the just-completed 1/0 uevice is executed when the process context task is resumed. The Mach primitive thread_set-stateO will be used to alter the state of the thread. The POS thread is then resumed and the interrupt handler executes immediately. See section 5.4.4 for details of the interrupt delivery mechanism.\n\n2. If the simulator is running at an equal or higher IPL than the device that has just finished I/O, a bit in the simulator's Pending Interrupt Register (PIR) is set to indicate the pending interrupt. The SIMreiO or SIMsetiplO code will detect this bit and deliver the interrupt when IPL is being restored to a lower value.\n\nSIMrei 0 and SIMsetiplO are described in detail in section 5.4.5. Also, the complete sequence of operations that need to be done when altering the state of the POS thread is described.\n\nThe POS starts DMA operations by loading the device address and memory address registers, and then setting a bit in the device control register using SIMdevctlO. The memory address must be a supervisor-mode address. Since the Sim task maps the physical memory object using the same supervisor-mode address range as the process context tasks, the Sim task can use the memory address directly to perform the I/O. For example, to perform a disk read operation, an I/O thread running in the Sim task would use the value in the memory address register as the address of the target buffer.\n\nWhen a trap, exception, or device interrupt occurs, the Sim task takes special actions that may result in altering the state of the active pas thread. Mach kernel calls facilitate these activities and allow the machine-specific aspects to be reduced to very few lines of code.\n\nBefore the details of trap, exception, and interrupt processing are presented, it is necessary to describe exactly how the state of the single pas thread will be altered when a trap, exception, or interrupt handler is invoked, and how the state will be restored when the handler exits.\n\nThe Sim task maintains a data structure known as the context stack. Whenever the flow of control in the pas thread is altered to invoke a handler, information pertaining to the thread and machine context that existed before the alteration is stored in a structure and pushed onto the context stack. This information minimally includes the program counter, the stack pointer, contents of the general-purpose registers, and the PSR.\n\nThe handler must always exit by issuing a SIMreiO instruction. When the simulator receives notification from SIMrei () , it pops the context stack and restores the context that was previously interrupted. At most, there can be 17 entries on the context stack, since there are 16 interrupt priority levels whose co:::rcs;,onding devices could interrupt an active trap or exception handler that interrupted user-mode code (note that using IPL 0 for a device interrupt level is not supported).\n\nA trap is initiated by user-mode code executing in the process context task, but most of the work is done in the Sim task. The sequence of events is described in the following steps:\n\n1. The user-mode code calls SIMtrap 0 supplying two parameters that are to be passed to the trap handler.\n\n2. SIMtrapO packages the two parameters into an rpc to the Sim task service port, also passing the arguments supplied to SIMtrap O.\n\n3. The Sim task suspends the pas thread, stores the context information on the context stack. and then aborts the pas thread (thus aborting the rpc). It then uses the thread_set-state () kernel call to modify the suspended state of the single pas thread so that the pas trap handler will be invoked when the thread resumes. The address of the trap handler is obtained from the system control block (SeB). The trap arguments are pushed on the target supervisor stack.\n\n4. The PMAPmodesvitchO routine 1S called to set the protection of the memory regions in supervisor-mode address space.\n\n5. The Sim task resumes the pas thread.\n\n6. While the POS thread is handling the trap, it may call SIMsetusrctxO to set the return status for the trap. This routine allows modification of the context information stored on the context stack.\n\n7. The POS thread then calls SIMrei 0 . SIMrei 0 will issue an rpc to the Sim task, which will result in the suspended POS thread being resumed (details below) in the previously interrupted thread context.\n\nExceptions occurring in the POS or the user-mode code running \"within\" the POS thread will be detected by Mach and a message will be sent to the thread's exception port. The receive rights for the exception port are passed to the Sim task during process context task creation (see section 5.7). Therefore, the Sim task receives exception notifications for all process context tasks, and initiates exception handler invocation in the same way described for traps above.\n\nThe conditions under which an I/O thread causes an interrupt handler to be invoked in the currently active process context task was described in section 2.4. The I/O thread does the following in order to deliver the interrupt:\n\n1. The Mach system call msem-.lockO is used to obtain a the system-wide simulator semaphore (see section 5.6). This semaphore is used so that interrupts can not cause an interrupt handler to be delivered in the middle of the processing of a simulator instruction.\n\n2. The POS thread is suspended and aborted. The context at the time of the suspend is saved on the simulator's internal interrupt stack.\n\n3. The appropriate POS interrupt handler is obtained from the system control block, and the state of the POS thread is altered so that the interrupt handler will be invoked when the thread is resumed.\n\n4. The Mach system callmsem_unlockO IS used to release the simulator semaphore, and the POS thread is resumed.\n\nThe return from exception or interrupt instruction is handled mostly in the Sim task, and \\vill be implemented as follows:\n\n1. The code running in the POS thread (within a process context task) calls SIMrei 0 to exit from the exception, fault, trap, or interrupt handler.\n\n2. SIMreiO calls msem-.lock to obtain the system-wide simulator semaphore, and then issues an \"rei instruction\" rpc to the Sim task's service port.\n\n4. The context information that is need to load the simulator's privileged registers is stored in a context information block whose address was supplied by the caller of SIMcreatectxO. This address must be in supervisor-mode address space.\n\n5. The parent process-context task is resumed.\n\nContext switching is initiated when an existing process-context task calls SIMsaveloadctx O. The parameters to this call include a pointer to a block that will be used to store the current con text, and a block that contains the context to be loaded. The following processing occurs when SIMsaveloadctxO is called:\n\n1. The existing process-context task issues a \"context switch\" rpc call to the Sim task's service port.\n\n2. The Sim task receives the message, and suspends the current process context task. The privileged simulator registers and other state information are saved in the context information block whose address was supplied by the caller of SIMsaveloadctx ().\n\n3. The Sim task then retrieves the context information block for the context to be loaded, and uses it to 10rd the simulator registers.\n\n4. The Sim task then resumes the new process-context task that was previous created as de scribed in the previous section.\n\nThe system-wide simulator semaphore has already been discussed in sections 5.4.4 and 5.4.5. In each rpc stub that is called by POS code to initiate a simulator instruction, the simulator semaphore is obtained by calling msem-l.ock O. When the rpc returns, or when the instruction is complete (some instructions never return, such as SIMrei) msem_unlock 0 is called to release the semaphore.\n\nThe Sim task tries to obtain this semaphore whenever it is about to deliver an interrupt. Therefore, the semaphore prevents simulator instructions from being interrupted while being processed.\n\nIt is also necessary to coordinate access to device registers between I/O threads executing in the Sim task. In this case, the pthread mutex mechanism is used.\n\nThe Sim task is started manually by the user, with an optional configuration file as a command-line parameter. The Sim task performs the following initialization steps:\n\nConfigures the simulator -the configuration file, if present, is read, and the specified devices are \"created\" (data structures are allocated in the Sim task to represent the devices). If no configuration file is supplied, a default configuration is created.\n\nPort allocationports are allocated for the physical memory object, the dummy memory object (see section 5.2.6), and the Sim task's general-purpose service port. A port is also allocated to serve as the bootstrap port, and the Mach system call to set the bootstrap port is called.\n\nInitial process context task creationthe Sim task forks the initial process context task. After the fork, the Sim task starts a single thread listening on the ports allocated in the previous step (a port set is used to group the ports into a single entity). The process context task sends a initial process context task created message to the bootstrap port, which is received in the Sim task.\n\nVirtual memory initializationwhen the Sim task receives the initial process context task created message, it suspends and aborts lO the single POS thread, then scans the address space of the process context task and deallocates all memory regions that overlap the address space of the simulated machine. The Sim task then maps the physical memory object (PMO) to the supervisor address range in the process context task.\n\nActivation of the CMRthe Sim task loads the CMR image into its (Le. the Sim task's) address space, and then uses Mach vm calls to copy the image into the process context task's address space l l . The state of the single POS thread is modified so that the CMR main routine will be executed when the POS thread is resumed. The stack pointer is set to the highest physical address of simulator memory. The POS thread is then resumed.\n\nCMR initializationthe CMR retrieves its bootstrap port, and issues a POS started rpc to the Sim task. The Sim task receive'; this ~nessage, deallocates the CMR from its own address space, and maps the supervisor mode address range to the PMO. At this point, the Sim task initializes device registers located in the register page of supervisor-mode address space. The Sim task then returns send rights' to its service port as a return value to the POS started rpc. The CMR receives the port, and loads it into a reserved register located in the register page of supervisor-mode address space. (The service port name becomes part of the process context, since each rocess context task will have a unique name for this port). The CldR can now use the normal simulator mechanisms for I/O calls.\n\n\"Booting\" the POS is initiated by a command typed on the console terminal. The CMR parses the command, and sends a POS boot message to the Sim task's service port. The Sim task immediately suspends and aborts the single POS thread. The Sim task then unmaps itself from the supervisor address space, loads the process context task image into its own address space, and uses mach vm calls to copy the POS image into the process context task's supervisor-mode address space.\n\n(The POS will be linked with a special switch to set its starting address to the beginning of the supervisor-mode address range. Thus the OSF/1 loader will perform the correct address fix-up since this is the same address range in which it will be copied into the process context task. The reason for temporarily unmapping the supervisor area in the Sim task is to allow the loader to function properlythe load call will fail if the address range is already in use).\n\nThe POS thread's state is altered so that the main POS routine will be invoked when the thread is resumed. The pfn of the first free memory page is supplied as the first argument to the main 10 the abort is required before the state of thread can be modified 11 the asp/1 load interface does not currently support directly loading images into another task's address space. This may be an option in future versions of asp/1 routine, the size, pages of the entire physical memory is the second argument. The Sim task then re-maps the PMO to the supervisor-mode address range, and resumes the process context task.\n\nThe OSF/I-based implementation has been partially implemented. The basic virtual memory func tionality has been prototyped; including page-fault detection, delivery, referenced and modified bits support, and page table flushing. A pmap module exists for the memory management architecture outlined in appendix B.l. I/O device emulation using threads in the Sim task has also been coded and tested, and interrupt delivery is working. Task and thread synchronization, after a great deal of debugging, is now working using a single system-wide simulator semaphore and multiple pthread mutexes to control access to device registers and internal device-related data structures.\n\nUser-mode support (the PMAPmodeswitch() routine and SIMtrap()) has not yet been implemented, nor has context creation and switching. The dynamic image file loading required to load the CMR and POS has not been coded, because the current version of OSF/I (snapshot 5) does not support the loader interface. Dynamic image file loading and context switching support are the major pieces of work remaining to be done in order to complete the OSF /I-based simulator.\n\n:31\n\nAn operating system development environment has been created that allows operating system code to run in native mode on the host machine as a user-mode application. A generic machine model has been defined, and the operating system/machine interface is emulated using standard procedure calls. The simulated machine is configurable in terms of the virtual memory architecture supported. The asynchronous behavior of most multi-device computer systems is emulated fully using interrupt priority levels.\n\nTwo implementations have been prototyped -the first was built on standard BSD UNIX [3], the second on an OSF/l-based system. The OSF/l-based system allows emulation of a virtual address space, with full paging capability. This can be achieved using the sophisticated memory management kernel interface available with OSF/1.\n\nThe following are ideas for possible further study related to the project:\n\nOperating system analysis tools -it would be useful to measure operating system performance without including overhead introduced by the simulator.\n\nA:l int~grated programming environment -writing operating system code involves speciai programming paradigms. A tailored programming environment, optimized for operating sys tem development, could be created that could further speed the development process. It should be relatively easy to build• this environment on top of a general-purpose, extensible programming environment such as FIELD [12].\n\nParallel architecture support -the current OSF /1-based simulator could be extended to sim ulate a parallel machine by allowing multiple process-context tasks to execute simultaneously (given a parallel host system).\n\nTransparent simulator operation -the current simulator suffers from the requirement that in order to modify some simulator registers, an explicit procedure call must be used so that the simulator can be notified. For example, modifying a device control register can not be accomplished simply by writing directly to the register. Instead, SIMdevctl() must be used otherwise the simulator would not be notified when modifications to the register are made. If Mach offered a write-through cache option in conjunction with the external pager mechanism, the simulator could be notified transparently whenever such modifications are performed. The same technique could be used whenever page tables are modified, so that the explicit flush page-mapping tables instruction would not be required.\n\nThe clock device provided by the simulator allows a single timer to be set. A bit is set in the clock status register when the time expires. An interrupt can be generated if interrupts have been enabled for the clock device.\n\nThe clock timer value is set by writing into the clock's write register the number of microseconds from the current time that the timer is to expire. The resolution of the clock is currently 10 milliseconds (10,000 microseconds) and runs off an internal simulator timer -therefore setting the clock's timeout value to less than 10 milliseconds will result in a time interval somewhere between oand 10 milliseconds and is equivalent to setting the timeout value to O.\n\nAdditional clock devices can be created using the simulator configuration interface.\n\nClock control register The START bit causes the clock to begin operation. The ENABLE bit, if set, causes an interrupt to be generated when the clock timer expires. Setting the HALT bit stops the clock, and clears the ALARM and STATE bits in the status register (see below). The bit positions are defined in sim.h.\n\nThe IPL of the default clock device is 14.\n\nClock status register The clock status register has two bits: ALARM and STATE. \"l'he ALARM bit is cleared when the HALT bit is set in the clock control register, and is set by the simulator when the timer expires. An interrupt is delivered (or made pending, based on the current IPL) only if the ALARM bit is clear when the timer expires and the ENABLE bit has been set in the control register. The STATE bit is set after the START bit is set in the control register, and is also cleared when the clock is halted.\n\nClock device write register The clock write register is set by using SIMdevYreg. The value written to the register is a longword unsigned value corresponding to the number of microseconds from the current time until the time the clock timer is to expire.\n\nTraps, exceptions, and device interrupts are events that cause the current flow of execution to be interrupted, with possibly a change of mode and stack from user to supervisor. Traps always occur synchronously and from user-mode code -they are typically used as a way to enter supervisor mode to perform a system call. Exceptions also occur synchronously, and are detected by the simulator when an illegal operation or memory access is attempted. Device interrupts occur asynchronously when a device has completed I/O and the device has been enabled to generate interrupts (as described in section A.3).\n\nSynchronous traps are generated using the following simulator function: val = SIMtrap( al, a2) -causes a trap to occur, and the arguments al and a2 become the two arguments of the trap handler. Typically, al would contain a trap code and a2 would contain the address of an argument list, but there are no restrictions on what the arguments are used for. The return value in val is set, after the trap has been processed, to the contents of the user-mode register that is normally used to return status on the target architecture. On the SPARCstation, this is iO; on the VAX, it is rOo The contents of this register, and hence the value returned in val, can be set from supervisor mode during trap processing by calling SIHsetusrctx (see section AA.8).\n\nSIMtrap is the only simulator routine (besides printf) that may be called from user mode. If it is called from supervisor mode, an illegal instruction exception is generated.\n\nWhen SIMtrap is called by the operating system code, the simulator freezes and saves the state of the user-mode code running on the user-mode stack, and starts the trap handler running on the supervisor stack. The address of the trap handler must have been previously stored in the system control (or trap vector) block. If this trap handler address is set to an invalid address in the SCB, or if the SCB register is set to an invalid address, unpredictable results will occur.\n\nThe trap handler must end with a SIMrei instruction in order for control to return to the frozen user-mode program counter and stack; see section AAA for more information.\n\nException handlers can be specified (by initializing pointers in the trap vector block) so that control is transferred to an exception handler, in supervisor mode, when one of the following events occurs:\n\n• an attempt to issue privileged (simulator) instructions while in user mode or to issue SIMtrap while in supervisor mode\n\n• access violation\n\n• illegal instruction encountered\n\n• floating-point error When an exception occurs, the simulator switches mode and stack to supervisor (if not already running in supervisor mode). If an exception handler has been set in the TVB for the type of exception, the handler is called with the exception code (defined in sim.h) as the first argument, the program counter where the exception occurred as the second argument, and the PSR at the time of the exception as the third argument. Exceptions may occur in either supervisor or user mode, and at any IPL. If the exception handler does not take steps to remedy the faulting situation by altering the context, control will revert back to the offending instruction when the handler issues SIMrei, thus causing an endless cycle of exceptions.\n\nAll the devices described in chapter A.3 can be set up to generate interrupts when an operation completes. One interrupt service routine (ISR) exists for each interrupt priority level (IPL). The However, routines are provided that allow the contents of the saved user-mode general-purpose registers to be examined and modified by supervisor-mode code. By using these routines, it is possible to:\n\n• set the return status of the SIMtrap routine, so that status can be returned from a system call. Note that using the normal C method of supplying a value to the return instruction of the trap handler will not work, because trap handlers must end with SIMrei and should not use return.\n\n• pass arguments to the initial user-mode function (ufunc) of a new process context.\n\n• set up an entire new user-mode stack, frame pointer, and program counter for the current process context. This may be useful if a user-mode exception occurs.\n\nThe following two procedures provide access to saved user-mode registers of the current process context 14 :\n\nSIMgetusrctx ( mask, ret_adr ) -returns the values of the (user-mode) registers indicated by bits set in the mask argument (a single longword) to an array oflongwords starting at ret_adr. If the 1st bit is set in mask, the value of rO at the time user-mode code was interrupted is returned; if the 8th bit is set, the value of r7 is returned, etc. The values are returned con::;ecutively in the return array from lowest to highest, according to the bits set in th~ :na.::;k argument.\n\nSIMsetusrctx ( mask, src_adr ) -sets the registers indicated in mask to the values stored in the longword array beginning at src_adr. The mask argument has the same format as in SIMgetusrctx.\n\nThese routines will only modify the user-mode registers of the currently executing process context.\n\nThere is no way to modify registers of a previously stored, inactive context. l1In this discussion, the rightmost bit is called bit 1, not bit O.\n\n..-r-T-_~ --,l;.;;2;.--=,O:bit page table index page offset segment table index 1 =supervisor mode, 0 =user-mode bit 31, must be set to 0 Figure 9: Virtual address format -default pmap B OSF/1 implementation notes B.1 OSF/1 implementation: default memory management architecture The default pmap module developed for the OSF/1-based implementation using the MIPS hardware platform (2] supports a segment-based architecture. Each process context requires a single segment table with one or more page tables. Each segment table entry points to a single page table. Pages are 4096 bytes in length.\n\nThe format of a virtual address is shown in figure 9. Bit 31 must be 0, since all simulator addresses must be user-mode addresses on the host machine. Bit 30 is set to 1 if the address is a simulator supervisor-mode address, 0 if it is a simulator user-mode address. Bits 26 to 29 contain the index within the segment table (0-15), bits 12 to 25 contain the index within the associated page table (0-(2*14)-1), and bits 0-11 contain the offset within the page.\n\nAs shown in figure 10, a segment table entry consists of the address of the associated page table, the size of the segment (in bytes), and the protection associated with the segment (read-only, read-write, or none).\n\nA page table entry contains the page frame number (pfn), the page protection, and a flags field. The pfn field contains the page frame number of a resident page, it may also be used to store the logical block number on disk of a non-resident page. The page protection in the pte allmvs more restrictive access to the page than that defined for the segment.\n\nThe source code for the OSF /1-based version of the simulator is in /pro/ sim. The information in this section is also contained in the README. FIRST file found in /pro/sim.\n\nDue to bugs in OSF/1 and time contraints. approximate 40design presented in the design document\n\nhas not yet been implemented. The source code in this area was used for testing certain key components of the design -page-fault processing and device I/O with interrupts. Most of the code should be re-usable, with some cleaning up. I've tried to comment things as thoroughly as possible.\n\nThe latex source for the design document is contained in the. doc subdirector and is called bse. tex.\n\npal/:e table sIze prot :> segment table pfn prot flal/:s :> page table 'physical page The code should closely reflect the design presented there.\n\nThe following things still need to be done to complete this version of the simulator:\n\n1. Because the aSF /1 loader interface wasn't complete as of 12/90, we couldn't implement dynamic loading of the console monitor routine and the prototype operating system image. Stubs performing the same functions are bound into a single image constructed by the Make file. These need to be split out into seperate images and dynamically loaded during startup.\n\n2. Context switching has not been implemented in any form. However, the design document contains a plan of how to do it. Many of the low-level routines needed to implement context creation and switching should already exist in the current code for other purposes, and could be used.\n\n3. The address space used in the prototype is as follows:\n\nstart_user_va: Ox20000000 start_super_va:OxSOOOOOOO registers_start_va: Ox64000000 this will probably have to change so that user va starts lower (Ox400000 on MIPS) and super _va at Ox40000000. The pas image should be loaded starting at Ox40000000 using the method described in the design doc.\n\nUNIX is a registered trademark of UNIX Software Laboratories in the United States and other countries.\n\n20SF stands for the Open Software Foundation.\n\nrelocation and address fix-up of the code may be required, depending on the POS being developed\n\nthis parameter is not used in the UNIX-based implementation of the simulator.\n\nOSF /1 is a superset of Mach that contains extensions implemented by the Open Software Foundation. The dynamic loading feature was created by OSF and is not part of Mach.aat the present time, prototypes of the first two items listed below have been created\n\nIf the page has just been made valid, the Sim task maps the page to the proper address range in the process context task, and sets the page protection. The Sim task then calls the PMAPreferencedO routine, which will cause the referenced bit in the page table entry to be set, if the memory management architecture supports such a bit.\n\nThe Sim task receives the \"build context\" message, and suspends, then aborts the single thread in the new context task. The state of the new context thread is then modified using the parameters that were supplied to SIMcreatectx O.\n\nSIMgetpsr is only provided in the UNIX-based implementation of the simulator. The OSFII-based simulator allows direct access to the register in the register area\n\nOnly SIMdevctl () is supported in the OSF II-based implementation. The other registers are accessed directly in the privileged register area of supervisor-mode address space."
}