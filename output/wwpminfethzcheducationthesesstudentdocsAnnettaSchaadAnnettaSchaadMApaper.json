{
    "title": "N/A",
    "publication_date": "2001-05",
    "authors": [],
    "abstract": "The Universe type system uses ownership to structure the object store and to control aliasing and modification of objects. In former work ownership transfer -which allows objects to migrate from one owner to another -was integrated in the Universe type system. It is based on the concepts of external uniqueness and alias burying. This report presents different extensions to the Universe type system with ownership transfer. The main extension concerns the inference of the ownership modifier for local variables. Further we apply the concept of subclass separation to the object store. We additionally introduce a solution for array handling that is derived from field access. As a last extension we weaken the external uniqueness invariant to allow passing multiple references on one transferred cluster via method invocation.",
    "full_text": "8.1 Existing Universe Type System with Ownership Transfer . . . . . . . . . . . . . . 8.1.1 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.1.2 Passes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.1.3 Object Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.2 General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3 Local Variable Inference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3.1 Universe Modifier Translation . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3.2 Java Type Checking and Expression Flattening . . . . . . . . . . . . . . . . 8.3.3 Analysis Variables of Interest . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3.4 Translation to analysis AST . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3.5 Analysis Solver and Partition Sets . . . . . . . . . . . . . . . . . . . . . . . 8.3.6 Performing the Type Checks . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3.7 Parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3.8 Multiple Universe Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.3.9 InvTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.4 Subclass Separation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.5 Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.5.1 Array Type Object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.5.2 Array Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.5.3 Array Creation Expression . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.5.4 Array Initializer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.6 Passing Multiple References on a Free Cluster . . . . . . . . . . . . . . . . . . . . . 8.6.1 Type Declaration Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.6.2 Initial Situation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.6.3 Parameter Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8.7 Changes or New Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 Conclusion and Future Work 9.1 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.1.1 Enhanced Linked List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.1.2 Hash Table Merging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.1.3 AVL Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.2 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9.3 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Chapter 1 Introduction 1.1 Background 1.1.1 Ownership Type Systems\n\nOwnership type systems allow the programmer to control aliasing and dependencies by structuring the object store hierarchically into contexts. Each object is owned by at most one other object, called its owner. The ownership relation constitutes a tree order. The set of all objects with the same owner is named context. Objects without an owner are in the root context. The set of objects owned by an object is called its representation.\n\nMost ownership models follow the owner-as-dominator property. This means that all reference chains from an object in the root context to an object x in a different context go through x's owner. Less restrictive is the owner-as-modifier property. An object x can be referenced by any other object, but reference chains that do not pass through x's owner must not be used to modify x. This allows the owner to control modifications of owned objects.\n\nThe Universe type system [4] is a lightweight ownership type system which has been implemented in the JML compiler. It enforces the owner-as-modifier property which means that it differs between read-write and read-only references. Owners can control the modification of owned objects, but not the read access.\n\nOwnership Modifiers. The classification of references is done by using an extended type system. The three keywords peer, rep, and any, called ownership modifiers, can be used in front of the standard Java types. They express the object ownership relative to this.\n\n• peer denotes a reference to an object in the same context.\n\n• rep denotes a reference from an object into its context.\n\n• anyfoot_0 denotes a reference that might point to objects in any context.\n\nA type in the Universe type system consists of both, the ownership modifier and the Java type. The modifier peer is used as default value. rep and peer types are subtypes of any types with the same Java type.\n\nany references are read-only. They can only be used for field read and calls to pure (sideeffect free) methods, not for field update or calls to non-pure methods. Therefore, side-effect free methods are required to be annotated with the keyword pure. peer and rep references are read-write and thus can be used for write access and calls to non-pure methods too.\n\n1 Introduction Type Combinator. The type combinator shown in table 1.1 is used to determine the type of transitive access like field access, method parameters, method results, and array element access. For instance if you want to access the field x. f you have to combine the modifier of x with the modifier of f to yield the modifier of x. f from the caller's point of view. Runtime System. During runtime each object stores a reference to its owner which is determined by the creation expression. This runtime information is needed for downcasts and to evaluate instanceof expressions.\n\nExample. As an example, figure 1.1 and 1.2 illustrate a double-linked list with an iterator. Class Iterator shows the power of the owner-as-modifier property. An iterator can have an any reference to the nodes of the list and iterate the elements over this read-only reference. Otherwise the LinkedList object has full control over the modification on the N ode objects.\n\nUnique variables is a concept for alias management in object-oriented programming. The uniqueness invariant requires that a unique variable, also called unique reference, is either null or else its value is the sole reference to an object.\n\nExternal uniqueness [2] weakens the constraint of unique references. An externally unique reference is the only reference into an aggregate from outside of the aggregate. Internal aliasing to an object from its owner representation is permitted. In combination with ownership types, an externally unique reference is the only reference that passes the context boundary of an object aggregate. If we have a data structure referred by an externally unique reference we can safely transfer it because we can be sure that there is no other external reference into the data structure.\n\nAlias burying [1] is an approach to maintain the uniqueness invariant. The idea is that aliases of a unique variable do no harm if they are not used anymore to access the referenced object at the moment the unique variable is read again. If a unique reference is read all aliases to the object are marked as unusable and cannot be used to access the object anymore.\n\nTo be practical, ownership systems must allow objects to migrate from one owner to another. This ownership transfer is, for instance, desirable in the Abstract Factory pattern or in the case of merging data structures.\n\nUniverse types with transfer or UTT for short [11,12] is an extension of Universe types that supports such ownership transfer. It combines the ideas of external uniqueness and alias burying with the Universe type system. It guarantees statically that a cluster of objects is externally unique when it is transferred and therefore, that ownership transfer is type safe. It provides the same encapsulation as Universe types and requires only negligible annotation overhead.\n\nClusters. To support that only a part of the object's representation is transferred, the ownership context is divided into so-called clusters. These clusters act as the units of an ownership transfer and can therefore only be transferred as a whole. The special this cluster may not be transferred. Clusters correspond to externally unique aggregates. Multiple read-write references into a cluster are allowed, as long as it is guaranteed that at the moment of a transfer there is indeed only a single reference pointing into the transferred cluster. Since any references are not used for modifications, they do not have to be considered to maintain the uniqueness invariant.\n\nAn object is owned by a pair consisting of an owner and a cluster name. Two types rep [f ] and rep [g] are only assignable to each other iff f = g.\n\nCluster Declaration. The ownership modifiers uniq and rep [f ] are used to handle clusters. The definitions of the rep and the peer modifier have to be adapted to the concept of clusters:\n\n• uniq denotes a reference that points into a newly defined transferable cluster. It can only be used for fields.\n\n• rep[f ] denotes a reference that points into the cluster defined by field f. f must be declared uniq in the enclosing class. It may only be used in field declarations and method signatures.\n\n• rep for fields and in method signatures: denotes a reference that points into the this cluster.\n\nfor local variables: reference pointing into a \"wildcard\" cluster. This is explained below.\n\n• peer denotes a reference that points into the same cluster.\n\nLocal variables that point into the representation of this are to be declared solely with a plain rep modifier. That can be seen as pointing into an existing cluster which does not have to be specified further. The actual cluster which the variable may point into is statically inferred.\n\nOwnership Transfer. The ownership transfer of a cluster happens in two steps: First, the cluster is released by the current owner, and then it may be captured into an ownership context to complete the ownership transfer. Both operations will take place implicitly, but the additional ownership modifier free is needed:\n\n• free denotes the only read-write, not unusable reference to a released cluster. It may only be used in method signatures.\n\nThe Universe type combinator for the modifier free is defined as follows:\n\nx U free := free free U x := any, x = free Cluster Alias Controlling. To control external references, analogous to the concept of alias burying, a set of unusable variables that must not be read is used. There are some rules to handle this set:\n\n• Whenever a possible release operation is inferred, all variables that point into the released cluster are marked as unusable.\n\n• Before a non-pure method call on a peer receiver, all local variables pointing into a non-free cluster are marked as unusable.\n\n• Reading a free variable marks it as unusable.\n\n• Assigning to a variable marks it as not unusable anymore.\n\nA static, intra-procedural data flow analysis tracks which variables refer into which cluster and which variables are unusable. This is computed for each program step in the method. Each statement of the language is translated with the so called analysis value transition rules to one or more analysis statements. They represent the modifications this language statement has on the cluster which each variable belongs to.\n\nFlow Graph. The data flow analysis operates on a graph representation of a given analysis statement. This flow graph represents all possible control flow transitions from one elementary analysis statement to another.\n\nTernary Logic. Due to control structures it is not always possible to allocate one variable to one single cluster as you will see in the following example:\n\nAt the end of the method, x can be either of type rep [f ] or rep [g]. Due to these conflict a ternary logic is used for the analysis. This means that the answer to if a variable points into a cluster can be either \"YES\", \"NO\" or \"DONT KNOW\" which means that the variable may point into this cluster or not.\n\nAnalysis Checks. The data flow analysis is employed to check the alias constraints. It performs the following checks:\n\n• No unusable variable must be read.\n\n• No fields must be unusable before a non-pure peer method call and upon method termination.\n\nAs example figure 1.3 shows the implementation of merging two double-linked lists annotated with the Universe type system. The different steps are illustrated in figures 1.4, 1.5, 1.6, and 1.7.\n\nInteresting is the ownership transfer of the list. The first step happens in line 6 in the method getHeader. The cluster of field header (including all nodes) is released as you can see in figure 1.5. This means that header is unusable after this line. Thus, a new N ode is assigned to header in the next line which makes header not unusable anymore (see figure 1.6). The second part of the ownership transfer happens in line 20, where the released cluster is implicitly captured (see 1.7) by assigning the externally unique reference to a local variable.\n\nIn line 6 the special method release is needed to release the header node. Otherwise the header field would be unusable after the return statement, because header and result point into the same cluster [12, p.128].\n\nFor further understanding we list in the code in figure 1.3 additionally the result for the data flow analysis which shows which cluster the rep variables header and otherHeader in the method merge as well as the variables header and result in the method getHeader belong to at different points in the methods. For instance in line 21 it means that header points into the cluster Cl h eader while otherHeader points to a separate cluster.\n\nclass LinkedList { uniq Node header = new rep Node(); free Node getHeader() { // {Cl header header | unusable} rep Node result = release(header); // {Cl header | result | unusable header} header = new rep Node(); // {Cl header header | result | unusable} return result; } pure free Node release(free Node x) { return x; } void merge(peer LinkedList other) { // {Cl header header} rep Node otherHeader = other.getHeader(); // {Cl header header | otherHeader} header.prev.next = otherHeader.next; // {Cl header header otherHeader} otherHeader.prev.next = header; otherHeader.next.prev = header.prev; header.prev = otherHeader.prev; } } class Node { any Object element; peer Node next, prev; Node() { next = this; prev = this; } } Figure 1.4: Ownership structure of list merging, step 1. This is the initial position. In this and the following figures, squares symbolize objects, solid arrows represent read-write references, dashed arrows denote read-only references, dotted arrows represent unusable references, solid rectangles are contexts, and dashed rectangles denote clusters.   At the end the object h 2 will be garbage collected because it is not reachable anymore.\n\nThe Universe type system as well as the extensions for ownership transfer have been integrated into the MultiJava compiler and the JML tools. Beside the static type checking it provides runtime and byte code generation support.\n\nJML [10], which stands for \"Java Modelling Language\", is a behavioral interface specification language designed to specify Java classes and interfaces. It is used to specify the behavior and the syntactic interface of Java code.\n\nJML builds on top of the MultiJava compiler and its utility classes. Thus, most of the uniqueness and ownership transfer extensions are related to the MultiJava code, as JML automatically benefits from them.\n\nMultiJava [3] is a backwards-compatible extension to Java. It retains Java's existing class-based encapsulation properties, type checking, and compilation model. It allows compilation units to be statically type checked modularly and safely, ruling out any link-time or run-time type errors.\n\nThe object of this project is to extend the Universe type system on the presence of ownership transfer. It relies on a recent master's thesis [12] and contains different parts that should be improved.\n\nLocal variables are now annotated with an ownership modifier. In case of a rep variable the cluster should not be declared because it is inferred statically. In this report we will introduce a possibility to omit any ownership modifier for local variables. Instead we will statically infer the ownership type related with a local variable.\n\nThe existing solution uses one cluster (called this cluster) for fields annotated with a plain rep modifier regardless in which class they are declared. For modular verification it would be nicer if the clusters of a subclass are separated from the clusters of its superclass. Our aim is to introduce an own, non-transferable cluster for each class to hold the subclass separation property.\n\nIn [12] the support for arrays is not implemented. Thus, our aim is to find a flexible solution for arrays. Our goal is to handle array element access like field access and thus derive array rules from our field rules. Limitations are given by the restricted information we have about arrays at static time.\n\nIn the existing solution it is not possible to specify two formal parameters pointing into the same free cluster. For more flexible ownership transfer this would be a nice extension. Therefore, our intent is to support passing of multiple references on a cluster via method invocation.\n\nIn the next chapters we will spend time on our extensions. In chapter 2 we first care about the type inference for local variables. Chapter 3 will present our solution to separate the cluster of a subclass from the clusters of its superclass. Our result for array handling is given in chapter 4. In the following chapter 5 we illustrate how to pass multiple references on a cluster via method invocation. In chapter 6 we list the formalization of our new type system including all our extensions. The subsequent chapter 7 handles how the data flow analysis works considering all our modifications. Chapter 8 on the one hand shows how the Universe type system with ownership transfer is implemented and on the other hand it documents our changes on this implementation. The final chapter 9 is about conclusion and future work.\n\nAll class diagrams in the following chapters are published as UML diagrams. For object diagrams we use a graphic rendition presented in [7].\n\nType Inference for Local Variables\n\nIn the old solution [12] local variables have to be annotated with one of the three modifiers peer, rep or any, whereas the plain rep modifier means that the local variable points into an arbitrary cluster of this. The exact cluster is inferred by the analyzer. This solution unburdens the user from declaring cluster details with local variables. Is also gives a higher expressiveness, as demonstrated by this short code fragment:\n\nx is really of type rep[g] } Static Data Flow Analysis. The inference is effectively done during the static data flow analysis. This data flow analysis is intra-procedural and each run of the analysis is handling one fixed method. Since only clusters of this can be transferred, only local variables and fieldsfoot_1 declared as rep can become unusable. Therefore, the analysis needs only to consider rep variables and can leave out the ones declared as peer or any.\n\nIf a cluster is transferred in the existing solution, all variables that point into this clusterexcepting the free reference -become unusable which means that they must not be read anymore. During the analysis these variables are in an additional cluster marked with unusable.\n\nGoal. We will present in this project the solution that all local variables do not need a declared Universe modifier anymore. The Universe type a local variable has will be inferred during the data flow analysis.\n\nIn our solution we omit every ownership modifier with local variables at the declaration time as well as in combination with the new operation. This means that each local variable can have any typefoot_2 except uniq and free and will never become unusable. Further local variables have not only one type, but they can change their type. An example of this type switching is shown in the following code snippedfoot_3 :\n\nhas at this point type rep[ this ]: { Cl this f g x | Cl peer h i } g = x; // is a correct assignment x = h; // x has now type peer: { Cl this f g | Cl peer h i x } i = x; // is a correct assignment }\n\nThe data flow analysis computes for each local variable to which cluster it belongs at each elementary analysis statement. Thus we have to look up the actual type a local variable has at a certain point in the result of the analysis.\n\nMoreover we allow input parameters and fields of type rep to change their type from rep g to rep f . This leads us to a more powerful type system as you can see in the example in section 2.2.11. On the other hand input parameters and fields of type peer and any cannot change their type. Thus, we distinguish between transferable clusters and non-transferable clusters. Transferable clusters are clusters declared by a field like the cluster declared by uniq f. Nontransferable clusters are all other clusters -the this clusters as well as the clusters peer, any and unusable. We allow input parameters and fields to change their type from transferable rep to an arbitrary rep.\n\nTherefore, we know statically which typepeer, rep, or any -a field has, but the current cluster of rep fields and input parameters should be inferred by looking up in the result of the analysis instead of taking the declared cluster. Furthermore before calling a method on a peer receiver or on this we have to restore the object's invariant. This invariant says that fields of different types refer to different clusters and that the type inferred by the data flow analysis is assignable to the declared type.\n\nThis short example shows the type switching of fields from one rep cluster to another rep cluster:\n\nhas at this point type rep[ f ]: { Cl f f x | Cl g g } g = x; // g temporary change the type to rep[ f ]: { Cl f f x g | Cl g } ... // restore object 's invariant : reassign g g = new T(); // { Cl f f x | Cl g | g } this.n(); } Not allowed is the type switching for fields from rep to peer as shown in the following code section: peer T f; uniq T g; void m() { T x; // { Cl peer f | Cl g g | x } x = f; // x has at this point type peer: { Cl peer f x | Cl g g } g = x; // not allowed since fields of type rep cannot change their type to peer }\n\nThe type switching of local variables means that they cannot become unusable. If we now transfer a cluster containing local variables and fields, the local variables change their type while the fields (as long as it is not a transfer from one rep cluster to another rep cluster) become unusable. This is demonstrated in the following example:\n\nof the two clusters of h and x // the two local variables x and y are transferred to peer // while the two fields f and g become unusable // { Cl f | Cl peer h x y | unusable f g} ... }\n\nIf we create a new object with the new operator we put the corresponding variable in a newly created cluster. This means that it has type rep of a transferable cluster (rep Cl tr ). This is problematic if we want to create a peer variable or a variable of a non-transferable rep cluster ((rep Cl nonT r )). The following example illustrates these circumstances (we here use for the first time the modifier notation rep<Cl> instead of rep [Cl]; the difference between the two is explained in section 6.\n\n3): class T { peer T p1, p2; void m() { T x = new T(); // {Cl peer p1 p2 | x} x.p1 = p2; // assignment from peer to rep<Cl tr> } } If we handle x like a peer variable the assignment on the second line would be correct. But since x is in a newly created rep cluster the assignment would mean an assignment from peer to rep Cl tr which is not allowed. The same problem exists with method calls: class T { peer T p; void m() { T x = new T(); // {Cl peer p | x} x.n(p); // expected parameter type is rep<Cl tr> |> peer = rep<Cl tr> // actual parameter has type peer } void n(peer T param) {} } If x would be a peer variable the method call would be correct. But since x is of type rep Cl tr the expected parameter type is rep Cl tr too while the actual parameter type is peer. New non-transferable rep Objects. The same issue occurs if we want to have a new created object of type rep of a non-transferable cluster: class T { rep T r; peer T p; void m() { T x = new T(); // {Cl this r | Cl peer p | x} x.p = r; // assignment from rep<Cl this> to rep<Cl tr> } } and for method invocation: class T { rep T r; void m() { T x = new T(); // {Cl this r | x} x.n(r ); // expected parameter type is rep<Cl tr> |> peer = rep<Cl tr> // actual parameter has type rep<Cl this> } void n(peer T param) {} } Solution. To solve this conflict we have to allow field writing y\n\neven if it is not correct according to the assignable-to relation. This means that we handle y like a variable of type peer or rep Cl nonT r instead of the inferred type rep Cl tr . This is completely correct because the cluster of y can make this ownership transfer since it is a transferable cluster. The transfer is really done in the merge statement of field writing which makes sure that after this point we handle y definitely like a variable of type peer or rep Cl nonT r .\n\nThe same holds for a method invocation y.mt(z) with formal parameter type mt p . The parameter is correct beside the assignable-to relation if\n\nThe correctness is similar to field writing since a method invocation performs a merge between the cluster of the expected parameter and the actual parameter cluster.\n\nThese conditions flow into the type rules presented in section 6.10.\n\nIn contrast to new expression we have to allow and to consider modifiers in connection with a cast between two local variables. For instance a cast between two local variables can be generated during the flattening and is really needed as you can see in the following example\n\n// the following is the flattened code of g = (peer T) f T x,y; y = this.f // y is in the any cluster x = (peer T) y;\n\n// x should be explicitly moved to the cluster of peer this.g = x; } If we do not consider the modifier during the cast expression x would be in the any cluster and the assignment to g in the next line would not be allowed. Since the original code g = (peer T ) f causes no problems we have to consider modifiers in combination with casts. Anyhow this modifier should only be optional.\n\nif a modifier before a cast is missing in the existing Universe type system the ownership modifier of the static type of the right hand side is taken. This is a good solution for local variables in the new version too. But instead of the static type of the right hand side we have to take the current type calculated by the analyzer.\n\nWith the expression x = (rep[z] T ) y it is possible to cast to the cluster the local variable z belongs to at cast time. The precondition is that z is of type rep at this point. Similar is the cast to the cluster a field f belongs to with the expression x = (rep[f ] T ) y. It is important to see that rep[f ] does not mean the cluster declared by uniq f , but the cluster where a field f is at cast time. It is therefore not needed that f is declared uniq. f can be any arbitrary field, but must be declared of type rep. It is explicitly possible that f is not in the same cluster as it was declared. We will illustrate this slightly confusing situation with an example:\n\nThe cast to the cluster of h2 is a cast to the cluster Cl g which h2 temporary belongs to and not to the cluster Cl h like h2 is declared.\n\nInput parameters are treated like fields in case of declaration and type switching as explained in section 2.2.2. The only difference between the handling of fields and input parameters is that in the object invariant only fields have to be checked.\n\nTo treat parameters like fields we have to insert the keyword this before each occurrence of input parameters such that writing and reading from and to input parameters are handled like field reading and writing: void m(peer T p1, rep T p2) { T x, y; ... // before x = p1; x = this.p1; // before p2 = y; this.p2 = y; }\n\nFor declaration we handle return values like fields. In the old version a return statement return x was handled like a method call this.m(x) where the formal parameter of m has the same type as the declared return type. Since the treatment of parameters is similar to the treatment of return values we can handle the return statement like a method call further on.\n\nIn the original Universe type system for static methods no rep types are allowed in the signature as well as for local variables because there is no receiver object [5]. We extend this restriction and allow free parameters (including multiple references to a free cluster as introduced later in chapter 5) and return values. Since local variables have no declared type there are no restrictions for local variables anymore.\n\nWe would also improve purity checking. In the old version in a pure method only assignment to a local variable, field reading and call to pure methods is allowed. We will improve this to allow field writing and call to non-pure methods in some cases.\n\nWe can allow field writing x.f = y and invocation of a non-pure method y = x.mt(z) if no fields of the current object are modified. We prevent this by the precondition that x has to be rep Cl tr . Thus, no call back to the current object and modification of it is possible since the reference to the current object is any. In addition there should be no field in the same cluster as x. This means that x has no read-write reference to a field of this.\n\nIn addition for a method invocation we have to be sure that x is still of type rep Cl tr after call because as mentioned in section 2.2.4 x can change the type to peer or rep Cl nonT r . This can be shown by the condition that z should be assignable to x combined with the formal parameter (for further understanding we refer to section 2.2.4). Furthermore we have to ensure that no field of the current object can be accessed through a read-write reference by the actual parameter z. All these restrictions lead us to the following precondition for field writing x.f = y (L x is the cluster which x belongs to; f means a field of the current object):\n\nand for call of a non-pure method y = x.mt(z):\n\nThus, this and all its fields are only accessible over an any reference from x and cannot be modified. We illustrate it by the following example: The method call in line 14 and the field writing in the subsequent line can be without any problems since they cannot modify the fields of the current object.\n\nIn figure 2.1 you can find another example. Inside of the pure function f ind at line 10 and 16 we call the non-pure method getN ext() on the parameter it. it is of type rep and since there is no field of the current object in the same cluster, we allow this method invocation. The whole code example is listed in A.1.\n\nWe use in our type system a weaken purity. We define purity in that way that no modifications on objects which are not transitively owned by the current object is allowed. Thus, modification of all objects inside the representation context of the current object is allowed.\n\nParameters and return values can be of type free. This needs some special kind of handling. When we have a method call y.m(z) we normally merge the cluster the actual parameter z has with the cluster of the expected type computed by the type combinator between y and mt p , the formal parameter type: merge(z, y £ U mt p ). In other words we merge the cluster where the parameter is now with the cluster where the parameter would be at the beginning of the method call. As long as the formal parameter type is of a type with a defined cluster this merge leads to no problems.\n\nclass LinkedList { uniq Node header; pure free LinkedList findAll(any Element obj){ Iterator it = new Iterator(this); return find(it , obj); } pure free LinkedList find(free Iterator it , any Element obj) { Node curNode = it.getNext(); LinkedList found = new LinkedList(); while (curNode != header) { if (curNode.element.equals(obj)) { found.addLast(curNode.element); } curNode = it.getNext(); } return found; } } class Iterator { peer LinkedList list ; any Node current; any Node getNext() { current = current.next; return current; } pure Iterator(peer LinkedList l) { list = l; current = l.header; } } class Element { int value; pure boolean equals (any Element other) { if (value == other.value) return true; else return false; } } If the formal parameter type is free this means that at the beginning of the method the parameter is in a new cluster, it would then be transferred to an unknown cluster. Thus, since we do not know what kind of transfer is done inside of m we have -by checking the method modularno knowledge about the type of field f and all other variables in the same cluster after the method call. This conflict is illustrated by the following example:\n\npeer at the end of the call ... g.m2(f); // f is rep at the end of the call } void m1(free T p) { g = p; // p becomes peer } void m2(free T p) { f = p; // p becomes rep } }\n\nBoth methods m1 and m2 have the same signature but in m1 parameter p has type peer at the end of the method while in m2 the parameter p has type rep. This shows that if we call a method with a parameter of type free we have no knowledge about the cluster of this parameter at the end of the method call.\n\nSolution. To prevent access to this parameter and all variables in the same cluster, we merge the cluster of f with the any cluster. This means that all fields in the cluster of f become unusable and all local variables in this cluster change their type to any.\n\nThus, in the following example we do not allow the assignment inside of n since f becomes unusable after the method call:\n\nFree Return Values. We have a similar situation if we are inside a method and return a free variable:\n\nWe handle a return statement like a method call. Thus, we have to merge the cluster of x with the cluster of the expected return type. By the same token as for free parameters we do a merge of x with any if the expected return type is free.\n\nIn the old version there exists a problem that sometimes a special release function was needed to release a reference [12, p. 128]. This fact is shown in the following example deduced from the list merging example:\n\nNode header; pure free Node release(free Node x) { return x; } free Node getHeader() { // {Cl header header | unusable} rep Node result = release(header); // {Cl header | result | unusable header} header = new rep Node(null, null, null); // {Cl header header | result | unusable} return result; }\n\nThe reason for the need of the additional method release was that the type system enforced a one-to-one correspondence between static clusters (a set of fields) and dynamic clusters (a set of objects). This means that if we would use a direct assignment statement:\n\nNode header; free Node getHeader() { // {Cl header header | unusable} rep Node result = header; // {Cl header header result | unusable} header = new rep Node(null, null, null); // {Cl header header result | unusable} return result; }\n\nheader would be in the same cluster as result before the return statement and would therefore become unusable since the result type should be free. Thus, we needed the release method mentioned above.\n\nWith our solution and the local variable inference we have solved this minor hitch. Since the newly created header object is in a new cluster instead of the declared cluster, result and header are not in the same cluster at the end of the method:\n\nNode header; free Node getHeader() { // {Cl header header | unusable} Node result = header; // {Cl header header result | unusable} header = new Node(null, null, null); // {Cl header result | header | unusable} return result;\n\nThis example shows that with our solution we have a more flexible handling of clusters which allows easier handling of some examples as shown above. The disadvantage of this flexible handling is, that each newly declared cluster needs at least one field that is declared as pointing into it. This condition is satisfied by our type system since the only way to declare a new cluster by using the keyword uniq.\n\nSubsumed we can say that:\n\n• Local variables have no fixed type and can therefore change their type freely after each statement.\n\n• Local variables can never become unusable.\n\n• Input parameters and fields of type peer and any cannot change their type.\n\n• Input parameters and fields of type rep Cl tr can change the type on rep[ ] or on unusable.\n\n• Before a method call on a peer receiver or on this, fields of different statically types should be in different clusters.\n\n• For all local variables we need to look up the current types in the result of the analysis.\n\n• For peer and any fields and input parameters we can take the statically declared types since they cannot change their type. Thus, we can leave out these fields and input parameters for the data flow analysis since we know which cluster they belong to.\n\n• For fields and input parameters of type rep we need to look up the current cluster in the result of the analysis.\n\n• We can allow field writing and call to non-pure methods inside of pure methods if the receiver object has type rep and there is no field in the same cluster as the receiver object.\n\nChapter 3\n\nIn the old version a class and its subclass share the clusters. In the following code example the fields f and g are both in the same this cluster:\n\nIt is correct to handle the this cluster in such a way, but it would be better if we separated the clusters of a class from the clusters of its subclass. Motivation for this subclass separation is for instance the static verification process in Spec# [9]. Each object in Spec# has to fulfill the invariants of all its superclasses. For example an object x of type B which is a subtype of A should hold both invariants inv A ∧ inv B . During the verification process it is sometimes desirable that we check only the invariant inv B without touching the fields that x inherits from A. Thus, Spec# needs the separation of subclasses.\n\nGoal. In our solution we want to separate the cluster of one class from the clusters of its subclass.\n\nTo allow modular checking a method should be sure that no fields of subclasses can belong to the clusters it analyzes. In other words fields of a subclass may not be declared of clusters used in the analysis of the superclass.\n\nSince we include only rep fields in our analysis, the peer and any cluster can only be used by local variables and thus only by the class where the method is declared. The rep clusters declared by a uniq field can only be accessed by the rep variables of the class where the field -and thus the cluster -is declared. Thus, the only two clusters that are shared by a class and its subclasses are the this cluster and the unusable cluster. If we have subclass separation this means that the fields of a subclass cannot be in the cluster used by the superclass. Therefore no field of the subclass can become unusable. This means that we only need to separate the this cluster.\n\nTo separate the clusters our solution does not work with one this cluster but with one single this cluster per class. All this clusters are marked with a corresponding marker and thus are non-transferable. This avoids the merging of two this clusters.\n\nThe notation will stay as in the old version. For fields, parameters and result types rep means that the variable belongs to the this cluster of the class where the variable is declared. Due to the absence of the possibility to declare explicitly to which this cluster a variable belongs there is no additional check needed to ensure that variables use only the this cluster of the class they were declared in.\n\nIn the analysis we have -beside the peer cluster, the any cluster, the unusable cluster and the clusters declared by fields of the current class and all its superclasses -one this cluster for the current class and one this cluster for each superclass of this class. The this cluster of the superclasses as well as the clusters declared by fields of the superclasses are only needed in the analysis and cannot be used for variable declaration in the current class.\n\nDue to these changes to achieve the subclass separation some examples that work smoothly in the old version are not correct anymore. The following example illustrates this problem:\n\nThe method invocation at line 10 requires the merging of the clusters of the actual parameter f and the formal parameter param. Without subclass separation f and param are in the same this cluster while they are in the presented solution in two different this clusters. Since all this clusters are non-transferable, the method invocation enforces a merging of two non-transferable clusters which is not allowed. In other words according to the new solution this example is not well-typed which it was in the old solution.\n\nAnother example which was correct in the existing system and is not well-type anymore by using subclass separation is the following:\n\nany Object element; peer Node next; } Class A and class B both have a list in their this cluster referred to by the fields head1 and head2. At the last line of the method SubclassSeparationV iolation we try to create a reference from the end of the first list to the end of the second list. This fails since one list is in the cluster Cl A and the other in the cluster Cl B and both clusters are non-transferable Overloading and Overriding. A third example shows the changes in connection with method overriding and overloading:\n\nClass B tries to override a method of class A with a plain rep parameter. Since both methods have semantically not the same signature -in class A the parameter has type rep Cl A and in class B rep Cl B -this is not handled like a case of overriding but like a case of overloading. Due to the Universe type system rules [5] overloading of methods is forbidden if the signatures only differ in their ownership modifier. Thus, our example is not allowed. This means that the rule about overloading prevents us from critical situations in connection with the subclass separation since rep in one class is handled as a different type than rep in another class.\n\nWe can subsume the subclass separation as follows:\n\n• We create one this cluster for each class.\n\n• All this clusters are non-transferable.\n\n• A variable of type rep points always into the this cluster of the class where it was declared. In the existing system there was no solution to handle arrays with ownership transfer. Thus we give here a little introduction to the handling of arrays in the normal universe type system [5]. Arrays of reference types need two ownership modifiers: one for the array object and one for the type of the reference they store. If only one modifier is present it is taken for the element type and the array object type is by default peer. The modifier of the elements has to be peer or any. rep is not allowed. Arrays of primitive types need only the modifier for the array object.\n\nAccess to arrays is basically interpreted like field access, this means that the type combinator is used to determine the type of the access expression. For write access we need runtime check.\n\nWe have covariant array subtyping. The type hierarchy can be seen in figure 4.1. Goal. Our aim is to find a solution which allows a flexible handling of arrays. It is limited by the information we have about arrays at static time.\n\nFor arrays we have to look at the array object as well as the array elements. There is a strong parallelism between field access and array access which we will demonstrate by the following example:\n\n// array object access array = x; // similar to g = x x = array; // similar to x = g // array element access array [0] = x; // similar to g.a0 = x x = array [1]; // similar to x = g.a1 } }\n\nThe variable array can be compared with the field g. Both are of type rep[g] and syntactically there is no difference between array = x and g = x as you can see in line 13 and 14. For array element access in lines 17 and 18 you find a similar situation. The expression array[0] = x is comparable with the expression g.a0 = x. In both expressions we access through a rep object an element that is peer to the prefix. Clearly the syntax is diverse in both cases. Beside the different syntax the only difference between array and field access is that in the case of fields we know the number of \"elements\" at static time while we do not know this about the array. By the same token we know statically always which field we access, but we do not always have the cognition which array element is accessed. Due to the parallelism between fields and arrays we try to derivate the solution for arrays from our handling of fields.\n\nWe will call arrays declared directly in a class \"field arrays\", array declared in a method \"local variable arrays\" and arrays used as parameter \"parameter arrays\".\n\nThe use of the ownership types at declaration is similar to the other variables. A field array and a parameter array can be declared with two types, one for the array object and one for the elements as explained in section 4.1.\n\nOtherwise the type of a local array object is inferred and thus needs no declaration. The modifier for the elements -which can only be peer and any, but never rep -can be declared. If it is not declared, peer is taken as default value. Notice that the modifier for local variable array elements is the only case where it is allowed to declare local variables with an ownership modifier.\n\nThe assignable-to relation for array types is listed in figure 4.2. Since we can transfer the cluster we allow assignment from an array object of type rep Cl tr to an array object of type rep Cl nonT r as long as the elements are assignable too.\n\nAs we have listed above, array objects can be handled like normal fields, parameters or local variables. The only difference is that we have to consider the assignable-to relation for arrays. Analysis Variable. We create for each array object of a local variable array as well as for each field array and parameter array of type rep an analysis variable to observe the cluster the reference belongs to.\n\nStatically we have not always information about the length of the array as well as which array element is accessed. If we want to handle each array element separately, different problems appear as we explain by the example below:\n\nf ar ar[0] ... ar[n] | Cl g g} ar[ i ] = g; // {Cl f f ar ar[0] ... ar[ i ] ar[ i+2] ... ar[n] | Cl g g ar[ i+1]} ... ar[ i ] = f; // {Cl f f ar ar[0] ... ar[ i ] ar[ i+1] ar[i+2] ... ar[n] | Cl g g} }\n\nFirst we do not know the length of the array and thus cannot determine how many array elements should be handled in the analysis. The method m get an integer i as parameter. Since we statically do not know the value of i we cannot decide which array element is moved to cluster Cl g . Thus, when we want to restore the object's invariant we do not really know which array element should be moved from cluster Cl g back to cluster Cl f . All this missing information is marked in the example with the variables i and n. As long as we do not know the values of these two variables it is not possible to handle each element of an array separately in the analysis. This means that we have to handle all elements like one single object. Consequently all elements of an array always have to be in the same cluster.\n\nThis means that we have to care about one element object for each array which we will call below the array element object. Thus, array[0] and array [1] will have the same effect.\n\nTypes. The Java type of the array element object is always the type of the array elements. The ownership type of the array element object is computed by the combination of the array object type and the array element type. This means that an array declared as peer peer has an array element object of type peer and an array declared as rep peer has an array element object of type rep.\n\nAnalysis Variable. In the same way as the fields of a field are not integrated in the analysis it is not needed to observe the type of array elements separately. Because we know statically the type of the elements relative to the array object we can get the cluster which the elements belongs to without problems. If the elements are declared any they are in the cluster any. Otherwise if they are declared as peer they are always in the same cluster as the array object whose cluster we can determine by the corresponding analysis variable. Because elements cannot be declared as rep there are no more cases. This means that we need no analysis variable to observe the cluster the array elements belong to.\n\nThe example introduced above will now look as follows:\n\nAt the assignment array[i] = g we move the array object -and thus all array elements too -to cluster Cl g . To restore the object's invariant we have to move the whole array back e.g. by a new expression.\n\nDuring flattening an expression is split into some basic statements by using temporary variables. The flattening of array element access works like the flattening of field access. In the following example: peer T p1, p2; peer peer T a, b; int i , j ; The first result value of the method f latten means the flattening -the basic statements -and the second result value means the flattened expression. This is the local variable that represents the result after executing the flattening. This means that we only have to look how to handle array reading of the form:\n\nand array writing of the form:\n\nFor each basic language statement we declare so called transition rules. They point the change that happens on the state of the clusters when we execute the corresponding statement while L means the cluster state before and L the cluster state after the execution. The transition rules for all basic statements as well as the used formalization can be found in section 6.9. Array reading of the form x = y[z] can be seen like field reading x = y.f where f has the same type as the array elements. Thus, we move x to the cluster of the array elements. This cluster is either the cluster of y -if the element type is peer -or the any cluster if the elements are declared as any. This leads us to this simple transition rule:\n\nThe so called type rules check whether a language statement is well typed according to our type system or not. Again L represents the cluster state before the execution of the statement. The whole formalization and all type rules are shown in section 6.10. In the type rules there is no check needed. Array reading should always be allowed.\n\nArray writing of the form y[z] = x can be compared with field writing y.f = x where f has the same type as the array elements. If we adapt the field writing transition rule we achieve the following rule for array writing:\n\nWe have to keep the condition that peer elements stay in the same cluster as the array object. Since we never move the array object but only merge it we hold this condition. The array field writing type rule would look as follows:\n\n4.2.9 Unusable Arrays Although we do not observe which cluster the array elements belong to, access to unusable array elements is prevented by the type rules. If the array elements are of type any they can never become unusable. Otherwise if we have peer elements they are in the same cluster as the array object. This means that if the array elements are unusable, the array object is in the case of a field or parameter array unusable too or it is any in the case of a local variable array. If the array object is unusable, the access to its elements is forbidden by the type rules. On the other hand if the local array object is of type any, array element writing is not allowed too. But according to the type rules we allow array reading if the local array object is any and thus the elements could be unusable:\n\nIn line 7 we allow array reading, but if we would have observed a single analysis variable for the array elements this would be unusable.\n\nIt corresponds to the following field reading situation: The field reading in line 89 is allowed although if we had an individual analysis variable for x.p it would have become unusable in line 7. Since in the field reading as well as in the array reading situation the access is only possible through an any reference, only reading is allowed. Reading of an unusable reference should be no problem according to the owner-as-modifier property.\n\nA second critical situation could occur if the array elements become unusable. Since we have no control about which element is accessed we do not have the possibility -expecting with complex methods -to observe whether we assigned a new value to each element of the array. This would be necessary to make the array element object not unusable anymore. Fortunately we do not have to care about this. As mentioned above only peer elements can become unusable and when they are unusable their array object is any or unusable too. If we want to make the array elements not unusable anymore while their array object stays any or unusable we extract no additional functionality since the access to the elements stays restricted by the array object. Therefore, we have no reason to try making array elements not unusable anymore without touching the array object itself.\n\nOtherwise if the array object changes its cluster -because a new value is assigned -the newly assigned array has its own elements which cannot be unusable as long as the array object is neither any nor unusable. This means that we achieve to receive array elements that are not unusable anymore by assigning another array to their array object. We demonstrate this constitution by a little example:\n\nAfter line 6 the array object a and its array elements are unusable. With the new array expression in line 7 a becomes not unusable anymore. Since the new array has new elements the elements are not unusable too.\n\nAn array can be created by an array creation expression like T [] x = new T [i]. Like for new object creation we do not expect modifiers in combination with the new expression. If there are modifiers, they are omitted and a warning is raised.\n\nFlattening. In an array creation expression, first the dimension expressions are evaluated, leftto-right [8, p. 432]. After that, the space for the new array is allocated. This means that for the flattening we first have to handle the dimension expression and then the array creation itself.\n\nThe basic form of an array creation expression is:\n\nTo achieve this form we first have to flatten each dimension expression and create a new array creation expression with the flattened expression: Transition Rules. The transition rule for array creation expression is derived from the new object creation rule:\n\nNotice that we do not have to care about the dimension expression in this basic form because they are handled in their statements of the flattening.\n\nType Rules. The type rule for array creation is simple since we do not have to do any type check:\n\nLike for the transition rules we can ignore the dimension expressions at this point since they are type checked in the statements of the flattening.\n\nThe second possibility to create an array is the array initializer of the form T [] x = {y, z} or for the two dimensional array T [][] u = {{x, y, z}, {a, b, c}}. It is a combination of array creation and array writing. Thus we can handle the following array initializer:\n\nFlattening. The expressions in an array initializer are executed from left to right in the textual order they occur in the source code [8, p.291]. We can thus flatten an array initializer expression into an array creation expression and some array writing expressions: flatten({x 0 , ..., x k }):\n\nThe rule is shown for a one-dimensional array. For multi-dimensional arrays the rule will recursively go on since f latten(x[i]) will flatten the next inner array initializer.\n\nBy splitting one array initializer expression into one array creation expression and some array writing expression we achieve that no array initializer expression occurs in the flattened tree. Thus, no transition rules and type checking rules for array initializers are needed.\n\nSince we handle arrays similar to fields it causes no problems to transfer arrays from one cluster to another. As an example, in figure 4.3 the merging of two hash tables -represented by arraysis shown. In line 12 we release the array table of otherT able by an explicit release function. This released array is passed to method merge which expects a free array as parameter. The whole code of this example is listed in section A.2.\n\nAlthough we do not have all information about an array at static time we reach a good solution for the handling of arrays without radical restrictions. Subsumed we can say that:\n\n• The array object can be handled like a normal variable, only the assignable-to relation is different.\n\n• The modifier of the array elements should always be known at declaration time.\n\n• Array reading and writing are similar to field access.\n\n• All elements of one array must always be in the same cluster.\n\nGoal. Our goal is to allow the passing of multiple references on the same free cluster via method invocation.\n\nfree references can only be used for parameters and return values. Since there is always only one return value the multiple references problem can only occur with parameters. To declare that two parameters point into the same free cluster we use the following syntax:\n\n1. One of the references that point into the same cluster -we call it param -is normally declared as free. We use the same syntax for declaring that a parameter points into a free cluster declared by another parameter as well as that a parameter points into the cluster defined by a field. Thus we use the following order to discover the cluster of a parameter p declared as rep[x]:\n\n• If a parameter in the same method is called x and this parameter is declared as free then p points into the same cluster as x.\n\n• Else (this includes the cases when there exists a parameter x but it is not declared as free) we search for a field x that is declared uniq in the same class as the method is defined. If there exists such a field p points into the cluster defined by this field and thus stays of type rep[x].\n\n• Else we get a type error.\n\nIf we have multiple references to one free cluster the reference declared as free is not really externally unique anymore. We handle all these references that point into the free cluster like free references, but they are coupled together. This means that at the beginning of the method all these references are in one cluster. We illustrate this in the following example:\n\n// {f | Cl peer g | unusable p1 p2} f = p2; // not allowed since p2 is unusable } Both parameters of the method m are of type free and could be handled independently of each other. In the case of n the two parameters are free references too, but they are coupled since they are in the same cluster at the beginning of the method. Thus, reading p1 makes not only p1 unusable but p2 too. Therefore, the second field writing in n is not allowed since p2 is unusable.\n\nIf two formal parameters are declared of the same free cluster it is not needed that the actual parameters are in the same cluster at time of method call too. Since only transferable clusters are assignable to a free reference we could, without problem, merge the clusters of the two parameters.\n\nFor each parameter of a method call we create -if the formal parameter type is not any -one merge operation. In addition we have to check for each parameter whether the actual parameter is assignable to the formal parameter. Since we get no operation for any parameters we first concentrate on all parameters and discuss the different handling of any parameters later.\n\nSince the merge operation of a parameter can change the type of the later actual parameters it is important that the assignable-to check has to be done at the point in the analysis directly before the merge operation of this parameter. Thus, the order will be type checking for the first parameter, then transition rule for the first parameter, then type checking for the second parameter, then transition rule for the second parameter and so on. Therefore, in the following example the method call m(x, y) is not well typed since y becomes any after passing x as first parameter. After passing x we merge the cluster of x with any and thus, y gets any too. But since we want to allow it in this special case we have to do the assignable-to check for y at the same point as for x. On the other hand we should consider that there possibly is a dependency between z and y too. This leads us to the necessity to change the order of the parameters (clearly the formal as well as the actual parameters). If we modify the order to m(x, y, z) and m(free T p1, rep[p1] T p3, peer T p2) we can type check y at the same point as x and the dependency between z and y is considered since when we check the assignability for z we consider the merge operation of y.\n\nThe reordering has to be done that each group of multiple references to the same free cluster should be handled successively and the assignable-to check for all of them has to be done directly before the first merge operation of this group of parameters is executed. In other words we first do all assignable-to checks for a group and then all merge operations of this group before we continue with the next group.\n\nWe do this reordering only for the analysis statements. In the original abstract syntax tree we do not change the order. We will show in a later section why the reordering of the parameters does not change the correctness of a program.\n\nany Parameters. Since no merge operation is created for formal any parameters we only have to look at their assignability check. The closest solution would be to check the assignability for these parameters in the order we get by our reordering like for all other parameters that do not point into a free cluster. Since for any parameters the order of the parameters matters this is not the best solution. We illustrate these circumstances by the following example: The method call f.m1(f, f.p) in class T is well typed while quite the same method call in class Awe only change the order of the parameters -fails. The problem there is that f becomes unusable after passing the first parameter and thus f is not assignable to any anymore. According to the owner-as-modifier property it would not be a problem if we allow passing a read-only reference to an unusable variable. Thus, we want to allow the method call in the second class.\n\nTo be more flexible we check for each any parameter if the actual parameter is assignable to the formal parameter at the beginning of the method call before the first merge operation of the first parameter. In the case of our example above we see that f is before the method call of type rep[f ] and therefore assignable to any.\n\nExample. We use the following method to visualize the reordering:\n\nIn figure 5.1 you see which order the analysis statements of these eight parameters have. Note that we use M erge(f ) as short for the merge statement created in correspondence with the formal parameter f . We first have the analysis statements of the parameters p, r, and a which do not point into a free cluster. After we have the analysis statements for each free cluster for all parameters pointing into it. This means first the analysis statements for f , f 2, and f 3 and after these for g and g2.\n\nIn contrast figure 5.2 shows for each parameter before which analysis statement it should be checked whether the actual parameter is assignable to the formal parameter or not. As mentioned above we do this check for the any parameter a at a dummy skip analysis statement at the beginning. The two parameters p and r are checked before its own merge operation. The multiple references to one free cluster like f , f 2, and f 3 are all checked together before the analysis statement of f . Impact of Reordering of Parameters. To show that the reordering of the parameters has no impact on the semantic of the program we have to prove that:\n\n1. we can omit all formal parameters of type any 2. the reordering of the merge statements does not change the property space at the end of the method call 3. the different order of the assignability checks raises in the same cases an error as if we would check it in the declared order (except for multiple references on a free cluster where the assignability check in the old order would lead to unintentional type errors)\n\nWe can omit all parameters of type any since on the one hand they have no impact on the analysis values because they create no merge operation. On the other hand we check the assignability of these parameters always at the beginning of the method call and thus, the order does not matter.\n\nWe now show that the reordering of the merge statements does not matter for the property space or more formally that in both orders the resulting analysis value L is the same (where M i stands for a merge statement and L is the analysis value):  Or in other words that in the following both cases L is the same (while Cl i represents the cluster the corresponding variable belongs to): . . . ; L L M erge(Cl 1 , Cl 2 ); M erge(Cl 3 , Cl 4 ); L . . . ;\n\n. . . ; L L M erge(Cl 3 , Cl 4 ); M erge(Cl 1 , Cl 2 ); L . . . ;\n\nWe now look at different cases. If Cl 1 = Cl 2 or Cl 3 = Cl 4 the corresponding merge operation has no impact. Else if all four clusters are different, the order of the merge operations does not matter too. The most interesting cases occurs if two clusters in both merge operations are the same like Cl 1 = Cl 3 . Then we get the following situation:\n\nWe divide this once again in different subcases:\n\n• If all clusters Cl i are rep clusters then their merge operations perform only union on sets.\n\nSince the union operation is commutative the order of the merge operations does not matter.\n\n• If Cl 2 is the peer or any cluster we have to consider that beside of the union operation rep fields become unusable. In the first merge operation all fields of cluster Cl 1 become unusable.\n\nIn the second operation all fields of cluster Cl 4 become unusable too. In the reverse order during the first operation no field becomes unusable. When we perform the second merge operation, all fields in cluster Cl 1 -and those in cluster Cl 4 too since Cl 1 = Cl 4 after the first merge operation -becomes unusable. Since in both cases the same fields get unusable we have the same analysis value after the two operations.\n\n• If Cl 1 is the peer or any cluster in the first order, all fields of cluster Cl 2 and Cl 4 become unusable. In the second order all fields of cluster Cl 4 and Cl 2 becomes unusable too, only in reverse order. Once again the order of the merge statements has no effect on final analysis value.\n\nThis semi-formally prove shows that the order of the merge statements has no impact on the property space after the last merge statement.\n\nAs a last point we have to show that the reordering has no impact whether a method call is well typed or not. For easier proving we omit the any parameters since they are always checked at the beginning. In addition we include for each group of references into the same free cluster only the first reference because we have shown above why all other references of the same group have to be checked at the same point. If we look at two different parameters x and y the type check and the merging operations have the following order:\n\nWe now want to prove that this method call m(x, y) will only be accepted iff in the reverse order: check(y) merge(y, Cl 2 ) check(x) merge(x, Cl 1 ) m(y, x) is accepted too. If x and y are not in the same cluster at the beginning, the first merge statement has no impact on the result of the second check. Thus, we have to concentrate on the case where x and y are in the same cluster at the beginning. The only reordering we do is moving the free parameters. If we handle x as free parameter we get the following situation: As mentioned above all parameters with formal parameter any are handled separated. Thus, in the first order check(y) will fail since the actual parameter is any and it would not be assignable to a formal parameter that is not any. The second order is a little bit more complicated. We have to distinguish two different cases:\n\n• If Cl 2 is a transferable cluster or in other words the formal parameter of y is rep Cl tr , both assignable checks will run without problems. But according to our type rules if the formal parameter is rep the receiver of the method call should be this and thus we have to perform InvT est after the method call. Since Cl 2 is defined by a field it contains at beginning of the method call at least this field. With the second merge operation the cluster Cl 2 is merged with the any cluster and thus the defining field becomes unusable. Hence the invariant test will fail.\n\n• If Cl 2 is a non-transferable cluster or in other words the formal parameter of y is rep Cl nonT r or peer, x will be in a non-transferable cluster before its check. Thus, the assignable-to check will fail.\n\nThis means that we accept with reordering the same programs as we would with the original order. Note that the only difference is that the given error message can vary.\n\nWe now have shown that for the change of two subsequent parameters the reordering has no impact on the property space as well as whether the method call is well typed. Since we get each arbitrary permutation by a sequence of such changes between two parameters the same property holds for any order of the parameters.\n\nSummarized passing multiple references to one cluster via method invocation is handled as follows:\n\n• If a parameter p is declared as rep[param] where param is a free parameter in the same method, this means that p points into the same free cluster as param at beginning of the method.\n\n• It is not needed that the corresponding two actual parameters are in the same cluster before the method call, they should only point both into a transferable cluster.\n\n• For checking the type rules the order of the parameters is changed.\n\nChapter 6\n\nThis chapter presents the formalization of the shown type system for a simplistic toy language.\n\nThe static data flow analysis used in this chapter is fully covered in the subsequent chapter. This chapter relies on the corresponding chapter \"Formalization\" in [12]. To make understanding easier we use the same syntax to describe the formalization. The parts of the formalization, which do not have changed in comparison to the old version, are only mentioned shortly. For further reading we refer to [12].\n\nWe use a simply, minimalistic toy language to give the formalization of the type system. We will describe it with the following syntactic categories:\n\nprograms CDecl ∈ TCDecl class declarations M Decl ∈ TMDecl method declarations W ∈ TPure purity modifiers S ∈ TStmt statements T f , T p , T r , T l , T n , T c , T a ∈ TType field types, formal parameter types, return value types, local variable types, object creation types, types in cast statements, and array element types m f , m p , m r , m c , m a ∈ TMod Universe modifiers for field types, formal parameter types, return value types, types in cast statements, and array element types Note that -in contrary to the old version -we do not have modifiers for local variable types and object creation types. Another difference to the old version is that we add types and modifiers for array elements to the language. Further, we make use of the following meta variables and shortcuts as in [12]: C, D ∈ TClass class names (including Object) mt ∈ TMethod method names f ∈ TField field names (including result and formal parameter names) p ∈ TParam ⊆ TField formal parameter names x, y, z ∈ TLoc local variable names (including this)\n\nwhere x ∈ TLoc Note that we handle parameters and result values like fields and not like local variables as it was done in the existing system. The syntax of the toy language is given in table 6.1. Let us comment some aspects that differ from the old solution:\n\n• For local variable declaration and new expression we expect only a class declaration but no ownership modifier.\n\n• For array handling we allow array reading, array writing as well as array creation expression.\n\n• We allow casting to the cluster a local variable belongs to. It should be checked that the variable is of type rep at the point of the casting.\n\nThe allowed usage of Universe modifiers is summarized in the following\n\ntable (where f represents a field declared uniq in the enclosing class, x is a local variable with inferred type rep, and p is a parameter declared uniq in the enclosing method): no modifier any peer rep rep[f] rep[x] rep[p] uniq free Field declaration -yes yes yes yes --yes -Formal parameters -yes yes yes yes -yes -yes Return values -yes yes yes yes ---yes Local variable declarations yes --------New statements yes --------Cast statements -yes yes yes yes yes ---Array element -yes yes ------\n\nThe set TClust represent the domain for possible cluster names to identify clusters. In addition to the clusters declared by the keyword uniq and the this Cluster Cl this -which is now called\n\nCl C for class C -we insert new cluster names for each superclass of the current class. This is a conclusion from the subclass separation. The function transCls: TClass → 2 T Clust yields the transferable clusters defined by the class C (where definedCl: TField → TCluster returns the name of the cluster defined by a given field name and the symbol denotes a \"don't care\" placeholder): Note that we rename the cluster Cl this to Cl C where C is the current class. We assume that TClust is disjoint from each of TClass, TMethod, TField, and TLoc so that globally unique identifiers are guaranteed.\n\nWe distinguish between transferable and non-transferable clusters. All clusters derived from a class -as Cl Object and Cl C -are non-transferable whereas the clusters derived from a field like Cl f are transferable. Subsequently we use Cl tr to denote a transferable cluster and Cl nonT r to mark a non-transferable cluster:\n\nCl tr ∈ transCls(C)\n\nCl nonT r ∈ nonT ransCls(C)\n\nIn the toy language we use the following Universe modifiers:\n\nwith this as Universe modifier for the this reference. Remember that parameters are included in the set TField. These modifiers correspond to the declared types. For further handling we have to use another set of modifiers since for example a rep[param] parameter should be handled like a free reference and a uniq field is treat like rep. Thus, we do a translation for each Universe modifier in TMod to one in the following set: → free p , where p must be declared free in the enclosing method rep [x]\n\n→ rep x , where x must be a declared local variable in the enclosing method\n\nWe call these modifiers the core Universe modifiers. To distinguish these two modifier type we use in combination with rep '[]'-brackets for declaration modifiers and '<>'-brackets for the core modifiers. Subsequently we will always use the core modifiers. In addition we use the following shortcut: rep = rep Cl , f or any arbitrary cluster Cl ∈ TClust Whenever only free is mentioned we include all variables with core modifier free p too. Notice that there are no translations for local variables since they have no declared modifier.\n\nThe lookup functions for static information can be taken from the old version. These are:\n\n• The function f ields : TClass → 2 TField yields the identifiers declared in or inherited by a given class.\n\n• The function f T ype : TClass × TField → TType yields the type of a field as declared in the given class.\n\n• The function mT ype : TClass × TMethod → TPure × TType × TType yields the signature of a given method as declared in the specified class.\n\n• The function mLoc : TClass × TMethod → 2 TLoc yields the names of the local variables of a method.\n\n• The function ∆ : TClass × TMethod → (TLoc → TType) yields the static declaration environment for a given method in the specified class.\n\nWe need one more function for handling arrays: • The function class : TType → CClass yields the class name of a given type.\n\nWe define the type combinator which is used to determine the type of transitive access for the core modifiers as follows: Inside of a method we handle the parameters declared as free like rep Cl tr . Thus, we never have free on the left hand side of an transitive access and can therefore omit the corresponding line in the table.\n\nIn our type system the subtype relation and the assignable-to relation differs. Because of ownership transfer we can assign more than only subtypes. The subtype relation outlined in figure 6.1 follows by a being-less-specific-than point.\n\nOne type m 1 C 1 is assignable to another type m 2 C 2 iff C 1 is the same class as C 2 or is a subclass of C 2 (like in Java) and if modifier m 1 is assignable to modifier m 2 according to the assignable-to-relation shown in figure 6.2.\n\nWe should additionally mention that two non-transferable rep clusters are not assignable to each other if they are not the same. In other words the following condition holds:\n\nAll other types are always assignable to the same type:  The assignable-to relation for arrays is illustrated in figure 4.2. In general the assignable-to relation should only be used if there is a field or a parameter on the left hand side of the assignment since an assignment to a local variable is always correct regardless of which type is on the right hand side.\n\nFor the static data flow analysis we use a ternary logic with the value set\n\n, 1}\n\n.\n\nWhen we query the data flow analysis it deliver an answer a ∈ T with the following interpretation:\n\n⇒ The property definitely does not hold in all possible executions of the program. a = 1 ⇒ The property definitely holds in all possible executions of the program. a = 1 2 ⇒ The property can hold in some executions, but it also cannot hold in other executions of the program. We do not know it.\n\nAn analysis value represents which variable points into in which cluster at a specific program point. L means the property space or the analysis universe which is formed by all analysis values. The special analysis value ı ∈ L symbolizes the initial value that stands at the beginning of the program. Informally it can be described as follows:\n\n• Each field points into its declared cluster.\n\n• Each local variable points into a new own cluster.\n\n• The parameters of type free p as well as the parameter p itself point into the same cluster.\n\nAll other parameters point to their declared cluster.\n\nLike in the old version we offer the following two query functions to the analysis values:\n\nreturns whether a analysis variable is unusable. Consider that local variables cannot become unusable hence the function is not used for local variables.\n\nThe second function is:\n\nchecks whether an analysis variable points into a given cluster. We introduce some more queries to receive type information about local variables and fields from analysis values. Since we work with ternary logic a simple type modifier query is not possible because the answer can be \"possibly peer\" and \"possibly any\". Thus we have to implement queries for the three types peer, rep, and any.\n\nThe function isP eer : L × mLoc(C, mt) ∪ f ields(C) → T checks whether a given field, parameter value or a local variable is of type peer at this program point. In case of fields and parameter values this query takes the information from the static declared types. For local variables the answer is taken from the analysis values.\n\nAnalogously, the function\n\nreturns whether a given field, parameter value or a local variable is of type any at this program point. For fields and parameter values the static declared type is taken while for local variable we use the current type in the analysis value.\n\nFurthermore, the function\n\ntests whether a given field, parameter value or a local variable is of type rep at this program point. We check this with a pointsInto-query for local variables as well as for fields and parameter variables.\n\nThe analysis transition operates on the property space L and represents the effect a certain entity has on an analysis value L ∈ L. We use the following transition functions:\n\n• M erge(L, x, y): x and all variables in the same cluster as x are marked as pointing in the same cluster as y.\n\n• M erge(L, x, Cl): x and all variables in the same cluster as x are marked as pointing in the cluster Cl.\n\n• M ove(L, x, y): x is marked as pointing into the same cluster as y.\n\n• M ove(L, x, Cl): x is marked as pointing into the cluster Cl.\n\n• N ew(L, x): x is marked as pointing into a new cluster. x is the sole variable that points into this new cluster.\n\n• InvRestore(L, x): if x is of type peer, all local variables pointing into the same transferable cluster as a fields are marked as pointing into the cluster Cl any and the function RestoreF ields(L) is executed.\n\n• RestoreF ields(L): if two fields of same declared type are in different clusters they are marked as pointing into the same cluster.\n\nThese transition function will be defined formally in chapter 7. Note that we do not need the functions Consume and ConsumeLocals introduced in the old version anymore.\n\nThe analysis value transition rules describe the effect that each statement of the toy language has in terms of the analysis values. The rules have the following structure: Γ; L e; L which means that in a declaration environment Γ partition change from L to L after evaluation expression e. The analysis value transition rules are listed in figure 6.3 and 6.4.\n\nWe use some shortcuts for easier understandability:\n\n• m f -declared type modifier of field f :\n\nwhere C is the class where f is declared\n\n• m yElem -declared type modifier of the elements of array y:\n\nwhere y is declared in the method mt of class C\n\n• mt p -type modifier of method's mt input parameter:\n\nwhere C is the class where mt is declared\n\n• mt res -type modifier of method's mt result:\n\nwhere C is the class where mt is declared\n\n• mi x -the inferred type modifier of x Further we use sometimes a modifier m instead of an analysis variable as argument of the move or merge operations like merge(L, x, m). To get the corresponding analysis variable we replace m by the cluster marker if it specifies a non-transferable cluster. Otherwise if m specifies a transferable cluster, we replace m with the defining field of this cluster.\n\nMoreover sometimes the type combinator is used inside a move or merge operation like merge(L, x, y £ U m f ). How the combinator and its result is mapped to an analysis variable is shown in section 8.3.4.\n\nnew Expression. Parameters of a new expression x = new T (p1, p2) are handled like parameters of a method call x.T (p1, p2).\n\nreturn Statement. The return statement return x is handled like a method call this.m(x) where the formal parameter of the imaginary method m has the same type as the return type of the current method. Additionally we have to add an exit statement at the end considering that we exit the method.\n\nMethod Invocation with many Parameters. If we have a method call with more than one parameter in the rule [L-PRE-INVK] we first have one RestoreF ields operation and after we create for each parameter -if the formal parameter is not any -its merge operation. These operations should be in such an order that the operations of the formal parameters which point into the same free cluster are one after the other.\n\nType rules has the next structure: Γ; L e It means that in a declaration environment Γ and partition L expression e is well-typed. We assume that the Java types are correct and expression is well-typed according to the standard Java type rules. In addition we do not allow assignment to this.\n\nThe type rules for the different statements are given in figure 6.5 and 6.6, while the type rules for method and class declaration as well as for programs are presented in figure 6.7. ı means the initial analysis value.\n\nMethod Invocation with many Parameters. If we have a method call with more than one parameter the assignability check in the rule [T-INVK] has for the free and free p parameters to be done before the first merge operation of all parameters pointing into the same free cluster. All other parameters have to be checked before its own merge operation.\n\n[T-NEW-ARR] Figure 6.5: Type Rules for statements, part 1. if (W = pure) then T r and T p ∈ {any, free}\n\nFigure 6.7: Type Rules for method declaration, class declaration and programs.\n\nChapter 7\n\nThis chapter describes the techniques used for the static data flow analysis. It relies on the corresponding chapter \"Data Flow Analysis\"' in [12]. In this chapter we will only list some few points that change in comparison with the old solution. For further understanding we refer to [12].\n\nThe static data flow analysis does neither operate directly on the Java source, nor on the presented toy language. Its target language is an additional abstract language called the \"analysis language\". All operations which are not relevant for the analysis are removed from the analysis language. Thus we get a reduced amount of code.\n\nThere is only one syntactic category describing the analysis statements:\n\nS ∈ AStmt : analysis statements\n\nWe use in addition a set of variables AVar and a set of label ALab for labeled statements:\n\nx, y ∈ AVar : analysis variable names l ∈ ALab : analysis statement labels\n\nThe syntax of the analysis language stays almost like presented in the corresponding section in [12]. First, there are elementary statements which perform a certain operation on the analysis values. They correspond to the operations used in the transition function.\n\nNote that the two statements consume(x) and consumeLocals of the existing type system are not needed anymore. Instead we use the two new analysis statements restoreF ields and invRestore(x).\n\nAll following statements are taken from the existing system. Thus, we only present them shortly. For deeper understanding we refer to [12]. There exist some elementary statements which represent a change in the control flow:\n\nFinally we have some composite statements which have other statements as children:\n\nThere is no notation of an expression in the analysis language. Thus, in the condition for an if statement stands the analysis statement generated by the condition expression.\n\nThe flow graph is a graphical representation of a given analysis statement on which the data flow analysis operates. The nodes of the graph are the elementary analysis statement. The edges represent possible control flow transitions from one node to another. Since in comparison to the existing system we only have introduced two new analysis statements restoreF ields and invRestore(x) the creation of the flow graph stays like mentioned in the corresponding section in [12]. Thus, we only note here how to handle the two analysis statements restoreF ields and invRestore(x).\n\nEach elementary statement is labeled by an index i. We use the notation [S] i to denote an elementary statement S with index i. The function nodes yields the indexes of the set of nodes of an analysis statement. Additionally init returns the index of the first node and f inal the index of the last node. For restoreF ields and invRestore(x) these three functions are defined as follows:\n\nThe function edges defines the directed edges between node indexes in the flow graph corresponding to an analysis statement. Since restoreF ields and invRestore(x) consists only of one node there are no additional edges between the nodes of these statements. Thus, edges is defined as follows:\n\nedges([restoreF ields] i ) := ∅ edges([invRestore(x)] i ) := ∅\n\nFor each method we define a set of variables which we are interested in during the data flow analysis. These so called variables of interest are the following:\n\nwhere:\n\n• ALoc -is the set of local variables\n\n• AFd -is the set of visible fields, parameters and result of type rep\n\n• AFd 0 -is the set of fields of type rep\n\n• AMark = {Cl any , Cl peer , unusable, nonT ransCls(C)} -set of markers\n\nIn contrary to the old solution we only have markers for all non-transferable clusters. For all transferable clusters, this means all clusters defined by a uniq field, we omit the markers. This allows us to easily distinguish between transferable and non-transferable clusters as only the latter have a marker.\n\nOne of the possibilities to denote analysis values are partition sets. You will find a deeper introduction to partition sets in the corresponding section in [12]. Each analysis value is represented by a set of partitions. Each partition stays for one possible constellation. The different sets inside a partition are called blocks. If two analysis variables are in one block this means that they point into the same cluster at this program point. We denote L x the block of the partition L that contains x. It follows from the partition definition that there is always exactly one such block. With the blocks we can determine the actual type of a variable. This means that if a variable is in the same block as the marker Cl peer it is of type peer. If a variable x has no marker in the same block AMark ∩L x = ∅ this means that the variable is of type rep Cl tr for a transferable cluster Cl tr .\n\nSince only non-transferable clusters have a marker, we can never have two markers in the same block:\n\nWe check this property explicitly as a postcondition of the merge operation. There are three operations on partitions: new, merge and move.\n\nMove. The move operation removes a variable x from its block and adds it to the block of y (where A is a set, L ∈ P artition(A) is a partition and x, y ∈ A are elements):\n\nAfter the move operation x has the same type as y.\n\nNew. The new operation removes a variable x from its block and moves it to a new singleton block:\n\nAfter the new operation the type of x changes on rep Cl tr .\n\nMerge. The merge operation unifies two blocks x and y: merge(L, x, y) := L -L x -L y + L x ∪ L y .\n\nAfter the merge operation all variables from L x change to the type of y. We have to ensure that we do not merge two non-transferable clusters. Thus, we have to check the precondition that the two blocks contain no more than one marker:\n\nIf the precondition is violated we treat it as a type error. Additionally we have to guarantee that no rep field or parameter changes the type to peer or any. Thus, if we have a merge where x or y is of type peer or any all fields of type rep in L x or L y become unusable:\n\nIn addition we have three functions for maintaining the object invariant:\n\nInvTest. With the predicate InvT est we test an object's invariant. This means that two fields in the same block have to be declared of the same type and for each field the type inferred by the analysis should be assignable to the declared type:\n\nWe check explicitly that this predicate is true before method invocation on a receiver of type peer or this as well as before return from a method.\n\nInvRestore(x). The operation InvRestore(x) calls InvRestore if x is peer:\n\n1. isP eer(x) ! = 0 ⇒ InvRestore InvRestore. With the operation InvRestore we can restore the object's invariant:\n\nFirst we change type of a variable to any if it belongs to a block which contain a field that refer on a transferable cluster. This avoids having a writable reference into a transferable cluster from the middle of a program stack. Second the operation RestoreF ields restores the clusters of the fields.\n\nRestoreFields. With the operation RestoreF ields we can restore the clusters of the fields:\n\nIf two fields of same declared type are in different blocks we merge these two blocks. We restore the object's invariant before each method invocation.\n\nThe analysis computes for each node in the flow graph the analysis value that holds at the entry to the node and one that holds at the exit of the node. The analysis value at the exit of a node can be computed by applying the transition function of this node to its analysis value at the entry. The entry analysis value of a node is worked out by joining the exit values of its predecessor nodes.\n\nTo distinguish the transferable clusters from the non-transferable clusters all non-transferable clusters contain a marker analysis variable m ∈ AMark.\n\nAs in the existing system we use the basic predicate areInSameBlock : 2 P art(A) × A × A → T to check whether two variables x, y ∈ PVar are in the same block of partitions contained in a given partition set Φ. The query functions isU nusable -which yields whether a variable is unusableand pointsInto -which returns whether a variable point into a given cluster -are used in the same way as in the existing system. We additionally make use of the three functions isP eer, isAny, and isRep to determine the inferred type of a local variable. These functions are defined as follows:\n\nisP eer(Φ, x) := areInSameBlock(Φ, x, Cl peer ) isAny(Φ, x) := areInSameBlock(Φ, x, Cl any )\n\nWe have the partition invariant that a block can never contain more than one marker. For a partition set Φ this means:\n\nWe check the maintaining of this invariant explicitly at the end of the merge operation.\n\nAs described in [12] all transition functions can be expressed using M erge and N ew as building blocks. This holds for the newly introduced functions InvRestore, InvRestore(x), and RestoreF ields too (where cluster(f ) yields the declared cluster of f ):\n\nby remembering that M ove can be expressed using M erge and N ew.\n\nTo maintain the partition invariants we have to check the following preconditions before using the transition function M erge(x, y):\n\nIn the existing type system there are different possibilities to represent the analysis values: partition sets, alias matrices and minimized partition sets. Since we change nothing about them, we refer for further reading to the corresponding chapter in [12]. In this section we give an introduction how MultiJava and the Universe uniqueness extensions are implemented. Beginning with section 8.2 we show some implementation details about the extension presented in this report.\n\nThe most important package of the MultiJava is the package 'org.multijava.mjc' which contains the files for the MultiJava compiler. The files of this package can be basically divided into four groups [6]:\n\n• The JP hylum hierarchy contains all classes representing abstract syntax tree (AST) nodes.\n\nInstances of these classes are the output of the parser. All these classes are marked with a 'J' as first letter of the class name. Examples are JF ieldDeclaration, JIf Statement or JLocalV ariable.\n\n• The CT ype hierarchy contains classes that represent types. For instance is CArrayT ype used for the type of an array or CClassT ype represents a class type.\n\n• The CContext hierarchy is used for control flow analysis and variable scoping during type checking.\n\n• The classes of the CM ember hierarchy represent the signatures of classes, interfaces, fields, and methods. CF ield, CM ethod, and CClass belong to this group of files.\n\nFurther we need the classes related to the universe type system with ownership transfer like for the data flow analysis. They can be found in packages beginning with \"org.multijava.universes.uniqueness'.\n\nThe MultiJava compiler uses different separate passes to process the AST. The relevant passes for uniqueness type checking are illustrated in figure 8.1. For further reading we refer to [12].\n\nUniverse Modifier Translation. During this process -called InitU niverseU niquenessT ask -the translation from surface Universe modifiers to core modifiers as explained in section 6.3 is done. This task is implemented in the initU niverseU niqueness methods of the relevant Java AST classes.  Java Type Checking and Expression Flattening. First of all the basic Java type checking is performed. At the same time some type checks for the Universe type system -the basic system without ownership transfer -is done. Both is related to the method typecheck of the relevant AST classes.\n\nAdditionally the expression flattening is performed. This means that the Java expressions are transformed into statements of toy language by using new temporary variables. The original Java expressions are not modified since the flattening is stored in association with the original expression. This step happens in the method f latten of the relevant subclasses of JExpression.\n\nChecking Uniqueness The data flow analysis and the remaining uniqueness type checks are performed in a new compiler pass called CheckU niverseU niquenessT ask. The corresponding functionality is implemented in the method checkU niverseU niqueness of the class JM ethod-Declaration. This pass is divided into three operations. At first the flow graph is created. Then we run the analysis and compute the solution of the data flow analysis. At the end the uniqueness type checking is performed using the computed analysis values. It is performed on the flattened AST, not on the original Java AST.\n\nTranslation to Analysis AST and to Flow Graph. For each method declaration, its body is translated into corresponding statements of the analysis language according to the transition rules. This happens in the methods getAnalysisStmt and createAnalysisStmtN oF lattening of the corresponding AST classes.\n\nUniqueness Type Checking. If the analysis could successfully be solved, the uniqueness type checking according to the type checking rules is performed using the analysis values computed by the solver. This type checking is implemented in the method checkU niverseU niquenessN o-F lattening of the corresponding AST classes.\n\nIn this section we want to show how the data between the different operations shown in figure 8.1 are represented. We clearly include only the most important objects and references.\n\nSurface and Core AST The surface AST is the output of the parser. The difference of surface and core AST are only little changes according to the universe modifiers. Thus, the whole object structure stays quite the same. In figure 8.2 you find the object structure of an if statement. In figure 8.3 the object structure of a field declaration is illustrated. On the one hand you see that the universe types are linked by the field universe of the class CClassT ype which represents a Java class type. On the other hand each local variable has a reference to an object of type LocalAnanlysisV ar which is used in the data flow analysis to represent this variable. Analysis AST The analysis AST is the representation of the program in terms of analysis statements which is used to create the flow graph. Each statement and expression of the core AST holds a reference to its analysis statement. The analysis language consists of the analysis statements introduced in section 7.1 and the analysis variables explained in section 7.3. A possible object structure of the analysis AST is presented in figure 8.4. We differ between the analysis statement which are marked yellow and green (yellow are the elementary analysis statements and green the composite analysis statements) and the blue analysis variables. You can see that the objects of type M ergeStmt and M oveStmt have references to their analysis variables. These analysis variable objects are the same as the LocalAnalysisV ar object shown in figure 8.3. Each analysis node has three references initN ode, innerN ode, and f inalN ode as mentioned in section 7.1. Notice that these references point only to elementary analysis statements which can be seen like the leafs of the analysis statement tree and are marked yellow in our example. In figure 8.3 we show only these three references for the top sequence statement to not worsen the understandability.\n\nFlowGraph The flow graph connects the elementary analysis statements from the analysis AST according to the program control flow. Since the elementary statements implement the interface F lowGraphN ode all elementary statement objects are of type F lowGraphN ode too. Thus, the terms flow graph node and elementary analysis statement can be used as synonyms.\n\nAn example for a flow graph is shown in figure 8.5. Each flow graph node has a reference to all its outgoing edged. Objects of type F lowGraphEdge represent an directed connection between two flow graph nodes.\n\nIf you compare the figures 8.5 and 8.4 you remark that for creating the flow graph all elementary analysis statement objects -marked as yellow -are taken and connected with each other through flow graph edges. Thus, we have not one analysis AST and one flow graph for each method, but both are strongly overlapped.\n\nHow the object of type F lowGraph which represents the flow graph of one method is represented is illustrated in figure 8.6. We leave away the connection between the objects referred by the flow graph object since we have shown them already in the last figures. For instance the flow graph edges and the flow graph nodes are connected. As mentioned above the object of type AnalysisStmt has references to the elementary analysis statements represented by F lowGraphN ode objects. These nodes have additional links to the different analysis variables of type AnalysisV ar.\n\nSolver After the creation of the flow graph we can run the analysis. The result of the analysis is the analysis values. Each analysis value represents the state of the clusters and analysis variables at one point of the program. The existing system can use three different solvers. In the figure 8.7 the object structure of the alias matrix solver is shown. You see in the middle of the figure the array of AliasM atrix objects. These are the analysis values that hold which variables point into which cluster. Due to conditional constructs more than one cluster state is possible at one program point. These different possible states are stored in the array referred by the field\n\nOur implementation extensions affect only the MultiJava code since JML automatically benefits from them. We used Java version 5 (generics and autoboxing) while the existing files were written for Java 1.4.\n\nModifiers before a local variable during the declaration or in combination with the new operator are not needed anymore. For backward compatibility they should be accepted, but ignored. The user will be warned that the modifier is omitted. We implement this in the method typecheck of the class JVariableDeclarationStatement corresponding to the way the correct use of modifiers before local variables is checked in the old version. In the same way we can check for new operation in the method typecheck in JNewObjectExpression if there is a modifier for local variable object creation.\n\nAll variables are linked with a modifier object at time of the surface AST creation, either with an explicit (and now ignored) modifier or with the implicit default modifier. We do not delete this modifier since for future work it can probably be used as a type hint, but we will now ignore it.\n\nSince during the task of the Java type checking and the expression flattening the Universe modifiers of the local variables are not inferred yet, it is important that all Universe type checking stuff is moved to the Uniqueness type checking pass (this means a move from typecheck() to checkU-niverseUniqueness()). While typecheck runs on the original tree, checkU niverseU niqueness uses the flattened version. But is works fine too. The movement of the code has the consequence that the type checking is done after the analysis and thus the errors and warnings have another order that before. Additionally we have to change the type queries for local variables as well as rep fields and input parameters to queries to the analysis data flow.\n\nisLValue. In the method typecheck(CExpressionContextT ype context) there is a call to the method isLV alue(CExpressionContextT ype context):\n\npublic JExpression typecheck(CExpressionContextType context) { ... boolean isLValue = isLValue(context); ... } public boolean isLValue(CExpressionContextType context) { ... if (context.isPure()) { ... } ... }\n\nSince isLV alue needs type information we have to move this method call too. The isLV alue method needs as argument an object of type CExpressionContextT ype for example to check whether we are in a pure context as you can see in line 9. In the method checkU niverseU niqueness we miss the context object. Thus, we cannot call directly the isLV alue method. We implemented it in that way that in the method typecheck we call a new method setLV alueF lags which stores in private boolean flags the information needed from the CExpressionContextT ype object in the method isLV alue as for instance isP ure. We now call from checkU niverseU niqueness a new method isLV alue which has no argument and takes the information required from the CExpressionContextT ype object by reading out the flags. After these changes the example would look like this:\n\npublic JExpression typecheck(CExpressionContextType context) { ... setLValueFlags(context); ... } public boolean isLValue() { ... if (isPure) { ... } ... } public void setLValueFlags(CExpressionContextType context) { ... isPure = context.isPure(); ... } protected void checkUniverseUniquenessNoFlattening( CUniverseUniqContextType context) { ... boolean isLValue = isLValue(); ... } private boolean isPure;\n\nIn the old system only rep local variables and rep fields are used as analysis variables of interest. We expand this now to all local variables and parameters of type rep. Thus we have to register all local variables as well as fields and parameters of type rep. In the flow graph we handle parameters like fields. The initial value of the partitions is that each field and parameter is in its cluster set and each local variable is in an own set. The only exception occurs with multiple references on one free cluster. All these references point into the same cluster at the beginning.\n\nThe analysis transition functions used to translate the core AST to the analysis AST has to be modified since we have now no knowledge about the modifiers of the local variables (-> create-AnalysisStatement() of subclasses of JStatement). The modified rules are listed in section 6.9. The different type rules are implemented in the method createAnalysisStmtN oF lattening of the classes mentioned in figure 8.1.\n\nIn the analysis transition rules (see section 6.9) we use the type combinator in a parameter for the move and merge operations several times which looks as follows: merge(P t, x, y U m f ). In every case the left hand side argument of the type combinator is a local variable and the right hand side is a field, a method parameter or the result variable. Thus, we know the type of the right hand side argument except in which cluster a rep variable points. Otherwise we do not know anything about the type of the local variable. We can only check if the local variable is this or not. Although we can determine which type the combination of the two variables should have in terms of real type or in term of the type that one of the two involved variables will have at analysis time. This is shown in the following table (the evaluation order must be from top to bottom):\n\nods of CU niverse it can be handled like a normal Universe type. The only difference is that CU niverseM ultipleT ypes has additional methods like isDef initelyRep. The difference between isDef initelyRep and isRep is that isRep return true if the variable may be rep regardless whether it is probably of another type too while isDef initelyRep returns true iff the variable is only of the type rep. The class structure is shown in figure 8.9.\n\nThe invariant test InvT est includes the following two rules:\n\nWe implement this test in the class AbstractAnalysisV alue. The straightforward solution would be to do both checks using the CU niverse object the field was declared with. But in the class AbstractAnalysisV alue we have only access to the analysis variables. Thus, we have only field 8.5 Arrays\n\nEach array variable is linked with an object of type CArrayT ype which represent its type. As shown in figure 8.11 an array type object has three important fields baseT ype, result type, and universe. baseT ype represents the declared type of the elements, while universe is the ownership type of the array object. result type is the type needed to access the elements. This means it is the combined type of the array object type and the element type. In the class CArrayT ype we had to change the assignability relation according to figure 4.2.\n\nThe two transition rules for array writing and array reading are implemented in the method createAnalysisStmtN oF lattening of the of the class JArrayAccessExpression. Analogously the type rules are added to the method checkU niverseU niquenessN oF lattening of the same class.\n\nIn the class JN ewArrayExpression on the one hand we have to implement the flattening process in the method f latten. On the other hand we have to implement the transition rule in the method createAnalysisStmtN oF lattening and the type rule in the method checkU niverseU niqueness-N oF lattening.\n\nFor array initialization it is only needed to implement the method f latten in the class JArrayInitializer. Since in the flattened tree there are no nodes of type JArrayInitializer no type rules or transition rules are needed to be implemented in this class.\n\nDuring parsing there is no difference whether a parameter p declared as rep[x] means that it points into the same cluster as a free parameter x or as a uniq field x. During the Universe uniqueness initialization pass in the method initU niverseU niqueness of the class JF ormalP arameter we check whether there is a parameter called x in the same method declared as free. If there is no such parameter we continue like in the old version by searching for a field x declared as uniq in the same class. But if we find such a parameter x we first change the type of p to free x . Then we store a reference to parameter p in the object x. This link is later needed for efficiently finding all parameters that point into the same free cluster.\n\nWe have to ensure that at the beginning of a method all parameters that point into the same cluster are in one block. Thus in the method checkU niverseU niqueness of class JM ethodDeclaration we create the analysis statements to merge all parameters that point into the same free cluster. These analysis statements are added at the beginning of the statement sequence that is created by the body of the method.\n\nAs mentioned in section 5.2.3 we have to change the order of the analysis statements created by each parameter passing in such a way that all formal parameters pointing into the same free cluster are handled successively. In addition the analysis statement before which the assignability check has to be done should be for each parameter of such a group the first analysis statement of the group.\n\nOrder of Analysis Statements. The ordering of the analysis statements is done in the method createAnalysisStmtN oF lattening of the class JM ethodCallExpression. During the creation of the merge statements for each parameter we arrange them into three different lists. In one list we hold all analysis statements of parameters declared plain free, in another one all statements of parameters of type free p . In the main list we put the statements of all other parameters. Then the analysis statement of each free parameter is added to the main list followed by all parameters pointing into the same cluster. To efficiently finding the parameters pointing into the same free cluster we use the method getM ultipleF reeP arameters in JF ormalP arameter which gives back all these formal parameters. To find the analysis statements connected with each of these parameters we use an array stmtF orP arameters that maps the original parameter indexes to the previously created statements. This means that for a method call: In the array checkArgsN odes we store for each parameter before which analysis statement its type check should happens. For indexing the original parameter order is used. For each parameter which is not of type free p the item in checkArgsN odes points to its own analysis statement. The checkArgsN odes item for all parameters declared as pointing into the same cluster as another free parameter p are set to the analysis statement of p.\n\nChecking Assignability. When we now want to check the assignability in the method check-U niverseU niquenessN oF lattening of JM ethodCallExpression we do this for each parameter before the analysis statement stored in checkArgsN odes.\n\nThe following files have been changed or added:\n\n• Package org.multijava.universes.uniqueness.analysis (classes for analysis variables and analysis values): AbstractAnalysisValue, AnalysisValue, AnalysisVar, AnalysisVarAny, Analy-sisVarPeer, ClusterAnalysisVar, FieldAnalysisVar\n\n• Package org.multijava.universes.uniqueness.analysis.statements (classes for analysis statements): AbstractAnalysisStmtVisitor, AnalysisStmtVisitor, InvRestoreStmt, RestoreField-sStmt • Package org.multijava.universes.uniqueness.analysis.solvers.singlepartition (class for the solver): SinglePartitionAnalysisValue • Package org.multijava.universes.uniqueness.analysis.solvers.partitionset (class for the solver): AbstractPartitionSet • Package org.multijava.universes.uniqueness.analysis.solvers.aliasmatrix (class for the solver): AliasMatrix • Package org.multijava.universes.uniqueness.analysis.graph (class for the flow graph): Flow-Graph • Package org.multijava.universes.uniqueness.testing.analysis.solvers (class for testing): Test-WorklistSolver • Package org.multijava.mjc: -Classes for Universe types: CUniverse, CUniverseImplicitPeer, CUniverseImplicitReadonly, CUniverseMultipleTypes, CUniversePeer, CUniverseReadonly, CUniverseRep, CU-niverseRepCluster -AST classes: JArrayAccessExpression, JArrayInitializer, JAssignmentExpression, JCas-tExpression, JClassDeclaration, JClassFieldExpression, JExplicitConstructorInvocation, JFieldDeclaration, JFormalParameter, JLocalVariable, JLocalVariableExpression, JMe-thodCallExpression, JMethodDeclaration, JNewArrayExpression, JNewObjectExpression, JParameterExpression, JParenthesedExpression, JReturnStatement, JThisExpression, JTypeNameExpression, JUnaryPromote, JVariableDeclarationStatement, JVari-ableDefinition -Classes and interfaces for types, methods, and classes: CArrayType, CClass, CClassType, CInitializable, CMethod -Other classes needed for uniqueness: CUniverseUniqContext, CUniverseUniqContext-Type, CUniverseUniqMessages, CUniverseUniqUtils Chapter 9 Conclusion and Future Work 9.1 Examples 9.1.1 Enhanced Linked List Figure 1.3 shows the implementation of a linked list with the possibility to merge two linked lists. Due to our extension we can enhance this linked list. First of all in our implementation (A.1) we can simplify the releasing of a linked list as explained in section 2.2.11. We added a second method concatenate(free Node first, rep[ first ] Node last)\n\nwhich adds not a whole list given as parameter but only a part given by the first and the last list element. This shows the benefit of passing multiple references to one free cluster via method invocation.\n\nAs a further additional feature we implement a method pure free LinkedList find(free Iterator it , any Element obj) that searches an element given a list iterator. Inside of this pure method we have to call the non-pure method getN ext on the iterator. Thus, we make use of our enhanced purity.\n\nThe code in A.2 shows the merging of two hash tables. In the two merge methods we make use of the possibility to transfer whole arrays. First in method call merge(otherTable.getHashTable());\n\nwe release one hash table represented by an array and in the method merge:\n\nvoid merge(free peer LinkedList[] otherTable)\n\nwe capture this hash table. Thus we changed the owner of a whole array.\n\nIn the AVL Tree example (A.3) each subtree is owned by its parent node. Thus for each change of the parent node an ownership transfer is needed. Note that the left and the right tree of a node are in different clusters since they are moved independently. The two methods free AVLTree getLeft() and free AVLTree getRight() are used to release the left or the right tree of a node, while the corresponding methods void setLeft(free AVLTree left) and void setRight(free AVLTree right) capture a free tree. The rotation methods like free AVLTree rotateWithLeftChild(free AVLTree k2) capture a free tree, make the desired rotation on it and return the released tree. Similarly works the insert method free AVLTree insert(int x, free AVLTree t).\n\nIt captures a tree, inserts the new node by modifying and rotating the tree and returns the released tree.\n\nIn this project we have completed the existing Universe type system with ownership transfer with different extensions. The biggest extension was the type inference for local variables. Due to it we get a more flexible solution since local variables can change their type and never become unusable.\n\nOtherwise we could eliminate minor limitations of the existing system like the problem with the release method in the list example (see section 2.2.11). Another advantage is that the user has less notation overhead since no Universe modifiers for local variables are needed. On the other hand our solution is more complicated to understand for the user. The different handling of local variables and fields can be confusing and thus is another disadvantage of the local variable type inference.\n\nThe enhanced purity allows more expressive examples like the f ind method in the linked list (A.1). In fact, the precondition for the enhanced purity is complex but since it is only an extension to the old purity there is no must for the user to make profit of it. Thus, the benefits of our enhanced purity are bigger.\n\nWith the subclass separation we separated the this cluster of a class from the this clusters of its subclasses. For the user the assignability of variables in the this cluster is more restricted. But this feature has the advantage that the invariant of a subclass can be checked without touching the superclass. This would be nice if once the Universe type system is integrated in Spec#.\n\nFor array handling we achieved a good solution which is derived from the handling of fields. Array creation and initialization expressions are supported too. There is only the restriction that all array elements should always be in the same cluster.\n\nOur last extension was the support for passing multiple references to one free cluster via method invocation. This is a powerful feature which allows methods like concatenate in the linked list example (A.1). On the one hand we tried to use the existing syntax for this feature. On the other hand this can be confusing since rep[f ] does not always refer to a cluster declared by a field.\n\nThere are still some extension to the project which are left as future work: Runtime Checks. In the method typeCheck some Universe runtime checks are done. They make use of the declared Universe types. For local variables the type determined in the analysis should be used. Thus, these checks should be moved to the method checkU niverseU niqueness-N oF lattening.\n\nException Handling Model. In the current system exceptions are handled in a primitive way. For the future a more precise treatment is desirable. A possible solution is to transfer an exception into the context of the handler during propagation.\n\nIn earlier descriptions and in currently implemented tools, any is called readonly\n\nWe use the term \"fields\" for instance variables declared within a class and outside a method whereas \"local variables\" are declared inside a method. \"Variables\" includes both fields and local variables.\n\nWe use the term \"type\" as short for ownership type. If we mean Java types we explicitly write this term out.\n\nFor understandability we list any and peer fields in the cluster sets in all following examples although they are not really held in the sets. Also we mention the markers for all clusters although in the developed type system we do not use markers for transferable clusters. In addition we leave out not used sets.\n\nFormalization"
}