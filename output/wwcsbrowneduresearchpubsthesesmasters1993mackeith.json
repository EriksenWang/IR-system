{
    "title": "EREQ Query Representation and Cost Model",
    "publication_date": "1993-05-06",
    "authors": [
        {
            "full_name": "Andrew Clement",
            "firstname": "Andrew",
            "lastname": "Clement",
            "affiliations": []
        },
        {
            "full_name": "Thornton Mackeith",
            "firstname": "Thornton",
            "lastname": "Mackeith",
            "affiliations": []
        },
        {
            "full_name": "Andrew C T Mackeith",
            "firstname": "Andrew C T",
            "lastname": "Mackeith",
            "affiliations": []
        }
    ],
    "abstract": "This paper describes the implementation of a Tree Repre sentation of a query in the Equal Query Language. The tree is annotated with data such as local variables, and cost of the sub query (in disk accesses). The cost func tions used for these annotations are based on the paper \"An Analytical Model of Object-Oriented Query Costs\" by E. Bertino and P.\nFoscoli, March 30, 1992\n. This has been adapted for used with the above Tree Representa tion of an Equal Query.",
    "full_text": "Andrew Clement Thornton MacKeith  RepCost 6 May 1993 page 3 EREQ Query Representation and Cost Model\n\nAppendices AppendixA: Class Definitions 27 Query Rep class OptRepMetaClass 27 class vlist 27 class AnnotList 27 class Op 28 class Node 29 class FunctionNode 30 class DataNode 31 class InputDataNode 32 class ClnputDataNode 32 class VInputDataNode 32 class F1)~c 33 class DF~c 33 Schema Manager and Cost Model class SchemaMgr 34 class TypeData 35 class PathString 37 AppendixB: Function Descriptions 39 B.1 Query Rep. 39 B.l.1: class ~cNode : OptRepMetaClass 39 B.1.2: class Op: OptRepMetaClass 40 B.1.3: class Node : ~cNode 41 B.1.4: class FunctionNode : Node 41 B.1.5: class DataNode: Node 42 B.1.6: class InputDataNode: DataNode 43 B.1.7: class VlnputDataNode : InputDataNode 43 B.1.8: class CinputDataNode : InputDataNode 43 B.1.9: class OtherDataNode : DataNode 44 B.l.10: class ~c : ~cNode 44 B.l.11: classDF~c:~c 44 B.1.12: class F1)~c : ~c 44 B.2 Schema Manager 45 B.2.1: class SchemaMgr: OptRepMetaClass 45 B.3 Cost Functions 46 B.3.1: class TypeData : SchemaMgr 46 B.3.2: class TypeDataType : TypeData\n\nThis paper describes the implementation of sections of the EREQ project The three parts dealt with in this paper are:\n\n• A new query representation to be used by the EREQ query optimizer.\n\n• A revised Schema Manager, and • A cost model for the optimizer to be used in conjunction with that representation.\n\nThe EREQ query rep is a C++ model and is an extension of a previous model written in C.\n\nExperiments have been done using the cost model to show how the cost of a query varies with respect to the various parameters input to the cost model.\n\nThere are several different structures that a database schema may use for a multivalued object. The most common description of on of these is a set. I have tried not to use the description \"set\" since this can be confused with \"set value\" as a verb. The description \"multivalued attribute\" therefore is meant to cover set, list, tree, array or any collections of objects in an attribute.\n\nPrimitive types are defined in [BERf92] as Integer, Float, String and Boolean. (paragraph 2, Definition 4).\n\nWork has been done previously on the parser and tree builder by George C. Lo (gel) in 1992. This formed the basis of the tree which has been used to build the current query rep as described here. In this paper I call this previous tree representation \"qTree rep\". This previous work provided an API which was incorporated in a library called IibRep.a.\n\nThe library had been used to implement the following programs:\n\n• \"table\". This could be used to build a data dictionary to describe the schema of the database being que ried.\n\n• \"opt\" This program calls an optimizer generated by the Exodus optimizer generator, and displays the query tree in graphical form in an X-window. This is based on the API functions createQueryTreeO and printTreeO. The displayed query tree is of the qTree type.\n\nThe current work has included the following:\n\n• Amendments and additions to previous program. Several changes and additions to the previous work have been made. These have not changed the func tionality of the qTree API, but have been done for two reasons: 1. To avoid duplication of functions in dif ferent programs, and 2. to provide additional functions to access the data dictionaries created by gcl. The original program \"table\" has been rebuilt and renamed \"OptRepTable\". Most of the functionality provided by the functions in table (functions also in the library IibOptRep.a) are now provided by the class SchemaMgr.\n\n• Implementation of new Query Rep as proposed by T. W. Leung. The aim of the new query rep is to provide an Object Oriented version of the query tree (an EAT or Equal Annotated Tree) which can be used in the extensible optimizer now being built at Brown. The qTree representation of the query tree has been used as a basis for the new Query Rep, to avoid having to rebuild the query parser. The new rep uses the previous model as a basis, so the parsing of the query is done by the functions that build the old rep.\n\npage 6 6 May 1993 RepCost File: OptRepMeta.H \";;i~~;~;:~~~::~;;\"\"\"'~\"\"\"\"\"~\"\"\"\"\"~\"\"\"'\"\"\"~\"\"\"'~~~:~:~::~~~~~~:~~~\"\"\"\"\"'\"\n\n.\n\nFeatures of the new Rep are: 1. The Annotations are now fully extensible. 2. Arcs between Nodes are now objects and have Annotations.\n\n3. Type checking of the graph is accomplished through the use of the C++ type checking mechanism. 4. New Annotations have been added: \"path\" Annotation, and \"cost\" Annotation.\n\n. 5. An additional field of the DataNode enables the size of a multivalued variable (ie a SET) to be stored.\n\nThis information is required for cost calculations. 6. Methods of the new Rep include methods to build Query Paths of the kind used by Bertino. These query paths are described in more detail below under Cost Model, but simply, a query path is of the form VariableName.AttributeName. This can be extended as far as the schema allows such as Y.A 1.A2.A3.A4, until a primitive type is reached. The function BuildQueryPathsO assumes that a FunctionNode operator that is NOT predefined is an attribute of a type.\n\nAnnotations may be of any type. Previously the qTree only supported a LambdaVar type in the Annotation list. The annotation list is now implemented as an Associative Array of void*, via a Map structure. This provides a fully extensible means of adding annotations using a string \"name\" as key. One of the problems with the void* representation is that the data cannot be copied by a copy constructor, neither can the data be deleted by a destructor. A special class has been defined to use with Annotations, which is similar to a very simple list node, but including the size of the data object of the list element. This will allow copying and deletion of an Annota tion List without knowing anything about the list except the size of the data block in the list, however this has not been implemented. New Annotations have been added: \"path\" Annotation, and \"cost\" Annotation. Functions exist in the Rep to manipulate these annotations, which questions the assumption that the annotations should be of type void*. However, this question is left open.\n\nThere is a method of this name in the classes FunctionNode, DataNode, FDArc and DFArc. In each one the principle is the same but the method has a different function. The tree is searched from the root for the Query Paths, and the Paths are built as the tree is traversed.\n\nIf the constructor DataNode::DataNode(USLString) is called with no second argument, no paths are built, and no cost data is calculated. If the constructor is called with a second argument of TRUE then the paths and the costs are annotated to the tree. This allows the tree to be built without having a file of cost data available. The methods in the Arcs just call the BuildQueryPathsO function of the Child and then copy the path and cost annotations to themselves from the child. The methods in the Nodes are more complex, but in principle, the DataNode::BuildQueryPathsO builds the paths, and FunctionNode::BuildQueryPathsO calculates the costs that cannot be directly calculated by the PathString::getCostO function. A Path is only built for a sub-tree below a FunctionNode that is an attribute, or for a leaf node that is a global variable.\n\nThe class definitions are in Appendix A. Function descriptions are in Appendix B. page 8 6 May 1993 RepCost 3.3 Schema Manager.\n\nThe Schema Manager is used to find details of any type in the database. The type details stored in the schema manager for each type T include • Structural details such as supertype and subtype ofT, and attributes ofT (and their types).\n\n• Cost parameters used for calculating cost of a Path, as described below. See paragraph 3.4.5 The Query Path. on page 10. The principle is that the class SchemaMgr should replace the functions of the file \"OptRepThble\" previ ously written by gcl. Class TypeData and PathString are both subClasses of class SchemaMgr. The type names, attribute details and variable names are taken from the \"gcl\" data dictionaries.\n\nThe previous query rep and current optimizer use a schema manager written by gcl. The functionality of this fonnaer schema manager is implemented in the files OptRepTable • e and OptRepCompute. e • The \"gcl\" data dictionaries are named. type_diet, • at tr_diet and • data_diet. The internal \"gel\" data dictionary has to be initialized by calling the function readlnBufO which reads the *_diet files in the current directory. This is done implicitly by calling ereateQueryTree ().\n\nThe Schema Manager used for the cost functions is composed of three classes: SehemaMgr, TypeData, and PathString. The Functions of these classes are briefly: SehemaMgr: provide a reference table of type data.\n\nTypeData: provides a structure for data relating to each type.\n\nPathString: calculates all the functions specified in the cost model of [BERT92].\n\nThe Schema Manager is not activated until the SchemaMgr constructor is called. This is called by the con structor of any subclass of SchemaMgr, ie classes TypeData or PathString. The first call to the SchemaMgr constructor calls the function buildTypeMapO, which builds the associative array typeMap that provides the reference for all infonnation on the types in the schema via the type name. The typeMap is a structure of class Map(USLString), TypeDataPtr).\n\n3.4 Cost Model.\n\nThe basis of the cost model is the paper entitled \"An Analytical Model of Object-Oriented Query Costs\" by E.\n\nBertino and P.Foscoli dated March 30, 1992 [BERT91]. . RepCost 6 May 1993 page 9 EREQ Query Representation and Cost Model / \" Figure 2: qTree Query Tree as produced for the optimizer Query text:\n\nProject(places,$p{ (place,p), (Tours,Select(Tour,$tp memberof Image(t@description,$w w@what@address@city@title»)}) page 10 6 May 1993 RepCost\n\nThe cost functions described in [BERT92] are for evaluating a nested predicate of the fonn:\n\nCl.Al.A2.....An. op expo I have asswned that the operator is of a fonn that requires equality, rather than a range to be resolved. Without this constraint the number of objects which resolve the query is not detenninesd\n\nThe function names which refer to the parameter fields of the PathString class have been kept as close as possible to the names used by Bertino. The class which holds infonnation about each type is caIled TypeData. This is roughly equivalent to the reference Cij adopted by Bertino. (See 3.1 Class and Type on page 4.)\n\nThe reference method to the types of the attributes in the path is by indexing a two dimensional array which is built whenever a PathStr ing is built. The cost parameters are generally of the fonn XCi) or X(i,j), where i refers to the type of attribute (i-I) in the path. The path is of length n since are n attributes in the path. If the type of the last attribute is included, we have n+1 types. Bertino does not include the type of the last attribute This is always a primitive type in her queries. I have included it in my Path String, since the last attribute of a path taken from the EAT may have a non-primitive type. This data is not used at present in this implementation. The access functions to the cost parameters are methods of the class PathString, but there are parallel methods in the class TypeData. Where possible, if a parame ter depends on more than one type, the access method calculates the parameter when it is called. For exam ple N(i), which is a function of all the types in the type hierarchy rooted at C(i,I).\n\nA complete class listing is given in appendix A on page 27.\n\nThe end of a path as described in [BERT92] is always a primitive type. The paths that I consider do not always keep to this restriction. A primitive type is a Integer, Float, String, or Boolean type.\n\nA Path is a string describing a type plus zero or more attributes. The length of the path is the number of attributes in the path. Note that the type oJ Attribute(i) in the functions and in [BERf9I] is cei+1,1). The definition of a path is shown below. The Type of each element of the path is shown under each element. cei,l) refers to a Type. Generally, cei) refers to the type cei,I). Type . Attribute(l). Attribute(2) Attribute(i) Attribute(n-I) . Attribute(n). cel,l) . ce2,1)\n\n. C(3,1) cei+l,l) cen,I). For the purpose of the EREQ query tree I have interpreted the Path as variable plus attribute(l) etc. The variable at the start of the path is a variable named in a leaf DataNode of the tree.\n\npage II EREQ Query Representation and Cost Model 3.4.6 Cost Parameters.\n\nA full list of the Cost Parameters is given in the table on page 17. Some of the parameters have been elim inated by making assumptions about the nature of the database schema. These assumptions are listed below. Assumption 1. Number of pages containing members of the type C(i) is assumed to be the sum of the number of pages containing instances of each type in the hierarchy. This assumes the same clustering of instances in the hierarchy based on a class as the instances of the base class. Therefore Ph(i) =:I:j P(i,j). Assumption 2. Number of distinct values for attribute A(i) for all instances in the inheritance hierarchy rooted at type CO, I) is assumed to be sum of those for each type in this hierarchy. Therefore DO) = :I:j D(i,j). Assumption 3. The average size of a multivalued attribute over the members of a type is assumed to be the average over the average size for each of the constituent types. FanO) = (:I:j fan(i,j) * NO,j» / (:I:j N(i,j».\n\nThese assumptions reduce the number of statistical parameters supplied to 2 per'JYpe plus 4 x number of attributes. (N(i,j), P(i,j), plus a value of D(i,j), fan(i,j), d(i,j), and rei) for each attribute of the 'JYpe.) 3.4.7 Cost Parameters D, fan, d and r. DOJ), fan(iJ) and d(iJ). These parameter can be different for each attribute of a type. For example, with reference to the above path, C(l,l) has an attribute Attribute(l) of type C(2,I). The value of fan(l, 1) in this case is the collection size of Attribute(l) (See \"Multivalued Attributes\" on page 5.). If A is not multi valued, the value offan(l, 1) is 1. As can be seen, the value offan(i,j) depends on the attributes in the par ticular path.. rei). This parameter is a Boolean, TRUE if there exists a \"reverse\" reference from type C(i) to type CO-I).\n\nJust as the average Set Size has to be stored for each attribute of a type, there could be a reverse reference from type T to (theoretically) any other type in the schema. Since it would only be interesting for refer ences (connections between types) that might exist in a path, I have stored the reverse reference as a parameter of the type referenced. (ie the type that the reference points to rather than the referencing type.) Type C(i) must therefore ask C(i-l) to find out if there is a reverse reference to C(i-l).\n\npage 12 6 May 1993 RepCost\n\nThere are several constraints that must be checked if values for the cost parameters are invented for exper iments. These are: d is the number of instances of C(ij) with no NULL vales for A(i). This cannot be greater than the number of instances of the type, the cardinality Nij. Therefore: d(i,j) <= N(i,j).\n\nP is number of disk pages containing instances of the type C(ij). I have assumed that an instance does not occupy more than a disk page; this allows a check to be made as to whether this parameter is sensible. P(i,j) <= N(i,j) D is the number of distinct values for Attribute A(i). There cannot be more distinct values than the cardi nality of the domain of the attribute. Therefore: D(i,j) <= Nh(i+l).\n\nSimilarly to the above, the if the attribute A(i) is a set (or more generally a collection), then the collection size (or set size) of attribute A(i) cannot be greater than the cardinality of the domain of the attribute. Therefore: fan(i,j) <= Nh(i+ 1). This is not true if duplicates are allowed in a set. I have assumed that they ar not.\n\nThe collection size of attribute A(i) cannot be greater than the number of distinct values for attribute A(i). Therefore: fan(i,j) <= D(i,j) If this is violated, it affects cost functions PrllO and Pr12), thence ReffiyO and ReffiyhO.\n\nThese constraints are all checked during the building of a path, with the exception of DO which is checked (together with the others) in function PathString: : getCost ( ).\n\nThe requirement fan<=D, means that another requirement k(ij)<=d(i,j) is not violated. This last affect the other functions thus:  FOIWard Traversal is to compute the cost of accessing the type C(n,l) (as well as its subtypes if applicable) from just the type C( I,1) or from CO, 1) and its subtypes according to the type of the query.\n\nReverse Traversal is to compute the cost of accessing a type C(1,1) (as well as its subtypes if applicable) from the type C(n, 1) and its subtypes. Nested Loop searches for each attribute in the path in tum using a sequential search loop. Sort Domain sorts the whole domain of a type and then passes this to the next type in the path to be fil tered.\n\nThe strategy is given as an argument to the getCost function of PathString.\n\nThe 4 strategies are therefore: NLFf Nested Loop FOIWard Traversal NLRT Nested Loop Reverse Traversal SDFT Sort Domain FOIWard Traversal SDRT Sort Domain Reverse Traversal\n\nThe SaRTO function used in the retrieval method Sort Domain assumes 100 OlD's per disk page for the sort. OIDperPage = 100;\n\nIn the cost functions the Cardinality of the range of values that resolve the predicate has an effect on the cost. For a predicate of the type \"attribute==value\", the cardinality is 1, whereas if the relational operator is <, >, <=, >=, the cardinality is unknown. I have therefore assumed a cardinality constant cardPred = I. 3.4.10 Cost Functions.\n\nDetails and a brief description of each of the cost functions are given in Appendix B2, page 46.\n\nThe Cost Model and the EAT.\n\nOn essential difference between the path used Bertino cost model and the path used in the query tree Rep (the EAT), is that in the path built by the EAT, there are no multivalued attributes. For example, if we have a type \"Hotel\" which has a multivalued attribute \"facility\", and a variable \"TheRitz\" of type Hotel. Ber tino would allow a path which includes TheRitz.facility. In our Query Tree, the operator Image (or Select) is used to iterate over the values in the set, and the operator Image is represented by a FunctionNode in the Tree. The Path therefore stops before the Image operator.\n\nIn the experiments therefore, I have used a Path which is not obtained from the EAT, but built directly from a string representation of a Path.\n\n3.4.12 Cardinality of values that resolve the predicate.\n\nI have assumed a value of I for this factor (cardPred=I). This implies Attribute==Value, rather than <,>,<= or >=. Values for the other comparison operators would be I~er, but undefined. This factor is used by cost functions NIO and V30. See [BERNI] paragraph 3.2.\n\n;\"\n\nThe meaning of Target Class in [BERT91] is not clear. It would appear that this would be type qn,l), ie the class at the end of the query path, but on paragraph 3.2 of the paper (category 1) it is clear that the tar get class can be C(l,l) with the path length greater than 1 (k=2 where 1<k<=n in NI(k) for Execution Strat egy SDFf). I first assumed that the Target Class (named targetType in PathString) is C(n,l), however I believe that the definition is in paragraph 2.2 of [BERT91] implies that the target is the type at the start of the path. If the attribute specified is an attribute of the base type (or the most specialized type in this spe cific hierarchy) then targetType is the type C(l). If the attribute is not an attribute of the base type, but of one of the sub types in the hierarchy, then the targetType is \"IN\" type C(l). This is the same as saying that the targetType is a member of C(l).\n\n4.0.1 Location of Rep/ directory. The full path name of directory Rep/ is /pr%odb/opt/Rep/. 4.1 Sample Database: The Altair Travel Agency. 4.1.1 Source of the Schema. The database schema for the Altair Travel Agency is a sample 02 database schema. The data for this data base schema is in the directory Rep/altair. The program OptRepTable in the directory Rep/RepLib (formerly table in directory Rep/rep_lib) has been amended to be able to import a text file of this type, and the file. text_diet has been read into the data dictionary files. type_diet, • data_diet and • attr_diet in this directory.\n\nThe parameter values used to calculate costs are in the disk file. OptRepTypeCostData. This file is intended to simulate statistical information obtained from a real database. This file must be in the default directory. Information is read from this file when the first instance of the class SehemaMgr is declared. This hap pens when an EREQ query tree Rep is built, and the \"path\" annotations are added. This class data is stored in a Map structure named typeMap, which is a static field of the class SehemaMgr, the super class of both TypeData and PathString. The values of these parameters is invented, and because of the constraints between the parameters that need to be maintained it is difficult to maintain compatibility between parameters when varying one parameter at a time.  \"\n\nThese parameters are described in [BERT92] paragraph 3.1. They refer to a PATH composed of a variable and n attributes, each one an attribute of the previous type in the path. The type of each of the objects in the path is shown below as C(i, 1). In our implementation C(i, 1) refers to an instance of the class TypeData. Object. Attribute(l) . Attribute(2) Attribute(n-I) . Attribute(n) C(l,I) . C(2,I)\n\n. C(3,I) . . . . . . . . C(n) Many of the parameters described in [BERT92] are derived from a few basic parameters; in addition some assumptions (given below) reduce the required cost parameters per type to 5 plus one for each multivalued attribute of the type.\n\nAll the parameters are integers. i indexes into the path length. 1<=i<=n. j indexes into the members of the type hierarchy based at C(i,I). 1<=j<=nc(i). Note that parameters D(i,j), fan(i,j), d(i,j) and k(i,j) depend on the type and an attribute of the type, param eters N(i,j) and P(i,j) depend only on the type.\n\nNumber of distinct values for attribute A(i) of type C(i,j), I<=i<=n, I <=j<=nc(i).\n\nN(i,j) Cardinality of type C(i,j), I <=i<=n, 1<=j<=nc(i).\n\nfan(i,j) Average number of references to members of type C(i+I ,j), contained in the attribute A(i) for an instance of type C(i,j), 1<=i<=n,I<=j<=nc(i). Note that for single valued attributes, fan=!.\n\nAverage number of instances of type C(i,j), having a value different from NULL for attribute A(i), 1<=i<=n and I<=j<=nc(i).\n\nPHYSICAL Data Parameters (data) P(i,j) Number of pages containing instances of the type C(i,j) for I<=i<=n, I <=j<=nc(i) .\n\nA binary variable asswning value equal to I if members of type C(i,j) have reverse references to members of type C(i-I,I) in the path, equal to 0 otherwise for 2<=i<=n. This value obviously varies depending on type C(i-I).\n\nThe following parameters are all derived from the above parameters and the particular path being considered, either by summing over the sub-classes of the type C(i,l), or by other means. fanh(i) Average number of references to members of type C(i+1,1) contained in the attribute A(i) of a member of type C(i, I), 1<=i<=n. The difference between this parameter and fan(i,j) is that this parameter is obtained as the average evaluated on all members of a type hierarchy, while in fanCi,j) the average is for each class.\n\nAverage number of members of type C(i,l), having a value different from NULL for attribute A(i), 1<=i<=n; dh(i) = SUM(1<=j<=nc(i))(d(i,j)).\n\nk(i,j) Average number of instances of type C(i,j) having the same value for attribute A(i), l<=i<=n and l<=j<=nc(i); k(i,j)=CEILING((d(i,j)*fan(i,j))JD(i,j)).\n\nAverage number of members of type C(i, 1) having the same value for attribute A(i), 1<=i<=n.\n\nPh(i) Number of pages containing members of the type C(i,l) for 1<=i<=n. Assumed to be SUM[j] P(i,j); theoretically could be smaller than the sum, if there is some clustering.\n\nNI(i) Number of members of type C(i, 1) to be searched for, 1<=i<=n.. Depends on previous parameters.\n\nNumber of accessed pages containing members of the type C(i,l) for 1<=i<=n.\n\nReffiy(i,s,y,k) Average number of values contained in the nested attribute A(y) for a set of k instances of type C(i) whose position is s in the inheritance hierarchy. 1<=i<=y<=n, 1<=s<=nc(i), 1<=k<=Nh(i).\n\nReffiyh(i,y,k) Average number of values contained in the nested attribute A(y) for a set of k members of type C(i, I), 1<=i<=y<=n, 1<=k<=Nh(i).\n\nk_bar(i,j) Average number of instances of type C(i,j) having the same value for the nested attribute A(n), 1<=i<=n, 1<=j<=n.\n\nAverage number of members of type C(i,l) having the same value for the nested attribute A(n), 1<=i<=n.\n\nRef(i,s,y,k) Average number of instances of type C(i,s) having as value of the nested attribute A(y) a value in a set of k elements for 1<=i<=y<=n, 1<=s<=nc(i), 1<=k<=Nh(i). Also in this case, as for RefBy(i,s,y,k), s determines the position of the type in the inheritance hierarchy supposing that the classes are sorted in the hierarchy.\n\nRetb(i,y,k) Average number of members of type C(i,l), having as value of the nested attribute A(y) a value in a set of k elements for 1<=i<=y<=n, 1<=k<=Nh(i).\n\npage 18 6 May 1993 RepCost 4.2 A driver program to create the EREQ rep.\n\nThe files are located in the directory /pr%odb/opt/Rep/.\n\nThe executable which drives the current programs is named makeRep. This takes 2 arguments. First a file name which should contain a query in the correct format, and second an integer which selects certain out puts.\n\nUse 1 to just output the query paths and the cost of each query path. Use 2 to output the query tree in the EREQ Rep format. This produces quite a lengthy output, but the fields can be inspected this way. Use 3 to output the Class Map which is used when calculating the cost. Use 4 to create a qTreeType tree from the EREQ query tree and display it using TREEprincqTreeO. Use 0 to output all 4 of the above. For example, to print the costs for the query paths generated by the query contained in the file altairll.input, type: > makeRep altairll.input 1 alternatively, use makeRep from the altair subdirectory, type:\n\nThe queries used for testing were taken from the file test-queries. In order to get these into the fonn required by the \"opt\" parser, I wrote a translator in emacs lisp. This function is named o2-equal-conv and is in the file o2-equal-conv. el. A listing of the latter file is in Appendix C.\n\nThe graphical output from opt, produced using the function TREEprint_qTree () is shown on page 9\n\nThe output from the EREQ Rep has not yet been output in graphical fonn. A sample of the output from the EREQ rep, indicating the fields of the Nodes, is included on page 9.\n\nThere is a paradoxical result in the \"cost\" annotation that the cost is zero when the strategy is Reverse Traversal and reverse references are provided. See note in [BERT92] section 3.2 after the section on Nested Loop Reverse Traversal. This is because in those cases the path length is I and in this case, the reverse pointers, that are given as OlD's form the solution of the query.\n\nExperiments have been carried out to see hoe the cost varies as the input parameters are changed.\n\nTo do this I have built a PathString from scratch, not via the Query Rep, and varied one parameter at a time. The driver used for these experiments is named costExp, and is in the directory Rep/work.. 4.3.1 Use of the experiment driver programs, costExp and costTest. These programs are in the directory Rep/work/. The driver program costExp will produce calculate the results of varying one parameter of N, fan, D, d, or P. All 5 can be done in one run in series, and each execution strategy can be selected. In addition, RepCost 6 May 1993 page 19\n\nboth values for the parameter r can be displayed. It is assumed that the user of the program will be able to amend the source code file costExp . C if more experiments are to be carried out.\n\nIn order to trace the reasons for the relationships described below, I compiled the cost functions with the variable TESTING defined. This is done in the makefile by giving a flag -DTESTING. This causes addi tional output giving the values of individual functions. The library functions have been compiled with TESTING not set.\n\nThe driver costExp produces several temporary files, suffixed. tmp, and two results data files. The first (named \"plotnnnn.xy\") is used to plot the points using xgraph, and the second (named \"plotnnnn. txt\") which prints out the data points in a more readable fonnat..\n\naddition there is a second test file, named costTest, which can be used to test individual PathString functions. At present only HO works, but it is easy to add a function to this program and then test a function by caIling costTest <function name> <arg 1> <arg 2> etc.\n\nThe above programs call the program xgraph to display their results graphically. These have been included in Appendix D. The output from the experiments is shown in Appendix D: Experimental Results on page 57.\n\nTo import the plots into this document, the xgraph file was written out to an idraw file. The idraw file was then imported to idraw and written out as an EPSI file (the \"save as\" option). Since an encapsulated post script file can be imported into framemaker, this is then imported into framemaker as a graphic file.\n\nTo dump the xgraph direct via xwd or the frame capture option would have printed the data lines as colored lines, which are fairly unreadable in monochrome.\n\n1.1 to 1.1.5.\n\nThis is based on the Path \"City.places_to~o.name\". I have varied each parameter of the type \"City\" in tum, keeping all others constant. The plots of these are shown as Experiment I. I.l to Experiment U.S. The constant parameters of the PathString are as follows: City.p1aces_to~o.name Parameters given. Object: Class: Dij Nij fanij dij Pij ri city :City 100 100 10 80 100 o Attribute: places_to~o :Place_tg 200 200 1 71 200 o : Monument 1 10 1 1 5 : Museum 1 10 1 1 10 :'l'heater 1 12 1 1 12 name : string 1 10000 1 1 10000 o Parameters calculated: Object: Class: kij Di Nh fani di kh Ph City :City 8 100 100 10 80 8 100 Attribute: places_to_go :Place_tg 1 203 232 1 74 1 227 : Monument 1 •Museum 1 .'l'heater 1 name : String 1 1 10000 1 1 1 10000\n\nNote that some of these parameters seem a bit dumb. For example, what does it mean that a primitive type such as \"string\" has a cardinality N ? This should be an exception, but it is not done this way yet.\n\npage 20 6 May 1993 RepCost\n\nThe first result from 1.1.I.and 1.1.2 shows that NLFT depends directly on Cardinality \"N\", and the set size of attribute \"fan\", and not on the other parameters. The functions for NLFT are just this: (see [BERf92] para 3.2 Category I). The cost is N(l,l) *fan(1,I), then progressively cost = cost * fan(i,l) along the path.\n\nIf all the parameters (fan==I) then the cost will be the size ofN(1,I) only. Experiments 1.1.3 and 1.1.4 shows that nothing depends on parameter D or d. This seems surprising and may be due to this being the first attribute in the path. Experiment 1.1.5 shows the effect ofP, number of Pages containing instances of the type. As the number of pages increases, the cost increases.\n\n4.5 Experiments 2.1.1 to 2.1.5.\n\nThe second set of experiments is based on a similar Path to the first. In this case the parameters of the sec ond type C(2, I) are varied.\n\nCity.places_to-9o. address. street Parameters given, Object: Class: Dij Nij fanij dij Pij ri City :City 100 100 10 80 100 o Attribute: places_to-9o :Place_tg 61 200 1 71 100 o : Monument 1 10 1 1 5 : Museum 1 10 1 1 10 : Theater 1 12 1 1 12 address :Address 12671 155 1 134 155 o street 'String 1 10000 1 1 10000 o Object: Class: Parameters calculated: City Attribute: ,City kij 8 Di 100 Nh 100 fani 10 di 80 kh 8 Ph 100 places_to_go :Place_tg : Monument 2 64 232 1 74 2 127 lMuseum 1 lTheater 1 1 address lAddress 1 12671 155 1 134 1 155 street 1 1 : String 10000 1 1 1 10000\n\n• Experiment 2.1. The top graph (NJ...,) shows that N(2, 1) does not alter the cost. This is as expected; see note in 4.4.2 above. The particular parameters selected for this case produced an error message, that N(2,1) is smaller than D(1,I) and P(2,l). The bottom graph (SD), shows that there is an inverse relation ship between cost and N, for SDFT, values of N>=73. The reason for the out-of-range values for cost is that the parameter Ph>Nh. This causes the function of Yao (pathString::HQ) to give a stupid answer. The program gives error messages if it detects such a conflict. The reason for the inverse relationship also lies with the function HO; this is because, as N(2) increases, with P constant, the concentration of records per page is increasing. This increases the hit rate. The number of records to be searched for is constant, since RepCost 6 May 1993 page 23 EREQ Query Representation and Cost Model\n\nthis depends on N(l) and not N(2), therefore the cost reduces as N(2) increases. Note that increasing N(2) without increasing P(2) is not a realistic relationship. SDRT with and without reverse references are constant, although not the same value.\n\n• Experiment 2.2. Since this attribute is not multivalued, there is no experiment .2 in this series.\n\n• Experiment 2.3 and 2.4. Similar conflicts to 2.1 above have given cause to the steps in the graphs of NLRT for varying D (graph 2.3), and NLRT for varying d (graph 2.4). From graph 2.3 we see that for SDFT, cost is proportional to D, the number of distinct values for attribute A(2).\n\n• Experiment 2.5 shows a linear relationship between P and cost for SOla when r=0, (SDRT and r= I is flat. There is a more complex relationship for cost when SDFT is considered. This is the effect of the function of Yao, which calculates the \"hit rate\" when searching for records from the disk.\n\nThe new query rep provides all the functionality of the old, plus more facilities, with one exception, and that is the fact that the annotations are not typed.. There are some unsolved problems with the Annotations, due to the fact that they are not typed, and therefore cannot be copied, deleted, or checked for equality in a general way.\n\nThe Schema Manager has been written to enable access to type details, and to include type cost parameters.\n\nIt does these successfully, although the functionality which has been added in comparison to the previous schema manager is only in relation to the cost parameters.\n\nSchema Manager class provides a framework for adding further properties of types in the future.\n\nThere have been some problems in interpreting Bertino's model. One of these is the interpretation of a \"class hierarchy\". The idea is to assume that each hierarchy will be separate until a TOP_CLASS is reached. It seems that there will be a schema where the classes are related, and so the hierarchies will not be so distinct. I have assumed in the implementation that the named class C(i,j) is the root of a hierachy, but this may not be the intention of [BERT92]. Overall this cost model may provide the best model in the absence of a specific database model to base a cost model on.\n\nThe [BERT92] cost model has been shown to have some problems. One of the worst of these is the difficulty of inventing values for the cost parameters in the absence of \"real\" data to work on. The problem is that it is almost impossible to keep all parameters constant and vary just one to see what effect this has page 24 6 May 1993 RepCost on the cost. This has particularly inhibited the testing of the model, perhaps it is a function of the models comprehensiveness.\n\nOne possibility would be to generate random values for the cost parameters, constrained as indicated in this paper, and use these to generate costs. If this were done many times, perhaps some trends could be seen.\n\nThere are functions not yet implemented, such as copy constructors, and operators such as equality and assigrunent. Should these be recursive'! The graphical output is at present only possible by converting the EREQ rep back to the qTree rep (using DataNode::createQueryTreeO) and printing qTreeType. If the EREQ rep could be displayed graphically, it would then be possible to add selected fields from the rep to display; fields which are not present in the old rep.\n\nThe next step would be to ensure that no functions from OptRepTable.c are called by the Rep classes or RepCost classes, except via the class SchemaMgr. This would provide an easy way to substitute the new schema for the old one at some future date, when the optimizer can access the new one.\n\nThe next step to incorporate this model into the EREQ query tree would be to use the cost model functions to calculate the costs of paths that include a FunctionNode of the type Image or Select. This would require modification of the function FunctionNode::BuildQueryPathsO. RepCost 6 May 1993 page 25 6.4 General 6.4.1 Location of files. The files for this work are in the following directories. Files for public use are in directory Ipro/oodb/opt/Rep/. This directory should be used as the \"include\" and \"library\" directory in a makefile. This directory includes: • header files OptRepMeta. H. OptRep. H, OptRepCost • H, • OptRepLib. H. • the OptRep library 1 ibOptRep • a; • the working driver program makeRep; and • the data dictionary files. data_diet, • type_diet. attr_diet and • text_diet. • The cost data file .OptRepTypeCostData. All these data files are for the Altair Travel Agency database. All compilation is done in the directory Ipro/oodb/opt/Rep/work/. This includes • .C files OptRepMeta.C, OptRep.C, OptRepCost.C. makeRep.C, eostExp.C, eostTest. C. • Makefile for compilations of makeRep, libOptRep. a, eostExp, eostTest. This directory also includes test output, executables of the driver files and copies of certain altair input files. Files relating to the \"gcl\" rep are in directory Ipro/oodb/opt/Rep/RepLib/. This contains the older version of the library, named 1 ibRep. a, which is now included in libOptRep. a. The header file OptRepIntRep. h, which contains enums for the operators etc. is in this directory, and is included in the .H files. 6.4.2 Makefile The Makefile used is in directory pro/oodb/opt/Rep/work/. Compile options with this Makefile are: With no target -compiles makeRep. make exp -compiles costExp. make lib -compiles the library libOptRep.a make est -compiles costTest. The -DTESTING flag will cause many print statements to be activated. The library option should not be compiled with this flag set. page 26 6 May 1993 RepCost class vlist { public: void *data; struct vlist *next; }; class AnnotList 1* * Generic linked list type to use with annotations. * This has rather more functionality than vlist. * *1 class AnnotList ( private: void *fData; int fDataSize; II to allow arbitrary copying of the AnnotList struct AnnotList *fNext; char *fAnnotName; II the annotation key. public: void *Data() {return fData; } void *getNthVar(int); int getListSize(); II number of elements AnnotList *Next() { return fNext; } char *Name() { return fAnnotName; } AnnotList(); AnnotList(int); II arg is size of the data AnnotList(AnnotList*,int); II 2nd arg is size of the data -AnnotList(); } ; RepCost 6 May 1993 page 27 EREQ Query Representation and Cost Model Header file: OptRep.H Op class Op : public OptRepMetaClass { private: char fName[OP_SYM_LEN]; int fArity; int fNumInputArguments; public: II constructor Op() / Op(char*, int ,int); OP(OP&)/ II destructor -Op() ; public: char *Name() { return fName; } operType OperType()/ int Arity() { return(fArity)/ } int NumInputArguments() { return ( fNumInputArguments ); } int NumOtherArguments() { return ( fArity -fNumInputArguments )/ } int isAttribute(); void PrintOp () ; }; /I class Op page 28 6 May 1993 RepCost char *DataType() void SetDataType(char *dataType) char *Name ( ) void SetName(char *name) void Splice(DataNode *theNewNode); II splice the new Node in for this node This function not yet implemented. Boolean IsMultivalued() int NumValues() The above two functions refer to the \"size\" of a set, if the type of the data is multivalued (ie a SET). Boolean IsLeafNode() Boolean IsLocalVar() II Does this node represent a local variable If the variable is in the avail list, it is a Local Variable. Boolean IsGlobalVar() A DataNode is assumed to be a global variable if it is not a local variable. Boolean BuildQueryPaths(Boolean)\n\nThis function will build the \"path\" and \"cost\" annotations. In the DataNode the PathString's are built.  Argument is the type name.\n\nCalled by any function requiring access to details of a specific Type. Returns a pointer to the specific instance of TypeData.\n\nTypeDataPtr SchemaMgr::getTypeDataErr(char*, char*)\n\nSecond argument is an error message. Functionality as getType DataO above, but prints an additional error message if the type is not found. An instance of the class exists for each type in the data schema. The class contains data on both the type realationships, or structure of the schema (ie superclass(es) and subclass(es)), and cost data. A structure array is provided in the class to store details relating to each attribute.\n\nTypeData::TypeData(USLString) This is the standard constructor for an instance of the DataType class. The argument is a type name. This is called by the function SchemaMgr: : buildTypeMap ( ) .\n\nchar* TypeName ()\n\nReturns the name of this type.\n\nThe following functions return super type and sub type repectively.\n\nTypeData* TypeData::Parent(int) TypeData* TypeData::Child(int)\n\nThe following functions are self explanatory.\n\nint TypeData::NumParents() int TypeData::NumChildren() int TypeData::NumAttributes()\n\nCalled by SchemaMgr::build1)'peMapO.\n\nReads the file of cost data, looks for this type name, and attribute names, and reads in the relevant type cost parameters.\n\nBoolean TypeData::AttrExists(char*)\n\nReturns TRUE if the type has an attribute of the name specified.\n\npage 46 6 May 1993 RepCost Boolean TypeData::AttrExists(char*, int*)\n\nAs above, but returns the index of the attribute in the second argument.\n\nThe following access functions relate to fields of each attribute. The first three fields may only be set from inside an instance of TypeData. char* AttrName(int i) char* AttrType(int i)\n\nReturns the type of the attribute. The type may be \"Set[T]\" or \"T\", depending on whether the type is multi valued.\n\nAttrIsSet(int i) Returns TRUE if this attribute is multivalued. int AttrD(int i) void SetAttrD(int i, int value) int Attrfan(int i) void SetAttrfan(int i, int value) int Attrd(int i) void SetAttrd(int i, int value) int Attrr(int i) void SetAttrr(int i, int value) TypeData: : nc ( ) Returns the number of members of the type hierarchy based at this type, including this type. The following functions are access functions for the cost parameters N (Cardinality) and P (Number of disk pages used by the type). int NO void SetN(int value) { fNij = value; } int PO void SetP(int value) { fPij = value; } void readAttributes(int varFlag=O); II Read the attributes of the type from the \"gel\" data dictionaries. Called by the TypeData constructor, and, for VARIABLE only, called by buildTypeMapO. void checkAttrTypes() Checks to see if the attributes of this type exist in the typeMap. page 47 EREQ Query Representation and Cost Model The following are private functions that get type and attribute infonnation from the \"gel\" data dictionaries using the functions in OptReptable.c void readParent() Reads from the table of types in .type_dict. to find super type(s). If a parent is found in the table, the par ent's functions addChildO and addMemberO are called to add this instance as a sub type of the super type. Called by TypeData constructor. void readChild()\n\nReturns sub types of this type. This is not used, since the sub types are aften not in the table when the con structor is called.\n\nThe following are protected functions:\n\nvoid addChild(TypeData*)\n\nIncrements the field tNumChildren, and adds the calling type to the array of fChildren.\n\nCalled by a sub type of the type.\n\nvoid addMember(TypeData*);\n\nCalled by a sub type (or lower) of the type. See readParentO above.\n\nOnly one instance of this class exists. It is for the meta-type ''Type''. The difference between this type and DataType is that this has a larger array for its sub types.\n\npage 48 6 May 1993 RepCost B.3.3: class PathString : SchemaMgr PathString constructors: Pathstring(char*)\n\nArgument is the name of a variable in the data dictionary. [Note. The constructor needs to be revised to use SchemaMgr functions rather than OptRepTable functions.]\n\nPathString(char*,char*)\n\nArgument 1 is a variable name, argument 2 is the type of the variable. This constructor is used when the variable is a temporary variable declared in the tree. This is, I think, the closest to the Bertino model. Input arguments are the type to be added and the current number of types in this hierarchy, index j. Add the TypeData to the array fAtttfD as the next jth entryand increment the number of types in this hier archy. This is the only place that an addition is made to fAtttfD.\n\nCalled by addAttrIO, addAttrJO. are int i, int j, and int vlaue. The i and j refer to the 2 dimensions of the PathString type array; 1<=i<=n, 1<=j<=nc. void SetD(int,int,int); void SetN(int,int,int); void Setfan(int,int,int); void Setd(int,int,int); void SetP(int,int,int); void Setr(int,int,int); B.3.4: Functions in file OptRepTable.c The following functions from OptRepTable.c are used by the classes in files OptRep and OptRepCost, and were written as part of this project. For descriptions of the API functions provided by gel, see the paper \"Documentation for the Query Tree Interface\". char *getTypeFromset(char*,char*); /* by acm */ Input arguments is type name, possibly as Set[T]. Output argument is type name T. int typeIsSet(char*); /* by acm */ Input arguments is type name, possibly as Set[T] Returns TRUE if Set[T] or List[T]. int typeExists(char*) Argument is type name. Returns TRUE if type exists in .type_dict. int attributeExists(char*,char*) Input arguments are type name, attribute name. Returns TRUE if the attribute exists. char *getAttribute(char*,int,char*,char*) Input arguments are type name and index. Output arguments are attribute name and attribute type. This type may be of the fonn ''T'' or \"Set[T]\". Returns attribute name. char *getAttributeType(char*,char*,char*) Input arguments are type name and attribute name. Output argument is attribute type. Returns attribute type. int objectExists(char*) Argument is a variable name. Returns TRUE if the named variable exists in .data_dict. page 54 6 May 1993 RepCost EREQ Query Representation and Cost Model ehar *getObjeetType(ehar*,ehar*,int) Input argument is a variable name in .data_dict.. Output arguments are type nae and Boolean variable which is TRUE if the type is a set. void readText()\n\nRead a data schema written in a text file and put the data into the data dictionary files •type_diet, .attr_diet and •data_diet. This enables a data schema to be input far more easily than the previ ous method, in which each type, attribute and variable had to entered separately.\n\nThe following three functions all retrieve data from the gel data dictionaries.\n\nehar *getObjeetFromTable(int, ehar*) Input argument is index into the variable table of the data dictionary. Output argument is variable name. (Object refers to a variable). Read the .data_diet and return the indexed entry. The variable name is returned. ehar *getTypeFromTable(int, ehar*) Input argument is index into the type table of the data dictionary. Output argument is type name. Read the .type_diet and return the type field of the indexed entry. The type name is returned. ehar *getSuperTypeFromTable(int, ehar*); ( Input argument is index into the type table of the data dictionary. \\ Output argument is a type name from the super type field of the type dictionary. Read the •type_diet and return supetrype field of the indexed entry. The super type name is returned. (while (not (eq (point) (point-max») (o2-equal-conv-colon) (forward-char) ) ) (save-excursion (replace-string H[H \"(H» (save-excursion (replace-string H]\" H}\"» (save-excursion (replace-regexp \"AND\" \"&H t» (save-excursion (replace-regexp \"IN H \"memberof\" t» (save-excursion (replace-regexp \"=\" \"==\" t» (save-excursion (replace-string \".\" \"@\"» ) (defun beginning-sexp () ~ove point to parenthesis at start of current balanced expression.\" (interactive) (setq open-bl (string-to-char \"(\" » (setq open-b2 (string-to-char \"[\" » (setq open-b3 (string-to-char \"(\" » (while (not (or (char-equal (preceding-char) open-bl) (char-equal (preceding-char) open-b2) (char-equal (preceding-char) open-b3) ) (backward-sexp) ) (forward-char -1) ) (defun o2-equal-conv-lambda () \"Replace lambda (x) with $x\" (interactive) (setq close-b (string-to-char \")\" » (setq comma (string-to-char \",\" » (cond «and « (point) (-(point-max) 7» (string-equal (buffer-substring (point) (+ (point) 7» \"lambda (\" » (delete-char 7) (insert H$H) (while (not (char-equal (char-after (point» close-b» (forward-char) (cond «char-equal (char-after (point» comma) (delete-char 1)\n\n11 in case of >1 variable (insert \"$\"»)\n\n11 replace \",\" with \"$\"\n\n) (delete-char 1)\n\n) )\n\n(defun o2-equal-conv-colon () \"Replace X:x,Word()I with (X,x), (Word(), OR Xlx,Word()I with (X,x), (Word,\" (interactive) (setq colon (string-to-char \"I\" » (cond «char-equal (char-after (point» colon) (setq this-point (point» (backward-wsexp) (insert \"(H) (forward-wsexp) (delete-char 1) (insert \",\") ( forward-wsexp) (delete-char 1) (insert \"),(\") (save-excursion (beginning-sexp) (forward-sexp) (forward-char 1) (insert \")\") (forward-wsexp) (while (not (char-equal (char-after (point» colon» (forward-char) ) (delete-char 1) (insert \",\")\n\n) )\n\n(defun forward-wsexp () \"move forward a word, or if word followed by (, forward to end of ).\" ;; End of o2-equal-conv.el\n\nii- --------------------------------------------------------------------\n\nThe following pages illustrate the experiments carried out using the cost model. A description of these experiments is in the text. See section 4.0 \"Experiments\" on page 16.\n\n( RepCost 6 May 1993 page 57 EREQ Query Representation and Cost Model Cost x leT' Experiment 1.1.1 NIFT 1.10 N'LRT -I + I SOFT ~ 1 / 1.00 I SDRT -I ' / 0.90 l / 0.80 ' __ I I I I I I 0.70 _ I I /V 1 0.60 I I I ' 0.50 V DAD 1 / 1 , ....... I I\n\n]1\n\n..••. '.~'.'.'. 0.20 I ' 1 ~ I I I t 0.10 0.00 -I I I i I I I t -N 0.00 20.00 40.00 60.00 80.00 100.00 # File: \"plotAllOl0l.txt\". # Parameter Cost Cost Cost Cost # N NLFT NLRT SDFT SDRT # 10 110 242 100 329 20 220 252 100 329 30 330 262 100 329 40 440 272 100 329 50 550 282 100 329 60 660 292 100 329 70 770 302 100 329 80 880 312 100 329 90 990 322 100 329 100 1100 332 100 329 , Cost x 103 Experiment 1.1.3 NrFT 1.10\n\n...... \"\"\"\"\"\"\"\"\"\"\"\"\" r-......................... i'o ......................\n\nSOFT 1.00 SORT 0.90 0.80 0.70 0.60 0.50 0040 ( \\, 0.30 0.20 0.10 0.00 D 0.00 50.00 100.00 150.00 200.00 # Pile: NplotAllOl03.txt\". # Parameter Cost Cost Cost Cost # D NLPT NLRT SDPT SDRT # 40 1100 332 100 329 57 1100 332 100 329 74 1100 332 100 329 91 1100 332 100 329 108 1100 332 100 329 125 1100 332 100 329 142 1100 332 100 329 159 1100 332 100 329 176 1100 332 100 329 193 1100 332 100 329 page 60 6 May 1993 RepCost :I~ Cost x lrf Experiment 1.1.4 NCFT 1.10 \"' .................... \"II'''' \"\" \" ... \"\". \" ~ .................... ..................... M..RT SOFT 1.00 'Sm~.T 0.90 0.80 0.70 0.60 0.50 0.40 0.30 0.20 0.10 0.00 d 0.00 20.00 40.00 60.00 80.00 100.00 # Pile: \"plotAllOl04.txt\". # Parameter Cost Cost Cost Cost # d NLP'l' NLR'l' SDP'l' SDR'l' # 20 1100 332 100 329 28 1100 332 100 329 36 1100 332 100 329 44 1100 332 100 329 52 1100 332 100 329 60 1100 332 100 329 68 1100 332 100 329 76 1100 332 100 329 84 1100 332 100 329 92 1100 332 100 329 100 1100 332 100 329 RepCost 6 May 1993 page 61 EREQ Query Representation and Cost Model Cost x 103 Experiment 1.1.5 NI:FT 1.10~ I I \\ I ~m.RT •• , I fp 0.00 .20.00 40.00 60.00 80.00 100.00 # File: \"plotAll0105.txt\". # Parameter Cost Cost Cost Cost # P NLFT NLRT SDFT SDRT # 20 1100 332 20 249 28 1100 332 28 257 36 1100 332 36 265 44 1100 332 44 273 52 1100 332 52 281 60 1100 332 60 289 68 1100 332 68 297 76 1100 332 76 305 84 1100 332 84 313 92 1100 332 92 321 100 1100 332 100 329 page 62 6 May 1993 RepCost EREQ Query Representation and Cost Model Cost x 10 3 ExperiIDent 2.1 NLFT (r=O 20.00 16.00--t------------t----/-------+-------------+-----------+_-14.00--t------------t----JL-------+-------------+-----------+_-12.00 --t--------------l[-Jf---------+-----------+------------I--\n\n10.00 I I 8.00 I \" \" I 6.00 I I 4.00 I \" 2.00 I ' i ' i ' i 0.00 I I d 0.00 50.00 100.00 150.00 200.00 Experi.uent: 2.4 500.00 I I I I I SOFT (r=O 450.00 I ' i 400.00 ( 350.00 300.00 250.00 200.00 150.00 f'7 ~---/ 100.00 50.00 0.00 I SOFT (r=1 SOR.T (r=O ' \" S O R . T (r=l i COS~ d 0.00 50.00 100.00 lSO.OCJ 200.00 Pile name: \"plot0204.txt\". Calculating costs of path: City.places_to~o.address.street. Changing parameter d for type places_to~o. Parameter Cost Cost Cost Cost d NLPT NLRT SDPT SDRT r=O r=l r=O r=l r ..O r=l r ..O r=l\n\n10 3 EREQ Query Representation and Cost Model ExperiIIllen t: 2.5 NLFT (r=D 20.00 I if!,; if;; i i.i; ; i i ; ; ; ; ; ; iii! ;j;:I=-i:iiiii;;;;; j i : : j ;i::: ;~i;iiii:'iii i iii; iii; i;\n\nRepCost6 May 1993 page 7\n\nRepCost6 May 1993 page 15\n\nRepCost6 May 1993 page 41\n\nMay 1993page 43\n\nMay 1993page 59\n\nRepCost"
}