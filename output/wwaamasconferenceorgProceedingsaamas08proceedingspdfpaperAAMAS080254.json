{
    "title": "Protoswarm: A Language for Programming Multi-Robot Systems Using the Amorphous Medium Abstraction (Short Paper)",
    "publication_date": "2004-09",
    "authors": [
        {
            "full_name": "Jonathan Bachrach",
            "firstname": "Jonathan",
            "lastname": "Bachrach",
            "affiliations": []
        },
        {
            "full_name": "James Mclurkin",
            "firstname": "James",
            "lastname": "Mclurkin",
            "affiliations": []
        },
        {
            "full_name": "Anthony Grue",
            "firstname": "Anthony",
            "lastname": "Grue",
            "affiliations": []
        }
    ],
    "abstract": "Multi-robot systems are becoming increasingly prevalent, but programmability is a major barrier to their deployment. Present systems force programmers to think in terms of individual agents. Application code becomes entangled with details of coordination and robustness and often does not compose well or translate to other domains. We offer an alternate approach whereby the programmer controls a single virtual spatial computer which fills the environment space. The computations on this spatial computer are actually performed by a large number of locally-interacting individual agents. This abstracts the actual computational hardware behind the spatial computer interface, and allows the programmer to focus on a single model of global computation. We achieve this abstraction with two components: a language that embodies continuous space and time semantics and a runtime library that implements these semantics approximately. We demonstrate the efficacy of our approach with multi-agent algorithms in both simulation and on a group of 40 robots.",
    "full_text": "Multi-robot applications involve coordinating the movement of robots in space over time. However, programming multi-robot applications requires the user to write software for individual robots and then imagine how these robots will interact to produce the final application. The mapping from robot actions to group actions is often complex and difficult to invert, making programming these systems challenging.\n\nThe dream is that by using a high level language to program a multi-robot application, we would empower a programmer to succinctly implement low-level repair and group functionalities and to quickly compose new programs out of these components. Programs would be developed with a more intentional macro perspective, and modularity would be strongly promoted.\n\nIn this paper, we present a new language, called Protoswarm, that is inspired by the continuous space-time model of Proto and extends this type of model to program swarms of robots. In particular, we present a virtual spatial computer, built out of a continuous Amorphous Medium, which fills the environment space. Programmers develop code for this medium without considering the details of the individual agents. The computations on this spatial computer are actually performed by a population of locally-interacting agents. The agents approximate the virtual computer presented to the user. We achieve this Amorphous Medium Abstraction [1] using two mechanisms: a language, called Protoswarm, which provides continuous space and time semantics, and a runtime library which approximates the semantics on the given hardware.\n\nThere are many domain-specific programming models for spatial computers, Swarm [9], TinyOS [4], and Paintable Computing [3], but they all involve programming the behavior of the devices, rather than the behavior of the aggregate. A notable exception is CMost, the operating system for the CM-5 [11], which allows operations on fields of devices, but assumes a fixed population of devices arranged in a grid.\n\nIn related swarm languages, programmers are similarly forced to program and manage individual robots. Mataric [7] introduced the notion of basis behaviors and group computng, but the basis behaviors are more challenging to combine than in Protoswarm. More recently, works by Klavins [5] and Kloetzer [6] have promoted the idea of high-level descriptors for swarm flocking, and the ability to compile out rules. The high-level is more akin to what we will show. However these systems mainly produce motion control laws on more capable robots -with GPS, and global clocks -where interactions are less critical in determining robot behavior. Furthermore, the languages are focussed on motion, and do not provide Portugal,pp. 1175-1178.\n\nvery expressive means of distributed sensing and distributed state, that one might like to do wth a robot swarm application.\n\nIn contast, sensor networks have focussed almost exclusively on data collection. They have focussed on using wellknown complete languages such as SQL or functional languages, which come with strong guarantees about what can be computed and many algorithmic tools to support the language implementation. For example, the Regiment [10] programming language operates on geometric regions of space, but is targeted towards sensor-network data-gathering and only distributes some operations across space.\n\nOur goal is to combine these two points of view -both sensing and motion control are fundamental parts of programming robot swarms. We would like to take advantage of these types of languages in robot swarms, since many times mobile sensor networks are essentially robot swarms and vice versa. The Proto language is described in [2] and the amorphous medium abstraction was first proposed in [1].\n\nIn this section, we introduce the Protoswarm language, and build up facilities that support high-level modular multiagent programming. In Protoswarm, the computational model is based on manifolds of space that execute code, called the Amorphous Medium. The medium has computational state and physical extent, both of which evolve over time. We assume that the medium is populated by an infinite number of agents, and each agent can only communicate with neighbors within a fixed distance. Programs for continuous regions are then run approximately on a discrete set of agents. Each agent runs identical code but their execution diverges due to differing local state and environment and interactions with neighbors.\n\nProtoswarm programs are written as expressions over fields, where fields are mappings from manifolds to values. Expressions are executed repeatedly, producing streams of fields. Behaviors are produced from vector fields by points in space moving in the direction of the vectors.\n\nProtoswarm is inspired by the programming model of Proto [2]. We treat the world as fields/streams and the computing constructs compute on these streams. Also we treat the system as a spatial computer, so all computing constructs work on neighborhoods without reference to exact neighbors. Unlike Proto however agents can move in space, and this is described by adding movement actuation. Consult [2] for more information on the Proto programming language on which the Protoswarm language is based. Now we describe some constructs one can build in this language to program at the group level.\n\nIn order to build basic behaviors, we assume we have a number of basic spatial and temporal functions that are useful in programming the Amorphous Medium developed in [1]. In particular, we assume functions to measure distance between any point and a given source region (distance-to), to elect a leader (elect-leader), to designate subregions (dilate), and to provide a global clock (time).\n\nIn this section, we build upon our basic spatial and temporal functions to produce simple motion primitives for wandering, clustering, and dispersion. We move regions by defining a vector field over a region and using this vector field to move the points in the region. For example, a random vector field is produced by:\n\nThis produces a tuple at each point in the region that represents a random change in that point's current goal position. Note that this is simply a field; we have not produced any motion yet. We can move each point to its goal position with (mov (brownian)), which produces the desired behavior.\n\nRegions can be clustered into a set of smaller regions by moving each point towards the average of the positions of all neighboring points:\n\nAs this code executes, points near the boundary of the region move towards the center of the region. No attempt is made to keep the region coherent as it clusters. Eventually, the region will contract to a set of points.\n\nConversely, regions can be dispersed by creating virtual springs between points with a resting length of d. The following fragment:\n\nmoves points to minimize the spring energy between neighbors. This eventually results a uniform dispersion [12].\n\nIn order to perform clustering and dispersion directed towards (or away from) a region, we need a way to determine the direction to a region. We can interpret a field of scalars in a region as the z-values of a topographic terrain. We can then compute the gradient at any point in the region by finding directions of maximal increase in height:\n\nThe third line computes a vector towards each neighbor, with magnitude equal to the gradient of the field towards each neighbor. The int-hood operator integrates all the gradient vectors within a local region around each point, called a neighborhood. The neighborhood of a point is the circle of radius comm-range centered at that point. Essentially, this function computes the average gradient vector towards the source from all the points in the neighborhood. Distance-based dispersion and clustering can be defined by moving towards or away from this gradient vector:\n\n(def disperse-from (src) (grad (distance-to src)))\n\n(def cluster-to (src) ( * -1 (grad (distance-to src))))\n\nThe left picture of Figure 1 shows the vector field produced by (cluster-to (is-light)), where the vectors points towards lit regions. Finally, we can follow a contour line in the topography of the field. Our approach is to create another field that has a stable limit cycle along the contour at a given level. We can generate this field by summing vectors pointed both towards and tangential to the desired topographic line:\n\nwhere c is a feedback constant less than one. The following example, produces a vector field causing points to orbit at 0.5 meter around the lit region:\n\n(contour-field (distance-to (is-light)) 0.5)\n\nas shown in the right picture of Figure 1.\n\nIn order to construct more complicated behaviors, we need a method for behavioral composition. The first mechanism spatially composes behaviors. For example, we can create a behavior that makes agents disperse and remain somewhat stationary over certain areas, while wandering everywhere else. The code (mov (cover-light)) creates a dispersal field in lit areas, and a brownian field in other regions:\n\n(def cover-light () (where (is-light) (disperse) (brownian)))\n\nThe second mechanism composes behaviors over time, sequencing behaviors according to events. For example, we can sequence dispersion for 2 seconds followed by wandering for 3 seconds:\n\n(loop (while (wait 2) (disperse)) (while (wait 3) (brownian)))\n\nor wander until coming in contact with an object, then pushing it for 5 seconds:\n\n(loop (while (not (is-near-object)) (brownian)) (while (wait 5) (push-object)))\n\nIn general, we can sequence arbitrary behaviors by introducing the notion of finite streams, which are truncated by some event. The while function creates a stream of fields while the predicate is true. Finite streams are represented as a tuple of value fields and a boolean active field that is true when the stream is active. The loop function transitions from finite stream to stream based on the active field.\n\nThe Protoswarm implementation addresses three separate challenges: (a) how to implement the primitives in a faulttolerant manner in the face of agent movement, (b) how to translate swarm programs onto actual robots in an efficient\n\nNetwork Path Distance vs. Euclidean Distance 0 1 2 3 0 1 2 3 euclidean distance (m) network path distance (m) and portable manner, and (c) how to support program development.\n\nNeighborhood communications and localization are supported by a best-effort communication scheme. The most recent information on neighbor's relative positions and shared variables are stored in a table [3]. Neighborhood operations then access the table, combining the most recent values into an approximate summary value. The virtual machine maintains the table by gathering shared values during each round of execution. These are then transmitted each round while receipt of packets proceeds in the background.\n\nThe simulator permits the running of much larger networks (over 10,000 agents), larger applications, flexible visualization, and friendlier code development and debugging. As in the robot port, only a small amount of platform specific code is necessary. The bulk of the simulator code facilitates visualization, code development, and debugging.\n\nWe implemented Protoswarm on a group of 40 autonomous mobile robots designed by iRobot. Each \"SwarmBot\" is autonomous and is equipped with bump sensors, light sensors, and an infra-red inter-robot communication and localization system [8]. The inter-robot localization system enables each robot to determine the positions of its neighbors relative to its own local coordinate system. The infra-red communication system is used to maintain the neighborhood table.\n\nWe tested elect-leader, distance-to, cluster-to, and dilate on the robots. Data was collected from the robots using a ceiling-mounted vision tracking system that recorded the positions of each robot over time. Telemetry from each robot was recorded to monitor each robot's internal state.\n\nThe distance-to function measures the distance between any point in the medium space and a source region. We ran the following code: (distance-to (elect-leader (id))), which elects a robot to be the source region, and then measures the distance to that robot from all other robots. Figure 2 compares the estimated distance to the source region to the actual distance. The distance estimate is accurate over the entire workspace. Because the paths for messages are constrained to only travel over the communication graph, the distance estimate will be an overestimate of the actual path. The longest path through the network was four communications hops.\n\nThe dilate function uses the distance-to function to defined a region around a source. We tested:\n\n(dilate (elect-leader (id)) 0.8) to produce a region of 0.8 meters around the leader. The picture in Figure 3  0 1000 2000 3000 4000 0 1000 2000 3000 4000 Cluster-To Path Efficiency 0.00 0.20 0.40 0.60 0.80 1.00 0.00 1.00 2.00 3.00 4.00 Euclidian Distance Efficiency Figure 4: Cluster-to results on robots. The lefthand plot shows five paths towards the source the bottom left, and the righthand plot shows the efficiency of these paths, where the efficiency is the ration of shortest possible path length to actual path length.\n\naround the leader robot as it is driven around using radio control. The black line shows the probability of a neighboring robot considering itself part of the dilation region. The transition point is shifted to smaller radii because distance-to is an overestimate of the actual distance. We suspect that the slope of the transition is caused by the voids in the network and the convergence speed of distance-to relative to the speed of the robot. The cluster-to produced a vector field which is used to drive regions towards source regions. We tested the following code:\n\n(mov (mux (elect-leader (-(id)))\n\n(cluster-to (elect-leader (id))) (tup 0 0)))\n\nwhich drives an \"anti-leader\" robot to a leader robot. The left plot in Figure 4 shows five paths from various starting positions. The right plot shows the path efficiency for each of these paths, where path efficiency is the ratio of shortest possible path length to actual path length. In twenty runs, the robot always converged to the source.\n\nIn this paper, we introduce a continuous spatial computer abstraction to programming multi-agent behaviors. Our approach is built upon an Amorphous Medium Abstraction which frees the programmer from needing to consider individual robots. The Protoswarm language uses this abstraction to provide the user with a high-level programming model. We describe several core algorithms written in Protoswarm useful for constructing larger applications. We tested program fragments on 40 to 10000 in simulation and on a physical swarm of 40 robots. In all cases, the programs behaved as expected and the resulting behaviors were robust and scalable.\n\nThe power of our approach is that we can write scalable applications once and deploy them approximately on a number of multi-robot platforms with each platform incurring a certain approximation error. We think it is important to characterize this error, but at this time we are unable to make formal or statistical bounds on it or guarantees on correctness of high level programs. We have been working steadily on this challenge and hope to have results soon.\n\nAlthough the demonstrated examples are limited, the programming model is a promising tool for multi-robot systems. In the future, we hope to expand the list of group level behaviors and applications and deploy the model on a wider range of multi-robot systems."
}