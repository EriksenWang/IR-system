{
    "title": "CONSTRUCTING GOOD QUALITY MOTION GRAPHS FOR REALISTIC HUMAN ANIMATION",
    "publication_date": "2002",
    "authors": [
        {
            "full_name": "Liming Zhao",
            "firstname": "Liming",
            "lastname": "Zhao",
            "affiliations": [
                {
                    "organization": "Catherine Stocker, Benjamin Sunshine-Hill",
                    "address": {
                        "city": "Grace Fong"
                    }
                }
            ]
        }
    ],
    "abstract": "Norman I. Badler. They have been great mentors as well as friends, giving me guidance and suggestions both in my research work and in my life and career development, with sincerity and patience. Without them this thesis would not have been completed or written.\nI am also grateful to all of the members in my thesis committee: Sanjeev Khanna,\nStephen Lane, Maxim Likhachev and Lucas Kovar. Their insights and suggestions from both theoretical and practical points of view helped guide my thesis work to completion.\nThe SIG Center for Computer Graphics, where I conducted my thesis work, is home to a group of talented and friendly people. I would like to thank Jan Allbeck and Amy Calhoun for their technical and spiritual support, Joe Kider for being a sincere friend both inside and outside work, and Erdan Gu, Chris Czyzewicz,",
    "full_text": "Realistic human animation has been an integral part of a diverse range of media such as feature films, movie special effects, computer games and virtual training and simulation systems. However, developing intuitive tools for both professional animators and novice animation users such as children, school teachers and small companies to easily and quickly create realistic human animations remains a difficult task.\n\nOn one hand, the realism of human animation is difficult to achieve. The human body is a complicated structure (on average 206 bones) and has the capability of performing motions ranging from subtle actions like a sigh to dynamic actions like a kick. In addition, humans are experts in detecting any unnaturalness in human motion because they have been observers of human motions throughout their lives.\n\nOn the other hand, the animation tools must be easy to use and fully automatic in generating human animations according to some easy-to-specify user requirements.\n\nMotion capture systems can accurately record the motion details from a live performer. Nowadays, more and more motion capture data is becoming freely available to the public, for example, the CMU MoCap database and the HDM05 database [1,37]. These motion capture databases have the potential to enable novice animation users to quickly synthesize realistic human motion for their animation applications. In particular, motion graphs have emerged as a promising technique for the automatic synthesis of natural human motion [6,24,29,43]. In brief, a motion graph is constructed by representing each pose from the motion capture data as a unique vertex and adding edges between \"similar\" poses (vertices) (Figure 1.1).\n\nThese additional edges bring in transitions which are new to the motion capture data. Once the graph is constructed, the desired motion is generated by searching the graph for a path -an ordered sequence of poses connected by the edges in the graph -that satisfies the high-level description of the motion provided by a user.\n\nMotion graphs provides an simple and automatic approach to motion synthesis using motion capture data. However, two fundamental problems prevent motion graphs from being actively used in practice. First, the quality of the motion generated by a motion graph depends largely on the connectivity of the motion graph and the quality of transitions allowed by the motion graph. Achieving both criteria simultaneously is difficult. Good connectivity requires transitions between less similar poses from different behaviors, while good motion quality results only from transitions between very similar poses from similar behaviors. Second, it is extremely difficult to manually select a good subset of motions from a large motion capture database in order to construct a good quality motion graph. On one hand, we want this subset to be of the smallest possible size to allow for small graph size and fast search for desired motions. On the other hand, the subset needs to contain large enough motion data to have good quality transitions and to satisfy user requirements. In this thesis we propose two approaches to address the two fundamental problems with motion graphs. In the next three sections we outline our approaches and discuss the connection between them.\n\nA number of papers [15,44,47] that use motion graphs for new motion synthesis note that the results depend largely on the quality of the graph. To synthesize good motions, motion graphs require both smooth transitions and good connectivity. A transition is smooth if it does not introduce visual discontinuity to the motion.\n\nVisual discontinuity often comes from transitions between frames with very different postures or very different motion dynamics. Connectivity is a measure of how quickly one can transition from a pose in one behavior to a pose in another behavior. Good connectivity is important for both interactive control applications where the quick transitions allow real-time user control, and for off-line motion synthesis where quick transitions allow the solution animation to accurately and efficiently follow a user sketch without suffering from long intermediate motion segments.\n\nUnfortunately, achieving both good connectivity and smooth transitions at the same time is very difficult. Good connectivity relies on quick transitions between less similar poses from different behaviors. On the other hand, smooth transitions only occur between very similar poses. Reitsma and Pollard [44] did an extensive evaluation of motion graphs for character animation and demonstrated that motion graphs have poor responsiveness to user control. Their study confirms that achieving both good connectivity and smooth transitions is a difficult task. For example, changing from a running motion to an ducking motion in their motion graph took an average of 3.6 seconds. In industry, hand-constructed move trees are often used [13].\n\nThey have better connectivity, but require an extensive amount of manpower and specially trained talents.\n\nIn this thesis, we present an algorithm that automatically constructs an unstructured motion graph with very smooth transitions and much better connectivity than offered by standard motion graphs (Figure 1.2). We call this graph a Well-Connected Motion Graph. To illustrate the main idea, consider two walking motions with different step lengths, M1 and M2 (Figure 1.3). They consist of poses which are similar, but not similar enough to create smooth transitions. If we construct a motion graph from M 1 and M 2 directly, there will be no transitions between them. On the other hand, a set of motions computed by interpolating M 1 and M 2 with different interpolation weights contain many more similar poses. These poses allow for smooth and quick transitions between M 1 and M 2 (Figure 1.4).\n\nOur algorithm first computes a set of interpolated poses that are interpolations of the original poses from the motion data. In particular, the algorithm computes a set\n\nSmall Steps Figure 1.3: Poses from a walk with a large step length (above) and poses from a walk with a small step length (below). There exists similar poses, but they are not similar enough to create smooth transitions.\n\nof plausible new motions via a time-warped, center-of-mass-aligned interpolation of motion segments that share the same contact configuration. These new motions can then be used as the basis for creating a motion graph, the Well-Connected Motion Graph, that achieves both good connectivity and smooth transitions. In creating the Well-Connected Motion Graph, the algorithm uses only a subset of the newly created interpolated poses. The choice of this subset affects the quality and the size of the motion graph. Our algorithm selects this subset in such a way as to: (a) guarantee the physical correctness of the transitions in the motion graph; (b) grow the overall graph size as little as possible while maintaining the best connectivity among the original poses. Moreover, the user can pick an upper bound µ on the amount by which the connectivity is sacrificed to trade for further decrease in graph size. The resulting Well-Connected Motion Graph uses exactly the same representation as a standard motion graph, a well studied data-structure with a variety of applicable motion synthesis algorithms.\n\nExperimental results show that the Well-Connected Motion Graph achieves much better connectivity and generates much smoother motions than standard motion graphs. These results are based on visual analysis as well as the comparison of several metrics, some of which were previously proposed by other researchers. In addition, the motions generated from the Well-Connected Motion Graph require no post-processing, a tedious and often imperfect task of removing visual artifacts such as foot sliding. Finally, the evaluation of the Well-Connected Motion Graph in an interactive character control scenario demonstrates better responsiveness to user control and better visual quality of generated motions than standard motion graphs.\n\nNowadays, large databases of human motion are becoming freely available and their sizes are growing at a fast rate. We believe that as motion capture data accumulates, it will provide dense coverage over the behavior space and will be able to satisfy user requirements for a variety of applications. Therefore, these databases have a high potential to enable novice animation users such as children, school teachers, and small companies to easily and quickly create realistic human motions. To explore this potential, there needs to be fully automatic methods for human motion synthesis.\n\nMotion graphs which embed multiple behaviors into a simple graph structure have The character needs to be able to navigate through rooms inside a building quickly and naturally using behaviors such as walking, running, jumping, ducking and so on.\n\nemerged as a popular data structure that can be used for automatic natural human motion synthesis. However, the performance of a motion graph is limited by the motions that the graph is built from.\n\nCurrent practice for finding the motions to build a motion graph is through manual selection from a large motion capture database. For example, in order to create a good quality motion graph for a virtual SWAT training scenario (Figure 1.5), a user selects a set of walking, running, jumping and ducking motions that are required by the application. These selected motions need to be well-connected to provide quick and smooth transitions. However, it is highly non-trivial to manually select a subset of motions from a large motion capture database to achieve this goal. On one hand, the subset needs to be of the smallest possible size in order to produce a small motion graph for efficient motion synthesis. On the other hand, the subset needs to contain enough motion data to preserve good quality transitions and to satisfy user requirements. As a result, the subset selection requires the user to carefully consider every relevant motion in the database, which is a highly tedious process. Even more importantly, in this process, it is nearly impossible to estimate\n\nUser Selection & Requirements Automatic Sub-graph Construction Database Motion Graph Sub-graph Motion Capture Database Figure 1.6: High level algorithm overview for the Iterative Sub-graph Algorithm.\n\nthe effect of including a particular motion on the well-connectedness of the motion graph before the graph is constructed. Motivated by reducing this burden on novice users, we develop an automatic method for selecting a good but small subset of motions from a large motion capture database that can be used to build a good quality motion graph.\n\nOur method treats the entire motion capture database as a single large motion graph and casts the motion selection problem as a search for a minimum size subgraph from a large graph. Figure 1.6 gives a high level overview of the algorithm.\n\nWe require the user to first select a small set of key motions that are required by his/her application domain. These motions alone usually fail to generate a good motion graph that satisfies all the user requirements, because they lack quick and smooth transitions between them. Our method then automatically finds additional motions in the motion database that result in good connectivity between user selected motions, but at the same time keeps the size of the motion graph as small as possible.\n\nThis step corresponds to a well-defined theoretical problem of finding a minimum size sub-graph from a very large graph. While this problem is NP-hard, we propose an efficient algorithm, called the Iterative Sub-graph Algorithm, that provides a good approximation to the optimal solution.\n\nExperimental results show that the Iterative Sub-graph Algorithm scales well to large motion capture databases and generates small motion graphs that satisfy user requirements. The results of our user study demonstrates that in addition to being fully automatic, the Iterative Sub-graph algorithm outperforms manually constructed motion graphs across all the metrics we have measured: construction time, the size of the generated motion graphs, average transition times in the graphs, and measures of connectivity and user requirements satisfaction. Finally, we demonstrate the performance of our automatically generated sub-graphs in the context of two common applications: the interactive control application and off-line motion synthesis application.\n\nFor novice and experienced users who do not have access to expensive motion capture systems and lack of time or trained skills to use animation techniques employed by the industry, readily available motion capture databases and standard motion graph technique are effective tools for synthesizing realistic human motions for a variety of applications. Each of our methods addresses a fundamental problem with standard motion graphs. These problems prevent standard motion graphs from being actively used in practice by a wide range of animation users. The first method focuses on exploring the interpolated space between a set of user provided motion capture clips for generating a motion graph with both good connectivity and smooth transitions.\n\nIt assumes that the motions for building the motion graphs are given as an input. The second method focuses on searching the entire motion capture database for a minimal subset of motions that will build a motion graph that satisfy user requirements. It assumes that the motion capture database contains a variety of motions and smooth transitions to contain a solution to the user requirements in the first place.\n\nFor some experienced users who possess a decent collection of motions for their applications, the first method helps them to improve the connectivity and motion quality of their motions. They could also use this method to quickly test their motion set and decide if more motion capture is needed for their application. The second method may be used by some novice users to help them select a set of motions needed by their application. It could also be used by experience users to quickly test if their existing databases contain motions that would complete the task or if more motion capture is necessary.\n\nThe second method relies on the assumption that a large motion capture database with good connectivity and smooth transitions is readily available. However, if such a database is not available, we could use our first method to augment the present motion capture database with a minimal set of necessary interpolated poses. The augmented database would offer both good connectivity and smooth transitions, and could then be used as an input to our second method.\n\nThis thesis document is structured as follows. Chapter 2 gives an overview of the related research work. Chapter 3 outlines the steps for constructing motion graphs and elaborate the two fundamental problems that prevent motion graphs from being actively used in practice. Chapter 4 describes the details for constructing the Well-Connected Motion Graph. Chapter 5 describes the details of our Iterative Subgraph Algorithm. Chapter 6 discusses the connection between the two methods and summarizes the contribution of this thesis. Chapter 2 Related Work This chapter gives an overview of the related research work. Section 2.1 gives a high level overview of various approaches to motion synthesis. Section 2.2 focuses on a particular motion synthesize technique -motion graph, and reviews methods that incorporate interpolation techniques to motion graphs. Section 2.3 describes a few systems that are related to the problem of automatic motion selection from motion capture databases. Section 2.4 (reinforcement learning) and Section 2.5 (off-line search) describe two common motion synthesis techniques. We use both techniques from Section 2.4 and Section 2.5 for our experimental analysis.\n\nIn computer animation, a human body is usually treated as a rigid skeleton that drives a deformable skin (Figure 2.1). A motion is specified as the translation values of the root joint of the skeleton and the rotation values of all other joints over time.\n\nResearch work in human animation is generally divided into two categories: dynamic approaches that build an internal physical model to represent the human skeleton and simulate it under the laws of motion, and kinematic approaches that directly manipulate joint translation and rotation values to generate human motions with desired physical effects. Dynamic approaches integrate torques and forces to compute joint angles and velocities to animate a character. Physical realism is guaranteed, but finding the torques and forces that generate a desired animation is difficult. Controller-based dynamic approaches use controllers such as proportional-derivative servos to control the joints during a simulation. A number of approaches have been proposed to allow\n\neasy design of the controller and flexible control to the character, and to improve the visual quality of the generated motion. For example, Hodgins et al. [17] use finite state machines, Laszlo et al. [26] apply limited cycle control to joint controllers, and Yin et al. [61] introduce balance control strategy to the controller design. These systems generate real-time physically correct human motions for a variety of behaviors such as walking, running and jumping behaviors. The character can react to environment changes while maintaining balance. However, the generated motion appear robotic, because no real human motion data such motion capture data is used to aid the design of these controllers. At the same time, physically correct motions are not necessarily natural. Sok et al. [53] solve this problem by first rectifying the motion capture data using optimization so that a controller can track the rectified motion capture motion robustly. Then they use these controllers to build more complex system to simulate a variety of new motions. Their approach achieves much better motion naturalness.\n\nController-based approaches often require a user to specify a large number of control parameters, many of which are unintuitive to the user. As an alternative, the space-time constrained optimization approaches are popular due to their optimal energy solution and intuitive user control in generating physically correct human motions. Given some start and end poses and a physically-based objective function, the optimizer minimizes the objective function and computes the detail of the motion while satisfying posture and physics constraints across all frames. However, for human characters, the system is high dimensional and highly nonlinear, preventing the optimization from converging to a solution quickly. A number of methods have been developed to reduce the optimization space while preserving the importance aspects of the human motion. For example, Popović and Witkin simplify the human body to a reduced set of DOFs that are essential for a given motion task [42]. Safonova and her colleagues compute a low dimensional space of a set of similar behaviors using PCA and optimize new motions in the low dimensional motion space [49]. In addition, Fang et al. [14] proposed a way to enhance the optimization efficiency by considering only constraints and objective functions that lead to linear time first derivatives.\n\nIn contrast to dynamic methods, kinematic approaches animate the character through the directly manipulation of joint angles. Keyframing is a traditional animation method, where key moments of the motion are manually specified and the in-between motions are generated by interpolating the key frames. Keyframing gives artists the ultimate control over every detail of the motion. However, producing a sequence of key frames that yield convincing physics and achieve desired effects consumes a long time and requires special artistic talents.\n\nMotion capture systems use calibrated cameras to triangulate marker positions on a real performer in 3D space. They generate accurate and natural human motions. However, re-mapping the animation to a character of different size or configuration, modifying the animation to satisfy different constraints are difficult. Nevertheless, motion capture data provides an effective basis for synthesizing new motions. A number of approaches have been developed to synthesize new motions from motion capture data and they are generalized as data-driven approaches. Bruderlin and Williams [10] apply signal processing to each DOF of an example motion. Witkin and Popović [59] use displacement mapping to modify an example motion. While these methods provides intuitive and interactive interface for editing motion capture data, they do not adjust the whole body in coordination. Further more, they only focus on kinematic properties. Some other approaches edit motion capture data while preserving physical properties. Abe and his colleagues [4] present a system for rapid editing of highly dynamic motion capture data using optimization. Instead of editing only a few motion capture data, motion graph takes advantage of a relatively larger set of motion capture data to synthesize new motions. It embeds motion capture data into a simple graph structure to allow efficient search for a new motion that satisfies user specifications. Motion graph has emerged as a very promising technique for natural human motion synthesis [6,24,29,43]. We defer the discussion of motion graph related work to next section.\n\nIn general, dynamic approaches automatically generate physically correct motions, relaxing the user from worrying about the interaction details between the character and environment. However, physical correctness does not guarantee motion naturalness, because certain aspects of human motion are not governed by the physical laws, such styles, emotions and intensions. Attempts have been made to handle these subtleties [18,32], but no general solution exists. In addition, most physically-based motion synthesis algorithms are computational expensive. Generating a few seconds long motions usually take several minutes. Keyframing provides the ultimate control over all the motion details. Visual realism and physical correctness are achieved through time consuming manual adjustment and usually requires specially trained talents. Most kinematic approaches leverage the high fidelity motion capture data and are capable of generating life like animations. However, it is often a difficult task to adapt the generated motion to new environments or new skeleton models.\n\nInspired by the technique of Schodl and his colleagues [50] that allowed a long video to be synthesized from a short clip, motion graphs were developed simultaneously promising technique for automatic synthesis of human motion for both interactive control applications [22,25,29,39,40] and for off-line sketch-based motion synthesis [6,7,14,20,24,29,33,47,49,60]. This thesis work presents novel algorithms to generate a standard motion graph with both good connectivity and smooth transitions from user provided motion set, and to search a large motion database for a minimum set of motions that be used to construct a standard motion graph that satisfies user requirements.\n\nThe Interpolated Motion Graph introduced by Safonova and Hodgins [47] is created by combining two identical standard motion graphs. The quality of the Interpolated Motion Graph depends highly on the quality of the standard motion graph.\n\nIf the standard motion graph does not contain quick and smooth transitions between different behaviors, nor will the Interpolated Motion Graph. Our method adds quick and smooth transitions to a standard motion graph (resulting in the Well-Connected Motion Graph). We can improve the quality of the Interpolated Motion Graph by constructing it from the Well-Connected Motion Graph instead of a standard motion graph. Therefore, our method is complementary to the method of the Interpolated Motion Graph [47].\n\nA number of other approaches have been developed over the past few years that combine motion graphs and interpolation techniques [16,25,39,40,51,55].\n\nThese techniques pre-process motions into similar behaviors (for example, walk cycles that all start from the same leg or martial art motion segments with similar rest poses [51]). Similar segments are then grouped together to create interpolation spaces and smooth transitions are created insides these spaces. In such structured, behavior-based graphs, behaviors can only connect at the end of the motion clips.\n\nMoreover, transition blending requires a large amount of motion capture data with good variations for accurate user control [55]. In this thesis work, we also try to find transitions in the interpolated space, however, we do it for standard and unstructured motion graphs. Therefore, our graph can transition from different places inside behaviors. In addition, we construct our motion graphs from a small set of representative motions with a mixture of behaviors.\n\nIkemoto and her colleagues [20] presented another relevant work for creating quick\n\n(1 second long) transitions between all frames in the motion database. They split the motions into short segments (1 second long) and separate them via clustering by similarity. To synthesize a transition from frame i to frame j, they find motion segments that are similar to the motion segments right after frame i and right before frame j. They then search over all possible interpolations of these segments to find the most natural transition from frame i to frame j. To find natural motion segments, they define discriminative classifiers to distinguish natural and unnatural motions. In this thesis work, we also construct a graph that allows for quick transitions between frames, but our construction process is simple, automatic, and very similar to the standard motion graph construction process. We do not require a classifier to distinguish natural motions, just a similarity measure commonly used in standard motion graphs. In addition, the transition lengths are not fixed. They evolve naturally from the dynamics of the motion data.\n\nAn additional difference between the Well-Connected Motion Graph and other variants of motion graphs that were introduced in recent years [16,20,25,39,51],\n\nis that the Well-Connected Motion Graph uses exactly the same representation as a standard motion graph. A standard motion graph is a well studied data-structure with a widespread support from many existing motion synthesis algorithms.\n\nMotion blending techniques [39,40,45,59] are often used to produce smooth transitions between two different behaviors, for example transitions from walking to running. However, it is often chosen empirically which motions to blend, how to align the motions in time, how long the blending window should be and how the blending weights should be set in order to produce natural transitions. Our Well-Connected Motion Graph frees the user from worrying about these settings. First, only motion segments which result in physically correct motion [46] are interpolated, and they are interpolated with many different weights. This creates a large pool of interpolated poses. Second, during the graph construction, transitions are created only between poses with similar motion dynamics, even if they are of different behaviors. The entire process is therefore simple and automatic.\n\nStructured motion graphs, which are often called move trees [27,34,36] are a variant of the standard motion graph. They are commonly used in game studios.\n\nMove trees also use graph structure and motion capture data to generate new motions, but they differ from motion graphs in the following ways. To construct a move tree, game designers often first design a finite state machine to represent all the behaviors required by the game and all logically allowed transitions between the behaviors. Then, they capture the motions according to the pre-planned finite state machine so that initial motions have similar start and end postures for looping. Next, they hand edit the motion capture clips and choose the exact place in the motions for good transitions to appear according to the finite state machine.\n\nSometime, these transitions are motion captured, but most often, they are generated online by blending the two transition motion clips. Finally, the captured motions and the finite state machine are packaged together for a game engine that will play the desired motion and transitions according to user control inputs. With the careful design of the finite state machine to allow for all possible transitions needed for the game, and the extensive amount of manual work required to optimize the captured motion clips, move trees are capable of producing motions with controlled motion quality and transition time, making them well-suited for real-time games. However, the manpower and the resources for such intensive manual design and editing are not available to the majority of animation users. Our main goal is to allow users who do not have access to these resources to create controllers easily by utilizing the large amount of motion capture data that are freely available today.\n\nTo our knowledge, little work has been done so far to develop an automatic method for selecting a minimum subset of motions from a large motion capture database to construct a good quality motion graph that satisfies user requirements.\n\nManual selection of motions for a specific task is difficult. Cooper and his colleagues solve this problem using an active learning method. Their system automatically identifies specific tasks that a motion controller performs poorly and advises a user to capture more motions to improve the performance of the controller [12] or automatically synthesizes new motion segments. As mentioned in their paper, the system does not make formal guarantees on being able to perform every task from every start state. Unlike their approach, our approach is targeted towards constructing a motion graph that guarantees to satisfy user requirements on the transitions in the graph. Also, once the user selects a few short motion segments that are required by the application, our approach minimizes the number of additional motions that are required to construct a good quality motion graph in a fully automatic manner without requiring any user intervention.\n\nA large motion database contains a rich variety of behaviors. It presents an effective basis for synthesizing new motions. However, without appropriate tools it is difficult to fully exploit this fact. Kovar and Gleicher [23] propose a method to automatically extract logically similar motion segments in a large database and use them to construct parameterized interpolation space. Later, high-quality motions are created for new parameter values inside the interpolation space. While this method works well for generating motions of a particular behavior, it does not scale to multiple distinct behaviors.Beaudoin and his colleagues [8] use a string-based clustering method to automatically organize a large motion capture database into a compact and understandable graph structure. However, the compact graph is not structured in a way that fits best to a specific user task. In addition, neither of the two approaches produces a set of motions that guarantees to satisfy user requirements.\n\nOur algorithm automatically selects motions from a large motion capture database to construct small-sized standard motion graphs. We deliberately design the algorithm to generate standard motion graphs because standard motion graphs have a simple graph structure and multiple algorithms have already been developed to use these graphs for both interactive control [22,29] and off-line motion synthesis applications [6,7,14,29,33,47]. An interesting next step would be to generalize our automatic motion selection idea to other variations of motion graphs that have been proposed over the past few years [16,25,39,40,51,55]. Our goal is to create a small-sized motion graph that satisfy user requirements.\n\nA typical requirement is quick transitions between different behaviors. Zhao and Safonova [64] propose a method to construct a small standard motion graph from a set of given motions to achieve both good connectivity and smooth transitions.\n\nIkemoto and her colleagues [20] propose another relevant work for creating quick transitions between all frames using clustering and classification techniques. Both algorithms start from a given set of motions and therefore do not solve the automatic motion selection problem. This problem is NP-hard and several heuristic algorithms have been developed to solve it sub-optimally [5,11,52,56]. Unfortunately, most known approaches are computationally expensive with time complexity ranging from O(kV 2 ) to O(V 3 ),\n\nwhere k is the terminal size and V is the vertex size. They work sufficiently fast in their application domains such as multi-cast routing problems, where V is from 50 to 100 and k is about 50. However, given the large scale of our problem, where the number of frames (V ) in a motion capture database is larger than 80,000 and is going to grow even bigger, and the number of user selected frames (k) is about 500, these existing algorithms fail to find a solution in a reasonable time. However, two heuristics commonly used by these algorithms are important to improve the optimality of the sub-graph solution. First, it is important to connect the root vertex to the terminal vertices in an order that early connections benefit many later connections. In other words, the algorithm should avoid greediness. Second it is important to identify good branch vertices. These branch vertices connect to multiple terminal vertices. Paths between the branch vertices are heavily shared by multiple root-terminal vertex pairs. Therefore, the branch vertices are the key to minimizing the total tree cost. Inspired by these heuristics, we present an efficient iterative algorithm that scales to large graphs with complexity of O(k 2 • E), where E is the edge size of the graph.\n\nA number of on-line methods that use variants of motion graphs together with reinforcement learning [9,38] have been recently proposed. Lee and Lee [30]  tions are required to create high-fidelity character controllers. This permits complex user navigation and obstacle-avoidance tasks. We use the reinforcement learning techniques presented in the above papers to evaluate the performance of the motion graphs for on-line interactive control applications.\n\nIn contrast to the on-line motion synthesis, where user inputs are provided at realtime, an off-line motion synthesis takes a set of predefined user requirements and searches a motion graph for a motion that satisfies the requirements using global search techniques. A number of sub-optimal search algorithms have been developed\n\nto generate motions at interactive frame rate. Kovar and his colleagues [24] employ a branch and bound algorithm to drive a character to follow a sketched path. Arikan and his colleagues [7] user dynamic programming to search a motion based on userspecified annotations of the motion. To find an optimal solution at interactive frame rates, Lau and Kuffner [27] manually created a small structured motion graph that represents the required behaviors and transitions between them. Optimal search can be performed efficiently on this small graph. We use A* search, and in particular its anytime extension ARA* [31] to search for a desired motion. A* is a well-known and well-studied search algorithm for finding an optimal solution efficiently, especially when given a good heuristic function [41]. Safonova and Hodgins use this technique to search for an optimal motion both in a standard motion graph and in an Interpolated\n\nMotion Graph [47,48]. The resulting motions navigate virtual characters in complex environments using desired behaviors without colliding into obstacles.\n\nChapter 3\n\nMotion capture systems accurately record human motion from a live performer. A motion clip consists of a sequence of postures sampled at a fixed frame rate. By itself, a motion clip only contains a limited number of behaviors captured for a finite duration. However, a collection of motion clips together presents an opportunity to produce a longer motion with a mixture of behaviors by connecting similar postures from different motion clips. This longer motion was never intentionally captured.\n\nMotion graphs automate the process of generating new sequences of motions of arbitrary length from a finite set of example motions. In this chapter, we review the construction process of motion graphs and point out two fundamental problems with motion graphs that prevent them from being actively used in practice.\n\nA standard motion graph is constructed from a set of user selected motion capture clips. These motion clips cover all the behaviors needed by the application. For example, in order to construct a motion graph for a navigation application, a user may select a few walking and running motions with different turning directions, some jumping, stepping over and ducking motions for avoiding obstacles. Each pose in these motion clips represents a unique graph vertex and \"similar\" poses (vertices) are connected by a directed edge to represent a smooth transition. Once the graph is constructed, the desired motion is generated by searching the graph for a path -an ordered sequence of poses connected by the edges in the graph -that satisfies the high-level description of the motion provided by the user, for example navigating the character without colliding into any obstacles in the environment.\n\nSection 3.1 explains how to identify \"similar\" poses. Section 3.2 describes the motion graph construction process. Section 3.3 discusses the two fundamental problems with motion graphs that prevent them from being actively used in practice.\n\nFirst, one needs to define a metric for identifying \"similar\" poses. We represent the similarity metric by a distance function D(P i , P j ), where P i and P j are two poses and the smaller the value is, the more similar they are. A good distance function should take into account both the static posture difference and the motion dynamics difference. A number of implementations of the distance function have been proposed.\n\nFor example, Lee and his colleagues [29] compute the distance function as\n\nwhere d(p i , p j ) measures the weighted differences of the joint angles of P i and P j , and d(v i , v j ) measures the weighted differences of the joint velocities of P i and P j .\n\nWe adopt the point cloud metric proposed by Kovar and his colleagues [24]. For every posture, they first extract a neighborhood of 2L + 1 frames centered at that frame. They then compute the global positions of a set of marker positions for each of the 2L + 1 frames. These marker positions capture the position and orientation of the body posture as well as the motion dynamics around the posture. the vertical axis:\n\nwhere p k i and p k i denote the k th marker position for the point cloud associated with P i and P j respectively, and T θ,x 0 ,z 0 is a rigid transformation composed of a translation of (x 0 , z 0 ) on the ground plane and a rotation around the vertical axis of θ degrees.\n\nWe use a Gaussian function to weight the frames around the center frame and we use weights from Wang and Bodenheimer's work [58] for weighting the markers in each frame.\n\nIn order to construct a motion graph, a user first selects a set of motions needed by his/her application. Each frame is represented by a unique vertex in the motion graph and a directed edge exists between two vertices (frames) if one can transition to the other smoothly. Naturally, we have the edges between sequential vertices (frames) from the same motion capture clip. In order to find more transitions, we compute the similarity between any two vertices using the point cloud method mentioned above. The user needs to pick a similarity threshold value to decide the naturalness of a transition. If the similarity value between vertex i and and vertex j is smaller than this threshold value, we consider them to be \"similar\" enough to create smooth transitions. As a result, we create two edges, one from vertex i to vertex j + 1 and the other from vertex j to vertex i + 1, where vertex i + 1 and vertex j + 1 are the successors of vertex i and vertex j respectively in their own motion clips. The cost for both edges is called the transition cost t and is computed as:\n\nwhere s is the similarity value between frame i and frame j. This particular mapping function is an arbitrary choice. One may pick his/her favorite function to reflect the similarity difference. The range of t is [0, 1], with 0 being the smoothest transition and 1 being the most discontinuous transition. This edge creation process can be viewed as filling the entries at row i and column j + 1 and at row j and column i + 1 of a transition matrix with the transition cost we just computed. After computing the similarity between all pairs of vertices, we obtained a sparse transition matrix Poses from a walk with a large step length (above) and poses from a walk with a small step length (below). There exists similar poses, but they are not similar enough to create smooth transitions.\n\nMotion graphs are popular among animation researchers and novice users because of their simple graph structure, ability to generate long motions, and fully automatic solution to motion synthesis problems. However, two fundamental problems prevent motion graphs from being actively used in practice.\n\nFirst, the quality of the motion generated by motion graphs depends largely on the connectivity of the graph and the quality of its transitions. One major challenge in creating a good motion graph is picking a threshold value that would result in both smooth transitions and good connectivity between different behaviors. Usually a low threshold results in very few transitions, most of which occur within the same behavior, but not across behaviors. A high threshold, on the other hand, produces better graph connectivity as it allows transitions between different behaviors, but often introduces poor quality transitions. Therefore users often face the dilemma of choosing an appropriate similarity threshold value for their motion graphs. In the example of two walking motions M1 and M2 with different step lengths (Figure 3.3), a motion graph generated from a low similarity threshold contains few smooth transitions inside M1 and M2, but not across two motions. On the other hand, given a high similarity threshold, the motion graph contains many more transition between the two motions, but they often introduces motion discontinuity, as frames with very different motion dynamics are allowed to connect to each other. It becomes even more difficult, to choose one fixed similarity threshold, to produce both smooth and quick transitions, between a large variety of behaviors, with very different motion dynamics, for example from a motion database with walking, turning, running, jumping and ducking motions.\n\nSecond, it is extremely difficult to manually select a good subset of motions for constructing a good quality motion graph from a motion capture database. Current practice for choosing this subset is through manual selection, which is often tedious and imperfect. On one hand, the subset needs to be of the smallest possible size in order to produce a small motion graph for efficient motion synthesis. On the other hand, the subset needs to contain enough motion data to preserve good quality transitions and to satisfy user requirements. For example, in a virtual SWAT training scenario, a motion graph generated from this subset needs to contain motions that allow the character to quickly navigate through rooms inside a building (Figure 3.4). This means that the motion graph needs to contain a large variety of behaviors including walking, running, jumping and ducking behaviors. In addition, these behaviors need to be well-connected in order for the character to transition from one behavior to another quickly. These conditions contradict the requirement that the subset is small. Given a large motion database, it is highly tedious to go through every motion in a large motion database and manually decide whether to select it. In addition, it is nearly impossible to estimate the benefit of including a particular motion on the well-connectedness of the graph before the graph is constructed, because the final performance of the motion graph depends on a complex process of graph search algorithms.\n\nChapter 4\n\nThe quality of a motion graph determines the quality of the motions it synthesizes.\n\nTo synthesize good quality motions, motion graphs require both smooth transitions and good connectivity. A transition is smooth if it does not introduce visual discontinuity to the motion. Connectivity is a measure of how quickly one can transition from a pose in one behavior to a pose in another behavior. Good connectivity is important for both interactive control applications where the quick transitions provide real-time user control, and for off-line motion synthesis where the generated motion can follow a user sketch without suffering from long intermediate motion segments. Unfortunately, it is often difficult to achieve both good connectivity and smooth transitions at the same time. Good connectivity relies on quick transitions between different behaviors. Therefore, it requires transitions between less similar poses. Smooth transitions only occur between very similar poses. Reitsma and Pollard [44] did an extensive evaluation of motion graphs for character animation and demonstrated that motion graphs have poor responsiveness to user control. Their study confirms that it is difficult to achieve both good connectivity and smooth transitions. For example, changing from a running motion to an ducking motion in their motion graph took an average of 3.6 seconds. In industry, hand-constructed move trees are often used [13]. They have better connectivity, but require an extensive amount of manpower and specially trained talents.\n\nIn this chapter, we present an algorithm that automatically constructs an unstructured motion graph with very smooth transitions and much better connectivity than offered by standard motion graphs. We call the resulting graph a well-connect motion graph, graph wcMG for short. To illustrate the main idea, consider two motions M 1 and M 2 , with different step lengths. They consist of poses which are similar, but not similar enough to create smooth transitions. If we construct a motion graph from M 1 and M 2 , there will be no transitions between them. On the other hand, a set of motions computed by interpolating M 1 and M 2 with different weights contain many more similar poses. These poses allow for smooth transitions between M 1 and M 2 .\n\nIn general, our algorithm first computes a set of interpolated poses that are Our experimental results show that graph wcMG achieves much better connectivity and generates much smoother motions than standard motion graphs. These results are based on visual perceptions as well as computing several metrics, some of which were previously proposed by other researchers. In addition, the motions generated from graph wcMG require no post-processing, a tedious and often imperfect task of removing visual artifacts such as foot sliding. Finally, the evaluation of graph wcMG in an interactive character control scenario demonstrates better responsiveness to user control and better visual quality of generated motions than standard motion graphs.\n\nThis chapter is organized as follows: In Section 4.1, we first describe the construction process for our well-connected motion graph. Then in Section 4.1.4, we extend our algorithm to allow for trade-offs between degree of connectivity and graph size.\n\nIn section 4.2, we compare our graph wcMG against a standard motion graph across a number of measures, some of which were previously proposed by other researchers.\n\nOur graph wcMG outperforms a standard motion graph in terms of both graph connectivity and transition smoothness. In Section 4.3, we show the applicability of our graph wcMG to interactive control applications. Finally, in Section 4.4, we discuss the contribution and limitation of our wcMG.\n\nThe construction of graph wcMG is divided into three steps: the interpolation step, the transition creation step, and the node reduction step. The remainder of this section explains each of these steps.\n\nGiven a motion data set, we first separate the motions into motion segments with the same contact with the environment (for example, double support, or single right leg support or hand contact during picking and so on). We use the technique from\n\nLee and his colleagues [29] to identify the contacts and then verify them by a visual inspection (only a very small percentage of the contacts need to be adjusted by hand for locomotion and other simple behaviors). Contact information could also be computed using one of the other published techniques [19,28].\n\nThe interpolation technique described by Safonova and Hodgins [46] is then used to interpolate all pairs of motion segments with the same contact. For every pair of motion segments with the same contact, we interpolate them using interpolation weights from 0.1 to 0.9 with a 0.1 increment. During flight phase, we interpolate the center of mass positions and then compute the root positions based on the interpolated posture. During ground contact phase, we interpolate the positions of the feet, the center of mass positions and all non-redundant degrees of freedom to prevent the feet from sliding on the ground. The timing of each phase is computed\n\nwhere T 1 and T 2 are the timing of the two input motion segments. Details are explained in their paper [46]. This interpolation technique produces close to physically correct motions.\n\nWe denote the frames in the motion segments from the original motion capture clips as original nodes and those from the interpolated segments as interpolated nodes. The original nodes, the interpolated nodes, and the transitions between consecutive nodes (frames) in the original and the interpolated motions are all added to graph wcMG(Figure 4.1a).\n\nAt this stage, graph wcMG contains only transitions between consecutive nodes (frames) in the original and the interpolated motions (Figure 4.1a). We now add new edges to the graph using the same process used for constructing standard motion graphs (Figure 4.1b). The only difference is that graph wcMG now contains both the original and the interpolated nodes and transitions in between.\n\nOur experimental analysis shows that a large number of smooth transitions can be added to graph wcMG with the help of the interpolated nodes. The interpolated nodes provide connections between poses that are similar, but not similar enough to create smooth transitions, such as poses from walks with different step lengths.\n\nThe interpolated nodes also provide transitions between different behaviors even if such transitions are not explicitly captured. For example, a transition from jumping to ducking is possible, because the landing steps from jumping and the steps that lead to ducking can be interpolated, even when no such motion capture data exists.\n\nTherefore, it is possible to choose a very low threshold for a variety of behaviors to create a graph with very good connectivity. Section 4.2 gives a detailed analysis of the connectivity and threshold choices for graph wcMG.\n\nTheoretically, the number of nodes in graph wcMG equals to N = n × n × d, where n is the number of frames in the motion database and d is the number of discretized interpolation weights used. The number of nodes and edges thus grow quadratically with the size of the original data set. However, assuming that the choice of the initial data set reflects the user's application needs, we can remove all nodes and edges from the graph that are not necessary for connecting the original nodes.\n\nTherefore, in this step we compute a subset of nodes and edges, V and E respectively, that connect the original nodes best. The measure of best connectivity can be application based. For example, if quick responsiveness is the goal, we look for the shortest transitions; if motion quality is the goal, we look for the smoothest transitions. In our implementation, we used a weighted average of length and smoothness of the transitions.\n\nThe algorithm proceeds as follows: for each of the original nodes, we compute the best transitions from this node to all other original nodes. This is done by setting the edge cost according to the metric described above and running a Dijkstra's single source shortest paths algorithm from this node. The shortest path search returns a shortest path tree rooted at the selected original node that contains all the shortest paths to all other original nodes. We repeat the computation of the shortest path tree for every original node. We then take a union of all the generated shortest path trees to produce a reduced graph wcMG (Figure 4.1c). The union can also be taken incrementally -after each computation of a shortest path tree. This allows us to keep memory requirements limited by discarding all the generated trees and maintaining only a single union tree. The reduced graph wcMG, therefore, contains the same connectivity between the original nodes as the original wcMG because it contains all the nodes and edges from the original graph wcMG that are necessary to preserve the best transitions between the original nodes. At the same time, the number of nodes and edges in the reduced graph wcMG is much smaller than in graph wcMG before the node reduction step. In Section 4.2.6 we show that the reduced graph wcMG shows a much more tractable graph size increase with respect to the data set size increase.\n\nCertain applications (such as games) may require graphs that are even smaller in size than the reduced graph wcMG we computed in the previous section. In this section, we extend our algorithm to allow a user to further decrease the size of graph wcMG at the expense of the transition quality between the original nodes.\n\nWe denote the motion graph generated in the previous section as the optimal graph wcMG, because it includes nodes and edges that belong to the optimal paths between the original nodes. We now introduce a sub-optimality scalar µ (µ ≥ 1) that allows us to compute suboptimal graphs with significantly fewer nodes and edge at the expense of the optimality of paths between the original nodes.\n\nWe construct the sub-optimal graph wcMG s (V, E) in an iterative way. Intuitively, each iteration adds nodes and vertices to the graph that connect several of the original nodes. In doing so, it connects these nodes via the \"best\" paths possible while also trying to reuse as many as possible the nodes and vertices that are already in the graph.\n\nThe algorithm proceeds as follows: first, V is initialized to include only the original nodes and E contains the edges between the original nodes. Then, we iterate through every original node and compute the Dijsktra's shortest path tree rooted at this original node. The tree contains the shortest paths from this original node to all other original nodes. To facilitate the reuse of nodes that are already in the graph V , before each shortest path computation, the cost c of each edge e is updated based on the elements in V as follows:\n\nwhere target(e) is the target node of an edge e and t is the base cost of the edge as described before. This penalizes any edge whose target node is outside of the set quality than the paths that go outside of V . As a result, the size of sub-optimal graph wcMG s decreases as µ increases (Figure 4. 2b and c). This process does not affect the reachability between the original nodes, but will reduce the quality of transitions (smoothness and responsiveness) since paths outside of V are penalized by µ times, even if they are of smaller transition cost or shorter length. Note, that even longer transitions are still natural-looking with no visible discontinuities because the graph is always constructed at the same low similarity threshold, independently of its suboptimality. Section 4.2.7 gives a detailed analysis on the sub-optimality trade-off and shows that the size of the graph decreases drastically as µ increases.\n\nIn this section, we analyze the performance of graph wcMG. Table 4.1 shows the motion data sets we used in our analysis. All data is re-sampled to 30 frames per second.\n\nDataset1 contains walking motions from one person with different step lengths, ranging from small steps to exaggerated large strides. Dataset2 contains walking motions from four different people with approximately the same step length. We chose these two data sets, because generating well connected motion graphs between different styles and for different people is known to be difficult. Dataset3 contains a large set of motions commonly used to construct motion graphs for interactive control applications and for off-line motion synthesis applications. Each motion in the data set contains a series of different behaviors and natural transitions between the behaviors. For example, in a single capture, the actor walks, jumps, walks again, ducks and so on. Even though each motion contains natural transitions between behaviors, the standard motion graph computed from this database has poor connectivity. Our graph wcMG on the other hand, achieves much better connectivity.\n\nDataset4 consists of a single long motion sequence in which the subject used the right hand to sequentially reach 15 evenly distributed locations with varying heights and orientations. This data set demonstrates the capability of our system in handling non-locomotion behaviors. As we discuss in Section 4.4, our current interpolation scheme can only handle non-locomotion behaviors with clear contact separations.\n\nDataset5 contains three martial art motions including punching and kicking. These Table 4.1: Data Set Description the motions computed using graph wcMG are very smooth and natural-looking. In Sections 4.2.3, 4.2.4, 4.2.5 we analyze the connectivity of graph wcMG and compare it with the standard motion graph (MG). As most motion graph construction algorithms go through the process of computing the largest strongly connected component (SCC), in Sections 4.2.3, we compare the size of the largest SCC for both graphs, MG and wcMG, at varying threshold values. In Sections 4.2.4 and 4.2.5, we analyze and compare the responsiveness of graph MG and graph wcMG to interactive user input by computing the local maneuverability measure. This measure is proposed by Reitsma and Pollard [44] to measure the average transition time between different behaviors in the motion graph. In Section 4.2.6, we analyze the size of graph wcMG and in Section 4.2.7 we show that one can decrease the size of graph wcMG at the cost of its responsiveness. The time is sampled from an Xeon 3GHz computer with 4GB memory. For the rest  of the data sets, we only constructed the optimal graphs. The computation time ranges from 3 seconds to 18 minutes. As for comparison, all the standard motion graphs took less than 1 second to construct. This animation [63] illustrates the good motion quality achieved using our algorithm. The resulting motion is natural-looking.\n\nWe generated a variety of motions using graph wcMG to visually evaluate its motion quality. We generated these motions by computing the best paths between user selected poses in a specified order. The best metric is defined as in Section 4.1.3. The resulting animations are natural-looking [63]. Figure 4.3 shows smooth transitions between poses from four different behaviors (walking, running, jumping and ducking). Figure 4.4 shows smooth transitions between a pose from a walk with a small step length and a pose from a walk with a large step length. This experiment was done solely to show the visual quality of the motion. We do not claim this to be a key application. In Section 4.\n\n3 we demonstrate the applicability of graph wcMG to interactive control applications by generating natural motions in real-time according to user input. Data1 Data2 Data3 Data4 Data5 Thre wcMG MG wcMG MG wcMG MG wcMG MG wcMG MG 0.2 42% 1% 84% 21% 96% 7% 99% 0% 90% 12% 0.4 70% 19% 91% 21% 98% 10% 99% 26% 99% 44% 0.6 77% 24% 94% 21% 99% 64% 99% 57% 100% 46% 0.8 81% 40% 95% 21% 99% 86% 99% 70% 100% 50% 1 84% 59% 96% 21% 99% 92% 99% 99% 100% 50% 2 91% 64% 96% 81% 99% 99% 100% 53% 5 92% 80% 97% 92% 99% 99% 100% 100% 6 96% 92% 98% 92% 99% 99% 100% 100%    indicated by the clustered off diagonal white areas in Figure 4.6h. Dataset4 contains only one clip, therefore, every frame is able to transition to its sequential frames. As a result, the transitive closure matrix of graph MG is fully white in the upper right corner in Figure 4.6i. However, graph MG is not able to find enough transitions to make every frame reachable to all other frames. As a result, the transitive closure matrix is almost fully black in the lower left corner in Figure 4.6i. Graph wcGM on the other hand, easily achieves full connectivity between all frames. As a result, the transitive closure matrix is all white in Figure 4.6d. Dataset5 contains three martial art motions including punching and kicking. These motions are a mixture of locomotion and non-locomotion behaviors. Graph MG fails to explore transitions between different behaviors as Figure 4.6j only contains blocked white areas within the same motion. Graph wcMG on the other hand is able to create transitions between all the behaviors as Figure 4.6e is almost all white. In conclusion, graph wcMG offers better data set utilization at low similarity thresholds and is capable of handling different types of behaviors.\n\nIn this section, we compute the average transition time between all pairs of the original nodes. This measure provides insight into how quickly it is possible to transition between different poses in the data set. Quick average transition time is important for both interactive user control and off-line motion synthesis.\n\nWe present results at different similarity thresholds for Dataset3, and similar results are achieved for all other four data sets. For graph wcMG, we vary the threshold from 0.2 to 0.8. For graph MG, we vary the threshold from 0.8 to 1.4, because below the 0.8 threshold, not every behavior present in the data set is connected to every other behavior.\n\nTable 4.3 shows the comparison between graph wcMG and graph MG. The Thre column shows different threshold values, the FFTime column shows the average frame to frame transition time in seconds. Figure 4.7 shows the wcMG Thre FFTime 0.2 1.71 0.4 1.27 0.6 1.12 0.8 1.04 MG Thre FFTime 0.8 2.68 1.0 2.05 1.2 1.79 1.4 1.66 Table 4.3: Average Frame to Frame Transition Time in Seconds transition time histogram for each graph wcMG and graph MG. Transition time decreases monotonically as the similarity threshold increases, because lower quality transitions become possible to connect different behaviors. Graph wcMG consistently offers quicker average transition time and better transition time distribution than graph MG. For example, graph wcMG obtains a better average transition time and a narrower spread of its distribution at the 0.2 threshold than graph MG at the 1.2 threshold (a 6 times increase in threshold value). Figure 4.7 also allows us to compare distributions for graph MG and wcMG at the same threshold -0.8. Graph wcMG shows considerably better distribution -much narrower spread and much higher peak at a smaller transition time. Table 4.4 shows the behavior to behavior average transition time for both graphs wcMG and MG at the 0.8 similarity threshold. We used threshold of 0.8 for the comparison because at the lower threshold graph MG does not have good connectivitynot every behavior present in the data set is connected to every other behavior. Each entry is the average transition time in seconds from all the original frames belonging to the behavior in row to all the original frames belonging to the behavior in column. The table is not symmetric, because the motion capture data does not contain transitions in symmetric directions. Graph wcMG introduces interpolated poses and transitions to help find extra connections, and therefore, outperforms graph MG in all cases. Table 4.3. The X-axis is the transition time in seconds and Y-axis is the number of transitions of a particular transition time in the graph. The peak of histogram roughly represents the average transition time. Usually a graph with good responsiveness shows a histogram with its peak at a smaller transition time value and a narrower spread. Note, graphs MG and wcMG have the same overall number of transitions because only transitions between all pairs of the original nodes are considered.\n\nAn alternative way to measure the graph connectivity is the local maneuverability measurement (LM) proposed by Reitsma and Pollard [44]. Instead of computing the transition time between any two frames, Reitsma and Pollard compute the average minimum time needed to transition to a particular behavior:\n\nwhere C is the set of all the motion segments in the motion graph, MDMP C c,k is the minimum time to transition from the end of motion segment c to any instance of behavior k, and D c is the motion segment length. In our experiment, we compute an average of local maneuverability measurement over all behaviors:\n\nwcMG idle walk turn jump run duck pick idle 0.00 0.70 0.67 1. 33  where K is all the behaviors in the motion graph. Table 4.5 shows the LM measure change with respect to the similarity threshold change for both graphs MG and wcMG on Dataset3. The Thre column shows different threshold values, the LM column shows the local maneuverability measure in seconds according to the above equations.\n\nFor both graphs MG and wcMG, as the threshold increases, the LM measure decreases (Reitsma and Pollard [44] obtained similar results). Even at a very low similarity threshold (0.2), graph wcMG is able to produce an LM value as low as 1.21 seconds. We could not compute the LM value for graph MG at the same threshold, because the behaviors are not fully connected to each other. At the 0.8 similarity threshold, graph wcMG has an LM value of 0.73 seconds which is 2 times smaller than the LM value (1.55 seconds) for graph MG at the same threshold.\n\nTo achieve wcMG Thre LM 0.2 1.21 0.4 0.91 0.6 0.80 0.8 0.73 MG Thre LM 0.8 1.55 1.0 1.18 1.2 1.00 1.4 0.90 Table 4.5: Local Maneuverability  4.5. The X-axis is the LM measure in seconds and Y-axis is the number of behavior pairs with a particular LM value. The peak of histogram roughly represents the average LM value. Usually a graph with good responsiveness shows a histogram with its peak at a smaller LM value and a narrower spread.\n\nthe same LM value (1.21 seconds) that graph wcMG obtains at the 0.2 similarity threshold, graph MG requires a 5 times higher similarity threshold value (1.0), which usually introduces motion discontinuity. The LM value distribution of graph wcMG is consistently better than that of graph MG (Figure 4.8). This analysis shows that graph wcMG provides very responsive transitions between different behaviors while preserving good motion quality. Therefore, it is much better suited for interactive applications than graph MG. We present results for Dataset3 in this section, but similar results are achieved for all five data sets.\n\nThe LM measure we compute in this section is a theoretical measurement. Some of the minimum-duration transitions may become impossible when the motion graph is unrolled into the environment. In addition to theoretical LM measure, Reitsma and Pollard compute practical LM measure which takes the environment into account.\n\nAs Reitsma and Pollard show in their work, practical LM measure is usually higher than the theoretical measure. However, they also note that poor theoretical LM values typically indicate poor practical LM values. The horizontal axis is the total number of frames in the database and the vertical axis is the number of nodes and edges. The blue empty diamonds show the nodes size increase before the node reduction step and the filled red diamonds show the nodes size increase after the node reduction step. The green empty squares show the edge size increase before the node reduction step and the orange filled squares show the edge size increase after the node reduction step.\n\nIn this section, we analyze the number of nodes and edges in graph wcMG with respect to the size of the data set used to compute the graph. For this experiment, we use Dataset3 and vary the amount of motion data used. Figure 4.9 shows that before the node reduction step, the number of nodes (green empty diamonds) and the number of edges (blue empty squares) grow quickly as the motion data size increases.\n\nIn contrast, after the node reduction step which fully preserves the connectivity among the original nodes, the number of nodes (red filled diamonds) and the number of edges (orange filled squares) shows a much more tractable increase with respect to the data set size increase. However, the resulting graph is still quite large, which could be unacceptable for some applications such as games. The next section shows experimentally how the graph size can be decreased further using the sub-optimality scalar µ.\n\nThe sub-optimality scalar µ allows one to decrease the size of the graph further at the expense of the transition quality and the connectivity of the graph. In this experiment, we used Dataset3 to construct a series of graphs wcMG by varying the parameter µ from 1.0 to 100.0. We repeated this experiment at different similarity threshold values (0.2, 0.4 and 0.6).  shows the transition time increase for suboptimal graphs. We generate these transitions by searching for the best paths between a fixed set of user selected poses.\n\nμ NodeSize SizeFactor FFTime Mem Opt. 99803 36.7 1.27 225 1.1 83690 30.8 1.27 185 1.3 63557 23.4 1.28 132 1.5 52415 19.3 1.29 110 1.7 45833 16.8 1.30 92 2.0 39074 14.4 1.32 77 3.0 28312 10.4 1.35 56 5.0 17182 6.3 1.47 32 10.0 6492 2.4 1.84 11 20.0 3683 1.4 2.31 6 50.0 3122 1.1 2.92 6 100.0 3017 1.1 3.33 5 μ Graph Size Suboptimal Graph Transition Comparison Optimal Graph 99803 nodes Walk to Duck Walk to Pick 40 frames 39 frames μ=5 17182 nodes 44 frames 42 frames μ=50 3122 nodes 78 frames 75 frames Figure 4.11: Transition comparison between suboptimal graphs. Given a pair of poses (for example the walking to ducking poses on the left, and the walking to picking poses on the right), we search for the best path in the optimal graph, in the µ = 5 suboptimal graph and in the µ = 50 suboptimal graph and generate the above six transitions. Note that as µ increases, the transitions take longer to complete. This is because the suboptimal graphs trade transition optimality for graph size. Note that even longer transitions are still natural-looking with no visible discontinuities because the graph is always constructed at the same low similarity threshold (0.4), independently of its sub-optimality. The first column shows the graph sizes. The actual transition lengths are shown under each image, but only a few representative frames are displayed in each image. In conclusion, the user can choose an appropriate value for µ to balance between memory requirements and transition quality. µ = 5.0 was used in our interactive control experiments in Section 4.3, as it provides the best compromise between size and responsiveness.\n\nIn this section, we show the applicability of graph wcMG to interactive control applications. We use value iteration methods to learn good control policies following the reinforcement learning techniques proposed by [30,35,55]. The main advantage of the value iteration approach is that the online operation reduces to a simple fast control policy table lookup for an action.\n\nWe briefly summarize the value iteration algorithm here. More details about value iteration can be found in Barto's book [54] and in recent papers [30,35,55]. Value iteration algorithm starts by computing a reward table R(f, c). All values in the table are initialized to 0 and updated until convergence using the following expected reward update rule:\n\nwhere R(f, c) is the reward for using frame f from the motion given control input c.\n\nQ(f → f ′ |c) measures the quality of the transition from frame f to frame f ′ given control input c and it is a product of two values:\n\nwhere Q transition (f, f ′ ) measures the transition smoothness from frame f to frame f ′ .\n\nQ control (f ′ |c) measures how well the frame f ′ is following the user control c. Both values are in the range of [0, 1], with 0 being the worst quality and 1 being the best quality.\n\nOnce the reward table R(f, c) has converged, the optimal control policy table can be computed as follows:\n\nwhere table P (f, c) stores the optimal frame f ′ to transition into given current frame f and control input c. Once the reward table P (f, c) is computed, the online operation reduces to a simple and fast table lookup in P (f, c) for an action.\n\nWe compare the performance of graphs wcMG and MG for interactive control applications. Both graphs are constructed from a motion database that contains walks with different turns, jumps, and a stopping motion. Figure 4.12 illustrates the interactive control system. The user controls the target orientation of the character and the character walks to follow the orientation. The user controls the character to switch between walking, jumping and stopping behaviors by pressing the corresponding keys from a keyboard. In our application, Q transition (f, f ′ ) is the inverse of the transition cost t in the motion graph, which measures the transition smoothness.\n\nThe range of the value is [0, 1], where 0 indicates the most discontinuous transitions and 1 indicates the smoothest transitions. Q control (f ′ |c) is 0 if the behavior tag of frame f ′ is different from the user control c, otherwise, it measures the orientation difference between frame f ′ in world coordinates with the user control c. For example the frames in Figure 4.12 are all performing the correct action with the correct orientation, so Q(f → f ′ |c) for these frames are close to 1. The resulting animations are shown in the accompanying movie [63]. Graph wcMG constantly generates responsive and smooth motions.\n\nTo evaluate the performance of graphs wcMG and MG, we use an approach similar to the one described in McCann and Pollard's work [35]. We train control policies for both graphs wcMG and MG. When computing graph wcMG, we use a very low threshold (0.2), because it already provides good connectivity between the nodes and also because we want to show the performance of our algorithm at the very low similarity threshold. When computing graph MG, we have to use some high threshold values to allow low quality transitions in order to get better connectivity. Table 4.6 shows that as the similarity threshold value increase, the SCC captures more original nodes (the SCC column) because low quality transitions become available. Our wcMG achieves a much better connectivity even at a very low similarity threshold value. McCann and Pollard also observed that low quality transitions are required for better interactive user control [35]. They show that if all low quality transitions are removed from the graph, the overall performance of the interactive control decreases. We then train control policies using the value iteration technique for both graph wcMG and graph MG.\n\nSimilar to McCann and Pollard's work, we first collect desired user traces (i.e., a sequence of keyboard commands) and then evaluate the performance of the policy trained for both graph wcMG and graph MG on these traces. Table 4.6 shows the result. When evaluating a given trace from the user, we compute both\n\nAs can be seen from the\n\ntable, even with a much wcMG Thre Control Transition Total SCC Size 0.2 0.74 0.95 0.70 561 MG Thre Control Transition Total SCC Size 0.2 0.22 0.99 0.22 36 1.0 0.24 0.92 0.22 244 5.0 0.50 0.84 0.42 524 10.0 0.51 0.87 0.44 552 Table 4.6: Interactive Control Evaluation lower threshold (5 to 50 times lower than that for graph MG), graph wcMG outperforms graph MG in terms of both transition quality and responsiveness to user control.\n\nMotion graph has been a popular technique for natural human motion synthesis.\n\nHowever, it is difficult to achieve both good connectivity and smoothness transitions in a standard motion graph. This limits the performance of many motion synthesis algorithms that are based on standard motion graphs. In this chapter, we presented an algorithm for constructing an unstructured motion graph with both good connectivity and smooth transitions. Our method first computes a set of plausible new motions via a time-warped, center-of-mass-aligned interpolation of motion segments that share the same contact configuration. These new motions can then be used as the basis for creating a well-connected motion graph (graph wcMG) that achieves both good connectivity and smooth transitions. Our algorithm reduces the graph size by minimizing the number of interpolated poses present in the graph, while preserving the optimal transition quality. In addition, our algorithm trades graph quality for even smaller graph size according to a user defined sub-optimality scalar value. The outcome of the algorithm is a standard motion graph, which can be used for all the standard motion synthesis techniques for motion graphs and improve their performance. Our experimental results show that well-connected motion graphs outperform standard motion graphs across a number of measures, result in very good motion quality, allow for high responsiveness in interactive controls, and even require no post-processing to the synthesized motions.\n\nNow we discuss a few limitations of our system. First, the current method for trading off size for graph quality (Section 4.1.4) is greedy, because the order in which the original nodes are processed to compute the best paths to other nodes affects the size of the final graph. In the future, we would like to develop a more optimal algorithm. Second, the current construction step goes through a phase where we interpolate all pairs of motion segments with the same contact. This generates a large amount of interpolated nodes which never get used by the optimal and suboptimal graphs. We would like to develop a better algorithm and data structure to only interpolate motion segment pairs that are likely to contribute to the final graph construction. This will further extend the scalability of our well-connected motion graphs to even larger databases. Third, the current interpolation scheme can only handle locomotion behaviors and non-locomotion behaviors with clear contact separations. We would like to investigate into new techniques that automatically produce plausible interpolations between more complicated non-locomotion behaviors.\n\nIn this chapter we analyzed the performance of our graph for interactive control applications. We believe that our graph will also perform well for off-line searchbased methods and plan to evaluate it for off-line search-based motion synthesis applications. In addition, it is part of the future work to analyze the performance of our graph when it is unrolled into the environment (as was done by Reitsma and Pollard [44]).\n\nChapter 5\n\nNowadays, large databases of human motion are becoming freely available and their sizes are growing at a fast rate. We believe that as motion capture data accumulates, it will provide dense coverage over the behavior space and will be able to satisfy user requirements for a variety of applications. Therefore, these databases have a high potential to enable novice animation users such as children, school teachers, and small companies to easily and quickly create realistic human motions. To explore this potential, there needs to be fully automatic methods for human motion synthesis.\n\nMotion graphs which embed multiple behaviors into a simple graph structure have emerged as a popular data structure that can be used for automatic natural human motion synthesis. However, the performance of a motion graph is limited by the motions that the graph is built from.\n\nCurrent practice for finding the motions to build a motion graph is through manual selection from a motion capture database. For example, in order to create a good quality motion graph for a virtual SWAT training scenario, a user selects a set of walking, running, jumping and ducking motions that are required by the application. These selected motions need to be well-connected to provide quick and smooth transitions. However, it is highly non-trivial to manually select a subset of motions from a large motion capture database to achieve this goal. On one hand,\n\nSub-graph Motion Capture Database the subset needs to be of the smallest possible size in order to produce a small motion graph for efficient motion synthesis. On the other hand, the subset needs to contain enough motion data to preserve good quality transitions and to satisfy user requirements. As a result, the subset selection requires the user to carefully consider every relevant motion in the database, which is a highly tedious process. Even more importantly, in this process, it is nearly impossible to estimate the effect of including a particular motion on the well-connectedness of the motion graph before the graph is constructed. Motivated by reducing this burden on novice users, we develop an automatic method for selecting a good but small subset of motions from a large motion capture database that can be used to build a good quality motion graph.\n\nOur method treats the entire motion capture database as a single large motion graph and casts the motion selection problem as a search for a minimum size subgraph from a large graph. We require the user to first select a small set of key motions that are required by his/her application domain. These motions alone often fail to generate a good motion graph that satisfies all the user requirements, because they lack quick and smooth transitions between them. Our method then automatically finds additional motions in the motion database that result in good connectivity between user selected motions, but at the same time keeps the size of the motion graph as small as possible. This step corresponds to a well-defined theoretical problem the construction time of graph DMG is improved by 3 to 6 times depending on the size of the motion capture database and the type of behaviors inside the database.\n\nThe user input to our system is a set of key motions and a set of requirements.\n\nFirst, given a large motion capture database, a user selects a small set of motion segments that are required by the application. For example, the user may select a set of walking, turning, and jumping motion segments for an interactive control application. In this step, the user only needs to concentrate on the important aspects of the motions. For example, in order to select a jumping motion, the user only needs to select the motion segment that starts with the knees bending and ends with the feet landing on the ground. The user does not need to worry about the motions that transition into and out of this jumping segment.\n\nIn practice, it is very easy to manually select these key motion segments for an application, because the user knows exactly what they are looking for and the motion segments are continuous motion capture blocks. On the contrary, manually selecting good transition motions to connect multiple behaviors quickly and smoothly is extremely difficult. First, it is difficult to predict which motion segments could best connect two motion clips, not only end to end, but also between arbitrary frames in the middle of the two motion clips. Second, it is almost impossible to manually locate the best set of frames which quickly and smoothly connect all the frames from two motion clips, because the best set of frames for connection often spans several motion capture clips instead of being a continuous motion block. Our algorithm automatically finds the best possible additional motions from a large motion capture database to connect the frames from user selected key motions quickly and smoothly. As a result, users only need to concentrate on the important aspects of the motions required by their applications, without worrying about the connectivity and transition smoothness between these key motions.\n\nInstead of specifying the specific key motions, the user may just specify the types of the required behaviors, such as straight walk, long jump, etc. Since the database is annotated, our system would automatically find motion segments that match the behavior description according to their annotations. Alternatively, the user may provide some example motion segments and we could extract logically similar but numerically different motion segments for the user to choose from, using the method introduced by Kovar and Gleicher [23]. The user selected key motions correspond to a set of vertices in graph DMG, which we call the user selected vertices.\n\nNext, the user specifies requirements for his/her application. Here we present a list of user requirements that constrain transition time and transition quality between the user selected vertices.\n\nRequirement 1: Some real-time applications, such as computer games, require motion graphs with quick transition to guarantee real-time response to user input.\n\nTherefore, we constrain the minimum transition time between all the frames from the user selected motions to be smaller than or equal to a given upper bound Ω frames.\n\nSometimes, even the shortest transition from the database exceeds Ω frames. In that case, we use the actual minimum length as the constraint instead of Ω.\n\nRequirement 2: An extension to Requirement 1 is that instead of a constant upper bound, a user may be interested in a minimum size motion graph that preserves the minimum transition time between all the user selected vertices in graph DMG.\n\nRequirement 3: Reitsma and Pollard [44] proposed the local maneuverability measurement, which computes the average minimum time to transition between clips and behaviors. Unlike the constraints on transition time between a pair of vertices used in Requirement 1 and Requirement 2, the local maneuverability requirement places constraints between a set of frames. As long as some pair of vertices satisfy the constraint, the requirement is satisfied. Therefore, in Requirement 3, a user may specify an upper bound Ω to the local maneuverability measure between the user selected motions. This requirement is often useful for applications that emphasize motion realism over immediate transitions. These applications often requires the key motions to be fully played before transitions to other behaviors.\n\nRequirement 4: We assume that as motion capture data accumulates over years, it provides a denser coverage over the behavior space. Therefore, graph DMG can be constructed at a low similarity threshold to contain only smooth transitions. As a result, all transitions are treated as having equal motion quality. In reality, such dense coverage is often not feasible and graph DMG needs to be constructed at a higher similarity threshold to connect multiple behaviors. Therefore, graph DMG will contain different quality transitions. In Requirement 4, a user may specify constraints on transition quality, which is defined as the sum of the edge costs along that transitions. By encoding both transition length and transition smoothness into edge costs, Requirement 4 can be tailored toward a range of applications with emphasis on both quick response to user control and good quality motion for realism.\n\nFor simplicity, we use Requirement 1 to describe all the details of our algorithm.\n\nIn Section 5.3.5, we extend our algorithm to handle the rest of the requirements. 0 1 2 3 4 5 6 7 8 9 Start Frame End Frame User Selection 1 User Selection 2 Graph DMG Motion Graph DMG Motion Figure 5.3: Descending Processing Order.\n\nSome vertices and edges must appear in the solution sub-graph, such as the user selected vertices and edges between them. In addition, some of the vertices in graph DMG, if absent, will cause graph DMG to violate at least one of the user constraints.\n\nTo find these vertices, we remove a candidate vertex from graph DMG and compute the shortest paths between all user selected vertices. If any path is longer than Ω frames, this candidate vertex is declared to be part of the RequiredSubgraph.\n\nAccording to the Steiner problem heuristics, a good order to connect user selected vertex pairs ensures that earlier connections benefit later connections. A number of metrics have been developed for choosing the best order [5,11,52,56] at run time. However, these metrics requires time-consuming evaluations and selections at run time for every candidate vertex pairs. In their application domains, where the graph size and the terminal size is much smaller, such computation is still feasible.\n\nHowever, given the large scale of our graph size (V > 80, 000) and user selection size (k > 500), we instead choose a predetermined order to approximate this heuristic.\n\nWe base our order on the length of the shortest paths between the user selected vertices in the original motion database. We have experimented with descending order, ascending order, random order and sequential order according to the vertex index. Experiments show that the descending order (pairs with the longer length to be processed first) consistently performs the best. Intuitively, by finding a long constrained shortest path connecting the user selected vertex pairs that are far apart, the search automatically finds shorter length paths between user selected vertices that lie on the longer path, avoiding the necessity for computing these shorter paths later. Figure 5.3 illustrates the intuition. A longer path, such as the path from vertex (frame) 0 to vertex (frame) 9 goes through some frames in the same motion segment, uses some additional frames to transition to a frame in another motion segment, and continues to the last frame of that segment. By finding a constrained shortest path (shown by the dark edges) from vertex 0 to vertex 9, many paths between the intermediate user selected vertex pairs automatically satisfies the user requirements, such as the paths from vertex set of {0, 1, 2, 3, 4} to vertex set of {5, 6, 7, 8, 9} with shorter lengths. Therefore, the descending processing order approximates the processing order heuristic and improves the performance of our  table SP [v][u]. The input to the algorithm is a source vertex v s , a target vertex v t , the length constraint Ω and a weighted graph DMG whose edge weights are updated based on SubGraph. Table C[u][l] stores the best path cost to reach vertex u from v s in exactly l steps and C[v s ][0] is initialized to 0. S current keeps track of the vertices reachable from v s in exactly l steps and is initialized to {v s }. The algorithm iterates from length 1 to Ω to compute the best path cost to reach a particular vertex u with exactly l steps. During each iteration, we update the best path cost for each successor u of every vertex v from S current . The path cost c p is the best path cost to reach v in exactly l steps plus the edge weight from v to u. Only the minimum value of c p is stored to C[u][l], which is the best path cost to reach u in exactly l steps. At any l th iteration the algorithm only consider a vertex u if the shortest path length from u to v t (SP [u][v t ]) is smaller than Ωl. Table C[u][l] is updated accordingly and vertex u is included to a vertex set S next . At the end of each iteration, vertex set S current is initialized with vertices in vertex set S next . These vertices are to be expanded for the next iteration. The algorithm terminates when l = Ω and it back traces the constrained shortest path p from the minimum cost entry in the v th t row in Table C to the source vertex v s . 1 2 4 3 1 2 3 5 4 2 3 6 1 5 Length (b) (c)\n\n1 100% 100% 2 99.01% 90.20% 3 96.42% 91.11% 4 95.28% 91.12% Overall 93.30% 89.43% (a) (b) (c) (e) Figure 5.5: Graph CORE and Shortest Paths Analysis 5.3.5 Improvements and Extensions Now, we discuss improvements to scale our algorithm to large motion capture databases and extend our algorithm to handle other user requirements listed in Section 5.2. Scaling to large motion capture databases Motion capture databases accumulate a variety of motions and provide an effective basis for new motion synthesis. However, given that a particular application only needs a small set of behaviors such as walking behaviors, it is questionable whether we need to compute the sub-graph from the full database that includes jumping, ducking and dancing behaviors. Therefore, we propose restricting our Iterative Sub-graph Algorithm to only consider vertices and edges from a much smaller representative graph, called graph CORE. Graph CORE is the union of the shortest paths between all the user selected vertices in graph DMG. Our numerous experiments show that graph CORE consistently contains over 98% of the vertices that comprise the sub-graph computed by our algorithm starting from graph DMG. Therefore, graph CORE provides almost as good a starting point as graph DMG. To understand why graph CORE is a good starting graph, we need to understand how constrained shortest paths between user selected vertices are discovered. The path discovery can be classified into three cases (see path 1 → 2 in\n\nWe have been describing our algorithm based on the frame to frame transition time constraint from Requirement 1. Now we extend our algorithm to handle other requirements.\n\nRequirement 2: A direct extension to Requirement 1 is to require that the subgraph preserve the minimum transition time between all the frames in the database.\n\nTo satisfy this Requirement, we change the constant Ω to a function that returns the minimum transition time between user selected vertex pairs. The rest of the algorithm stays the same. Smaller motion graphs with quick transitions are especially useful for interactive control applications, as observed by a number of researchers [20,35,55,64].\n\nThe motion capture database we used contains 89 motions with a total of 86,987 frames sampled at 30Hz. The database contains a variety of behaviors as well as natural transitions between them that occurred during the motion capture sessions.\n\nThe corresponding database motion graph (graph DMG) contains 86,674 vertices and 613,838 edges, which covers over 99% of the entire database.\n\nWe use the boost graph library [2] to efficiently represent each vertex with a unique integer and each edge with a real value indicating the transition cost. We To scale to even larger databases, we can resort to external memory for storage and external memory algorithms for graph search [57] to first compute graph CORE.\n\nThen, as discussed in Section 5.3.5, the sub-graph computation can be perform from graph CORE with little compromise to the optimality of the solution. best). Therefore, Subgraph(DMG) and Subgraph(CORE) made little compromise in transition time distribution (only about 1 frame increase to the average transition time comparing to graph CORE) to achieve a much smaller graph size, making them well suited for interactive control applications. Table 5.4: Sub-graphs for All Requirements.\n\nsub-graphs that satisfy user requirements with very small graph sizes.\n\nWe have also tested on some other databases of different size and with different user selections. Our algorithm consistently produces sub-graphs that satisfy user requirements with very small graph sizes, usually 2% to 3% of the database size and less than 20% of the graph CORE size.\n\nIn addition to the Iterative Sub-graph Algorithm we propose in this thesis, we have also experimented with some other algorithms to compute sub-graphs that satisfy user requirements. They did not perform as well as the Iterative Sub-graph algorithm and they have drawbacks on computation efficiency. For completeness, we give a brief description of these algorithms in Appendix A. We also discuss what we have learned from these experiments and compare to our final algorithm.\n\nOur user study simulates how novice users and animation researchers usually create motion graphs by manually picking motions from large motion capture databases (such as CMU MoCap database). The study confirms the difficulty to manually select a set of motions from a large motion capture database that would result in a good quality motion graph and satisfy some given requirements.\n\nWe performed a user study with 8 subjects. Among the 8 subjects, 3 were experienced motion graph users while the other 5 were novice animation users. All subjects were presented with the motion capture database and a set of key motions described in Section 5.4. Through a motion graph construction interface shown in Figure 5.7, they browsed the motion capture database to find additional motion segments for constructing a motion graph with good connectivity and fast transitions.\n\nWe set an upper bound of 50 frames on the minimum transition time between all the frames from the key motions as the goal during our user study. The subjects performed the manual motion graph construction task twice. In the first task, they were asked to select candidate motion segments and make changes as they like. After they think the selection is adequate, the interface creates motion graphs from their selections and evaluate graph connectivity and constrains satisfaction for comparison.\n\nThe graph connectivity is measured in terms of how many key motions are connected where a user first selection the motions and then build a motion graph. In the second task, they were given constant feedback on connectivity and satisfaction of the motion graphs built from their currently selected motions to help them improve the selection. The interface also gave suggestions on the most poorly connected or satisfied key motion pairs to the subjects. The subjects analyzed these feedbacks and modify their motion selections. At a certain point, it became extremely difficult for the subjects to modify their selections to improve the connectivity and satisfaction scores any further and they stopped the test. The last user selections were considered their final selections and motion graphs were created from these selected motions for evaluation and comparison.\n\nTable 5.5 shows the average performance of novice users vs. experienced users for the two tasks. We also compare the results to a sub-graph constructed under the same problem setting using our Iterative Sub-graph Algorithm. The first column gives the time spent on constructing the motion graph manually and the time to compute the sub-graph automatically with our method (last row), measured in minutes.\n\nThe second and third column show the corresponding graph sizes. The fourth and fifth column show the graph connectivity and the constraint satisfaction respectively.\n\nThe last column shows the average transition time between the frames from the key motions measured in frames. Only experienced users were able to create a fully connected graph in task 2. They mentioned that the key strategy was to select more and longer motion segments -the redundancy helped. However, the best average satisfaction rate is only 66%. All of the subjects reported that it is very difficult to predict which motion segment would connect two motion clips smoothly and quickly.\n\nIn addition, it is impossible to locate such a segment in a large database. Our fully automatic sub-graph algorithm outperforms manual motion graph construction in all measures.\n\nIn this section, we analyze the performance of the automatically generated motion graph using our Iterative Sub-graph Algorithm in two common motion synthesis applications. First, we demonstrate it in an interactive control application. Our test application takes in real time user inputs using either key board, mouse or game pad and immediately generates motions so that the character is facing the desired orientation and performing the desired behaviors. Such a system is commonly used in computer games and virtual interactive training. They require quick transitions between all the behaviors. Second, we demonstrate our motion graph in an off-line motion synthesis application. Our test application takes in a complex environment and searches the motion graph for a physically correct and natural looking motion that efficiently navigates the character from a start location to a goal location without colliding into the environment. Such a system is commonly used for virtual simulations.\n\nIn this section, we demonstrate the applicability of our automatically computed motion graph (sub-graph) to interactive control applications. We use value iteration methods to learn good control policies following the reinforcement learning techniques commonly used by several other researchers [30, 35, 55]. Section 4.3.1 gave an overview of the exact value iteration method we used. Using the learned control policy table, a user uses a keyboard to control the orientation of the character during walking and switch between walking, jumping, stepping over, ducking and stopping behaviors in real-time (Figure 5.8). The accompanying video demonstrates both good motion quality and quick responsiveness to the real-time user control [62]. We compare the control policies learned for our sub-graph to those learned for the best motion graph created manually by an expert during our user study. Our sub-graph is much smaller in size, but achieves comparable motion quality and motion responsiveness. The motion graph created manually contains 10,404 vertices and 33,849 edges and requires a 146MB run-time policy table from 3 hours of training. Our sub-graph contains 2,217 vertices and 2,810 edges and requires a 31MB run-time variables: S i = (v i , T i x , T i z , R i y ). A state S j = (v j , T j x , T j z , R j y ) is a successor of state S i in the unrolled graph if and only if v j is the successor of v i , and (T j\n\nx , T j z , R j y ) is the result of a the aggregated translation and rotation from (T i x , T i z , R i y ) by the relative transformation from v i to v j . Theoretically, the search space is huge, containing V • T 2 • R states, where V is the vertex size of the motion graph T is the number of discretizations of the translation value along the ground plane axis and R is the number of discretizations of the rotation value around the vertical axis. With appropriate heuristics, the search only expand states that can improve the solution optimality, but the total vertex size is still an important factor to the search times.\n\nAs a result of the small size of our sub-graph, the search for a 12-second long motion took only a few seconds. The guarantees on the small transition times allow the search to find motions with efficient movements. The accompanying video shows the Figure 5.9: Off-line Motion Search. Given a complex environment, the off-line search finds an efficient natural motion to navigate the character from a start location to a goal location without colliding into the environment. generated motions [62]. The same search algorithm on the best motion graph constructed manually by an expert did not converge to a feasible solution because the large graph size causes the search to run out of memory. The same search could not find a feasible solution from the best motion graph constructed manually by a novice user, because the graph does not contain smooth and quick transitions between the required behaviors.\n\nLarge motion capture databases and motion graph techniques enable both novice users and animation researchers to easily create good quality controllers for their animation applications. However, as shown in our user study, finding a good set of motions that results in a good quality motion graph is difficult. We present an algorithm for automatically selecting motions from a large database that would result in a good quality motion graph. Users control the content and the quality of the resulting motion graph by selecting key motion segments and specifying requirements that fit their application needs. While the automatic motion selection problem is NP-hard, our efficient Iterative Sub-graph Algorithm provides a good approximation to the optimal solution and scales to large motion capture databases. We believe that our approach is a necessary step towards making motion graphs a practical tool for a larger spectrum of animation users, in particular unexperienced users such as children, school teachers, etc.\n\nThe quality of the sub-graph computed by our algorithm depends on the quality of the motion capture database. Even after years of accumulation, the database still lacks good motion quality and connectivity between certain behaviors. Low quality transitions are allowed to include these behaviors, and they decrease the motion quality of the generated sub-graphs. We address the motion quality issue by setting the constraints on transition quality (Requirement 4). In the future, we would also like to investigate how the method proposed by Zhao and Safonova [64] could be used to improve the motion quality and the connectivity of the motion capture database by introducing a minimum amount of interpolation.\n\nWe deliberately targeted our algorithm towards standard motion graphs because of their simple graph structure and widespread support by many existing motion synthesis algorithms. In the future, we plan to generalize our automatic motion selection idea to other variations of motion graphs (such as structured motion graphs with interpolations) that have been proposed over the past few years [16,25,39,40,51,55]. synthesis problems.\n\nHowever, two fundamental problems with motion graphs prevent them from being used actively in practice. First, it is difficult to generate a motion graph with both good connectivity and smooth transitions from a set of user provided motions.\n\nSecond, it is extremely difficult to manually select a good subset of motions from a large motion capture database to construct good quality motion graphs. The two approaches we developed in this thesis work address these two problems. Both of our approaches produce motion graphs of much better quality than graphs produced by previous methods. We show that our graphs are well suited for interactive control applications and for off-line motion synthesis applications. Many existing motion synthesis methods can benefit from this thesis work, because the output graph uses a standard motion graph structure, a well studied structure in computer animation with a widespread support of motion synthesis applications.\n\nThe first approach focuses on exploring the interpolation space computed from a set of user provided motion capture clips to generate a motion graph with both good connectivity and smooth transitions. While the user provided motions alone do not generate a good quality motion graph, we first compute a set of plausible new motions via a time-warped, center-of-mass-aligned interpolation of the user provided motions that share the same contact configuration. These new motions can then be used as the basis for creating our Well-Connected Motion Graph that achieves both good connectivity and smooth transitions. We reduce the graph size by minimizing the number of interpolated poses present in the graph, while preserving the optimal transition quality. In addition, we trade graph quality for even smaller graph size according to a user defined sub-optimality scalar value to fit to different application needs. This work was published at the ACM SIGGRAPH/Eurographics Symposium on Computer Animation 2008 conference where it received the best paper award [64].\n\nIn addition, an extended version on this approach was published at the Graphical Models Journal 2009 [65].\n\nInput: k: number of terminals to reach, r: root vertex, and X: terminal vertices Output: A tree T rooted at r that satisfies at least k terminals in X if there do not exist k terminals in X reachable from r, then 1 return φ; Steiner Trees as T and T t , where T is computed to connect the root vertex to all other user selected vertices in graph DMG and T t is computed to connect all other user selected vertices to the root vertex in a graph that is the transpose of graph DMG. The union of T and T t is a Directed Steiner Graph G s that connects the user selected vertices with a small graph size. However, many paths between the user selected vertices are longer than the path length limit Ω in Requirement 1, for example, the paths between some terminal vertices, because they have to travel from one terminal vertex, go up the tree to some place close to the root vertex, and then go down the tree to reach another terminal vertex. We fix this problem by short-cutting these paths using our IterativeCSP algorithm with the Directed Steiner Graph G s as the StartGraph. The resulting graph is a small sub-graph that satisfies all the user requirements.\n\nVertex Edge Time CORE 9,396 41,559 25.3 DSG 1,597 2,368 26.6 RCSP 1,439 2,087 26.8 ISA 1,403 2,138 26.7 Table A.1: Comparison between different sub-graph algorithms solution.  A.1 shows the comparison in terms of vertex size (the \"Vertex\" column), edge size (the \"Edge\" column) and the average transition time between all the user selected frames (the \"Time\" column). The first row is graph CORE, the second row is the sub-graph computed using the Directed Steiner Graph approach (DSG), the third row is the sub-graph computed using the Randomized IterativeCSP approach (RCSP) and the last row is the sub-graph from our ISA algorithm. Our ISA algorithm returns the smallest vertex size and a good average transition time. The Directed Steiner Graph approach is time consuming. Its optimality is limited by the time complexity of the DST algorithm. In order to obtain a solution in a reasonable time, we can only set the recursion level i to 2. As a result, the Directed Steiner Graph G s is not an optimal Startgraph for the later IterativeCSP algorithm. The Randomized IteratitveCSP approach achieves much better result,\n\nIn this section, we analyze the size of the largest strongly connected component (SCC) as a percentage of the original data set size for both graphs MG and wcMG at varying threshold values. This shows how well the nodes in the data set are connected to each other and how well the motion graphs are utilizing the motion data set. Table4\n\n.2 shows the percentage of largest SCC size for both graphs wcMG and MG at different similarity thresholds. The first column shows the similarity threshold.\n\nto achieve over 90% data set utilization. These entries are highlighted in blue in the\n\nγ = 0.1 in Equation5\n\n.2. In all cases, our Iterative Sub-graph Algorithm generates"
}