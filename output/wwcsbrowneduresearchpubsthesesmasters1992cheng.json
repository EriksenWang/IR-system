{
    "title": "N/A",
    "publication_date": "1988",
    "authors": [],
    "abstract": "This paper introduces three problems which could occur in Constraint Logic Pro gramming and presents possible ways to increase the efficiency of these problems. The first problem is enforcing arc consistency on a set of inequalities by reducing the domains of variables. The second problem is to find an incremental algorithm for least generalization in presence of on line bindings. The third problem is the extension of the second problem where each least generalization is required to be in a certain form. A dynamic algorithm is also generated for the problem.",
    "full_text": "The Static Algorithm 32\n\nThe Dynamic Algorithm 34\n\nUpdate Generalization 36 Time Complexity 37\n\nA An Application on Least Generalization 38\n\nThe purpose of this article is to find an algorithm which enforces arc-consistency on a set of inequalities. The definition of arc-consistency for constraint is as the following:\n\nDefinition 1 Let C(XI, ... , x n ) be a constraint and D i be the domain of Xi (1\n\nConstraint c( Xl, ... , x n ) is said to be arc-consistent wrt D i (1 ~ i ~ n) if the following condition holds for all i • \\;fbi E D i :3bl, ... ,bi-l,bi+I, ... ,bn E DI, ... ,Di-I,Di+I, ... ,D n such that c(bl, ... ,bn) holds.\n\nThis problem of inequalities is a typical Constraint Satisfaction Problem, which is defined by a finite set of variables taking values from finite domains and a set of constraints between these variables. The solution to this problem is an assignment of values to variables satisfying all inequalities. The technique is to reduce the search space by removing, from the domains of variables, values that cannot appear in the solution. The constraints in this paper are inequalities in the form of:\n\nWhere the ai, bj are constants, the Xi and Yj are variables with domains. Whether a constraint is satisfied depends on the maximum values of the variables on the left side and the minimum values of the variables on the right side.\n\nTo satisfy a constraint, the domains of variables on both sides of the constraint may be restricted by the constraint. Generally, the minimum value of each variable on the left side of an inequality may increase and the maximum value of each variable on the right side of an inequality may decrease. If there is only one inequality, each variable in the constraint should be considered once because the minimum value of a variable on the left side of the inequality depends on maximum values of all other variables on the left side and minimum values of all variables on the right side. Similarly, the maximum value of a variable on the right side of an inequality depends on minimum values of all other variables on the right side and all maximum values on the left side. Since the domains of the variables depend on each other, the variables in an inequality may need to be reevaluated if the domain of a variable in the inequality is changed by another constraint. We want to find a dynamic algorithm which reevaluates only those variables whose domains could possibly be changed and ignores all other variables. The following section gives a clear explanation for this problem. we could derive Bi from the inequality above. We could decide if the maximum value or minimum value of a variable needs to be changed by comparing it with B i or Ai. If B i is smaller than the maximum value of Yi on the right side, lBiJ becomes the new maximum value of the variable. If Ai is larger than the minimum value of Xi on the left side, rAil becomes the new minimum value of the variable. But, if Bi is smaller than Yi.min or Ai is larger than Xi.max, there is no value in the domain of this variable could satisfy this inequality.\n\nThe following is the basic idea for updating the domains of variables in a constraint.\n\nFor each variable Y on the left side Calculate B for Y if y.min < B < y.max Update y.max else if B < y.min return FAILURE. For each variable x on the right side Calculate A for x if x.min < A < x.max Update x.min else if A > x.max return FAILURE.\n\nThe above idea is enough when there is only one inequality. Now we are in position to discuss the system of several inequalities. An inequality needs to be reconsidered if the domain of one of the variables was affected by another inequality. Whenever rAi1\n\nbecomes the new xi.min, the constraints with the variable on the right side should be reconsidered since the minimums of these constraints will be higher.\n\nSimilarly, whenever lBd becomes the new Yi.max, the constraints with the variable on the left side should be reconsidered since the maximums of these constraints will be lower.\n\nThe following is the basic idea of the algorithm for inequalities:\n\nStepl Initialize each inequality: Evaluate the maximum and minimum of the inequality.\n\nC1 : VI +V2 > V3 +V4\n\nC2 : V4 + Vs > V2 + Vs 1.1 For each variable x on the left side of a constraint: Evaluate A for x such that x.min cannot be smaller than A.\n\nUpdate the minimum value of x if necessary and keep all other constraints with the variable on their right side for further reevaluation.\n\n1.2 For each variable y on the right side of a constraint: Evaluate B for y such that y.max cannot be larger than B.\n\nUpdate the maximum value of y if necessary and keep all other constraints with the variable on their left side for further reevaluation.\n\nStep2 For each constraint that needs to be reevaluated. Update the max or min of the constraint. Apply 1.1 or 1.2 for the variables in the constraint.\n\nAs we can see, the algorithm should be able to obtain the following information.\n\n• Which constraints should be reconsidered?\n\n• Which variable causes the constraint to be reconsidered?\n\n• When a constraint C is reconsidered, how much should C.max decrease or how much should C.min increase?\n\nNow let us take a look at Example 1. Assuming that the maximum value of V2 is changed by C2, C1 should be reconsidered since V2 is on its right side. Furthermore, if the maximum value of V4 is changed when C1 is reconsidered, C2, which contains V4 on its right side, should be considered again. The cycle will continue until the domains of V2 and V4 become stable.\n\nA queue Qis used to keep the information of which constraints need to be reconsid ered. Q is a set oftuples as (min,y, C,dv) such that y E C.right or as (max,x,C,dv)\n\nWhenever the maximum value of a variable, V, is decreased by some value dv, a tuple (max, V, C, dv) is inserted to Q for each constraint C with V on the left side of the constraint; similarly, whenever the minimum value of a variable, v, is increased by some value dv, a tuple (min,v,C,dv) is inserted to Q for each constraint C with v on the right side of the constraint.\n\nIn Example 1, (max, V4, C2, d1) and (min, V2, C2, d2) are in Q ifthe domains of V2 and V4 change during the evaluation of C1. But, these tuples are redundant because C2 has not been evaluated yet, V2 and V4 have to be evaluated by C2 anyway.\n\nWe call the first evaluation of each constraint the initialization of the constraint.\n\nA tuple (m, v, C, dv) does not need to be inserted to\n\nmtn:\n\nmax:\n\nIn all specifications, we take the convention that a parameter p subscripted with 0 (i.e.,po) represents the value of p at call time.\n\nWe now present the algorithm for the problem. The algorithm initializes each con straint first; Each variable is evaluated in order that the maximum or minimum value of the variable is updated if necessary. C.lnit of the constraint is set to TRUE when the constraint is initialized. Second, for the constraint in each tuple of Q, reconsider the constraint and reevaluate its variables.\n\nC.min-(C.max-au:.max)\n\n. th £Ii' t f . C A := a were a IS e coe CIen 0 x In j\n\nbegin Initialize( C); for each y E C.right do InitY(y, C, Q)j for each x E C.left do InitX(x, C, Q) end Initialize(inout C) begin Calmaxmin( C)j C.Init := TRUE end InitY(inout y, C, Q) begin CalB(y, C, B)j if y.min < B < y.max then begin dv := y.max -LB Jj y.max := LBJ; PushTuple(y, max, dv, Q) end else if B < y.min return FAILURE end InitX(inout x, G, Q) begin CaIA(x, G, A); if x.min < A < x.max then begin dv := rAlx.min; x.min:= rAl; PushTuple(x, min, dv, Q) end else if A> x.max return FAILURE end UpdateC(in (m,v,G,dv), inout Q) In the worst case, where each variable appears in all constraints, whenever the domain of a variable changes, all constraints have to be reconsidered and as we could see in procedure UpdateC, all variables are reevaluated by each constraint. Because a single domain update could trigger n* e times of variable reevaluation and it is possible to have n* d times of domain update, hence the time complexity of Algorithm 1 is O(n 2 ed); where n is the total number of variables, d is the largest domain size of all these variables and e is the number of inequalities.\n\nIn Algorithm 1, whenever a constraint is reconsidered, all its variables must be reeval uated by InitY or InitX. But it is not true that all variables have to change their domains to satisfy the new status of the inequality.\n\nConsider Example 2, CI.min = 0+3 = 3, CI.max = 2 + 1 + 3 = 6, and the domains of v, w, z and q will not change. But, if CI.min changes from 3 to 5 because the minimum value of q changes from °to 2, the procedure UpdateC in Algorithm 1 will trigger the reevaluation of v, wand z by using A . -Cl.min-(Cl.max-ai'\"Xi.max).\n\nV : °< 5 -(6 -1 * 2) = 1, v.min becomes 1.\n\nOnly v and z are affected by the change of CI.min.\n\nAs we can see, when CI.min or CI.max changes, it will be nice if we could predict which variables need to be reevaluated. Since a.max can only decrease and a.min can only increase, B i will be smaller each time a.max or a.min changes; Similarly, Ai becomes larger each time a.max or a.min changes. The problem here is when will lBij be small enough to replace Yi.max or when will rAil be large enough to replace xi.min; (Bi -xi.max) * b i and (Yi.min-A)*ai give the information we need. We denote by old(a.max-a.min) the difference between a.max and a.min last time a was considered, and new(C.max a.min) the difference between a.max and a.min now.\n\nchanges if (old(a.max -a.min) -new(C.max -a.min)) > (Bi -Yi.max) * bi. Also xi.min changes if (old(a.max -a.min) -new(a.max -a.min)) > (xi. min -Ai) * ai• If the new lBij replaces the xi.max as the next Xi.max, the new B i must be smaller by (B i -xi.max)j thus, if Xi.max is fixed, a.max -a.min should be (B i -xi.max) *b i smaller to make the new lBij small enough to be the new xi.max. If the amount of change of C.max and C.min each variable could tolerate in a constraint is provided, then, when a.max or C.min changes, only some variables in the constraint need to be reconsidered. We introduce another data structure, R, in order to support the information. R = { (C,v,dr) I v E C.right V v E C.left}. R is a set of tuples as (C,y,dr) or (C, x, dr) where y E C.right, x E C.left and dr is the tolerant value of y or x such that y.max and x.min will not change unless the total amount of changes made to C.max and C.min is greater than dr. C.DI F is the total amount of changes made to C.max and C.min. In Algorithm 2, whenever Vi in a constraint C is evaluated, a tuple (Vi, C, (B i -Vi.max) *b i +C.DIF) is inserted to R if Vi is on the right side of C or (Vi, C, (Vi.min -Ai) * ai + C.DIF) is inserted if Vi is on the left side of C. When C.DIF is (Bi -vi.max) * b i or (vi.min -Ai) * ai larger or more, the tuple will be retrieved and the reevaluation of Vi will be evoked. 5.1 Algorithm 2 Algorithm 2 begin Q:= 0; R:= 0; for each constraint C do ApplyInit(C, Q, R); while Q =f 0 do begin tu := DEQUEUE( Q); UpdateC(tu, Q, R) end end ApplyInit(inout C, Q, R) begin Initialize(C); for each y E C.right do InitY(y, C, Q, R); for each x E C.left do InitX(x, C, Q, R) end Initialize(inout C) begin Calmaxmin( C); C.DIF:= OJ C.Init := TRUE end InitY(inout y, G, Q, R) begin CalB(y, C, B); if y.min < B < y.max then begin dv := y.max -LBJj y.max := LBJj PushTuple(y, max, dv, Q) end if B < y.min ret urn FAILURE else R:= R U {(G,y,(B-y.max)*b+G.DIF)} where b is the coefficient of y in C end InitX(inout x, C, Q, R) begin CalA(x, C, A)j if x.min < A < x.max then begin dv := IAlx.min; x.min := IAl j PushTuple(x, min, dv, Q) end if A> x.max return FAILURE else R := R U {(C,x, (x.min -A) * a + C.DIF)} where a is the coefficient of x in C end UpdateC(in (m,v,C,dv), inout Q, R) begin case m of: max: C.max := C.max -a * dv where a is the coefficient of v in Cj C.DIF:= C.DIF + a * dVj mtn: C.min := C.min + b * dv where b is the coefficient of v in Cj C.DIF:= C.DIF+ b* dVj InR:= { (C,vr,dr) E Q I (vr E C.left V vr E C.right) 1\\ dr < C.DIF}j R:= R \\ InR; while InR i-0 do begin (C,vv,ddr):= DEqueueR(InR)j if vv E C.right then InitY(vv, C, Q, R) else InitX(vv, C, Q, R) end end DEqueueR(InR):(C, v, dr) Post: (C,v,dr) E InR a and InR = InR a \\ (C,v,dr). As we can see in procedure UpdateC, InR collects the tuples of R with tolerant values smaller than C.D]F since only the variables inside those tuples of C will be affected by the change of C.max or C.min. 5.2 Examples el : x + y >= Z + W c2 : r + s >= t + y x : [0,5] y : [0,6] Z : [2,4] w : [2,3] r : [0,5] s : [2,3] t: [4,5]  x.min remains a and (el, x, 2) is inserted to R because A:z: < x.min and x.min A:c = 2. y.min remains a and (el,y,l) is inserted to R because All < y.min and y.min -A y = 1. z.max remains 4 and (el, z, 5) is inserted to R because B z > z.max and B z -z.max = 5. And w.max remains 3 and (el, w, 5) is inserted to R because B w > w.max and B w -w.max = 6. For c2, c2.min = t.min + y.min = 4 and c2.max = r.max + s.max = 8. r.min becomes 1 and (c2, r, 0) is inserted to R because A r > r.min. s.min remains 2 and (c2, s, 3) is inserted to R because A 6 < s.min and A 6 -s.min = 3. y.max becomes 4 and (c2,y,0) is inserted to R because y.max > By. Since el contains y on its left side and dv = 6 -4 = 2, (max, y, el, 2) is added to Q. And finally t.max remains 5 and (c2, t, 3) is inserted to R because t.max < B t and B t -t.max = 3.\n\nel is reconsidered when tuple (max,y,el,2) is dequeued from Q; cl.max = 11 2 = 9 and el.min is still 4. Only one tuple in R, (el, y, 1), which contains el and which has tolerant value smaller than 2 needs to be reconsidered. Since Ay = 4-(9-4) = -1 and y.min-Ay+C.DIF = 0-(-1)+2 = 3, y.min remains 0 and (el, y, 3) is inserted to R. Notice that rAyl was expected to replace y.min, but the increase of y.max which occurred previously made rAyl too small to replace y.min. But, at least we could promise that the variables with larger tolerant values will not be reconsidered.\n\nIn example 4, a.min = 2 + 1 = 3 and a.max = 2 + 1 + 3 = 6. x remains 0 and (x, C, 1) is inserted to R because x.min > A~ and x.min -Ax = 1. y remains 0 and (y, a, 2) is inserted to R because y.min > A y and y.min -Ay = 2. z remains 0 and (z, C, 0) is inserted to R because z.min = A z • When a.min becomes 5 because the minimum value of w changes from 2 to 4, we only need to reevaluate the tuples with tolerant value smaller than 2 (the change of C.min), which are (z, a, 0) and (x, a, 1). x.max and z.max will change and two proper tuples will be inserted to R. Whenever a.max or C.min changes, each variable being evaluated is promised to be changed except those variables whose domains have been changed by other constraints since the last time the constraint was considered. As we could see in pro cedure UpdateC, InR collects variables with tolerant value smaller than the change of a.max or C.min; thus, only limited number of variables will be reconsidered. In the worst case, where each variable appears in all constraints, whenever the domain of a variable changes, all constraints have to be reconsidered. Since there might be n*d times of domain update, therefore the time complexity of Algorithm 2 is O(ned)j where n is the total number of variables, d is the largest domain size of all these variables and e is the number of inequalities.\n\nIt is still possible to improve Algorithm 2 to make it work more efficient in some cases.\n\nConsider when (max, y, el, d1) and (min, x, el, d2) are in the queue. In Algorithm 2, if (max, y, el, d1) is dequeued first, el will be updated and may cause some new tuples to be inserted to Q. But after (min,x,el,d2) is dequeued, el needs to be updated again and may possibly insert more tuples to Q. It is better in this case to accumulate the changes of C.max together with the changes of C.min. Instead of reconsidering some variables each time C.max or C.min is changed, we accumulate the changes of C.max and C.min until there is no tuple in Q which contains the constraint, and then reevaluate all the variables inside those tuples in R with tolerant values smaller than the accumulated value.\n\nIn example 5, C.max = 2 + 1 +3 = 6, C.min = 1 + 2 = 3 and (C,x, 1), (C,y,2), and (C, z, 0) are in R. Suppose that w.min increases to 2 and nextq.min increases to 3 due to other constraints, two tuples (min, w, C, 1) and (min, q, C, 1) are inserted to Q consecutively. If (min, w, C, 1) is processed first, tuple (C, z, 0) in R has to be reconsidered. The minimum value of z increases to 1, and tuple (C, z, l)((z.min\n\n) but also (C, z, 1) has to be reconsidered; z has to be evaluated twice.\n\nIn this example, if we could delay the evaluation of variables until both (min, w, C, 1) and (min, q, C, 1) have been dequeued, some variables, like z, could be evaluated only once.\n\nIn procedure UpdateC of Algorithm 3, we test if there is any tuple in Q with constraint C and then decide whether to reevaluate the variables of C.\n\nThe time complexity of Algorithm 3 is still O(ned), only constant time better than Algorithm 2 in some cases. Since Algorithm 3 never pushs more tuples than Algorithm 2, it never works worse than Algorithm 2.\n\nIn this paper, we have introduced O(ned) dynamic algorithms for this problem of inequalities. But there is still room for some improvement. For example, when the sum of minimum values on the left side of an inequality is larger than the sum of maximum values on the right side of the inequality, this inequality will never need to be reconsidered again. That is to say, it is necessary to keep two more data for each inequality and the inequality could be satisfied forever as soon as the minimum value on the left side becomes larger than the maximum value on the right side. Though the time complexity is still O(ned), it should be more efficient in some cases.\n\nThe idea of least generalization of terms or literals, which plays an important role in non-deductive reasoning, has been discussed in many papers including Plotkin [1970;1971], Reynolds [1970], Lassez, Maher and Marriott [1988], and Lassez and Marriott [1987]. These papers provide algorithms to find the least generalization of a set of terms or literals in time linear to the sum of sizes of these terms or literals if a proper data presentation is given.\n\nTerms come in three varieties, constant symbols, variables and function applica tions. In this paper we restrict terms to the last two varieties. We say that the term T1 is more general than the term T2 if T10\" = T2 for some substitution 0\". Substitution is a set of variable/term pairs and each variable/term pair is called a variable binding; each variable is said to be bound in this substitution. Applying a substitution to a formula means replacing each occurrence of a bound variable with its term. For exam ple P(v1,v2,v3) is more general than P(v1,v2,j(v4)) because there is a substitution 0\" = {v3/j(v4)} such that P(v1,v2,v3)0\" = P(v1,v2,j(v4)). A least generalization of a set of terms is a generalization which is less general than any other such gen eralization. For example, the least generalization of {P(x,y,j(x)),P(w,z,j(w))} is P(v1,v2,j(v1)), but P(v1,v2,j(v3)) or P(v1,v2,v3) is not the least generalization.\n\nThere is only one least generalization for a set of terms.\n\nDefinition 1 A generalization of a set of terms {t1, t2, ... , tn} is a term T such that there is a substitution O\"i for each ti and ti = TO\"i.\n\nDefinition 2 A least generalization of a set of terms {t1, t2, ... , tn} is a general ization, T, such that for any other generalization of {t1, t2, ... , tn}, T', there is a . substitution 0\" and T = T'O\".\n\nBut when a variable inside a term is bound, the generalizations relate to this term may need to be updated due to several different reasons. We have to know which generalizations need to be updated when a binding occurs, otherwise, we may need to regenerate all the generalizations all over again. The problem in this paper is not only to find the least generalization of any two terms, but also to attempt updating only those generalizations which need to be updated when a binding occurs. For example, the generalization of (x,j(y)) is vI and the generalization of (z,j(y)) is v2. When x is bound to j( xl), we want only the generalization of (x, j(y)) to be reconsidered but not the generalization of (z,j(y)). In fact, the generalization of (J(x1),j(y)) should be a functor j, like j(v3).\n\nOur aim in this paper is to find a dynamic algorithm which finds the least gener alization of any two terms and is able to reconstruct only the generalizations which need to be updated whenever a binding occurs.\n\nIn this paper, we use tl, t2, t3, tr, t1', t2', T1, T2, T3, ... for terms, v, x, y, z, w, v1, v2, v3, ... for variables, f,g, h, for functor names and P for predicate symbol. Definition 3 A set of generalizations {> is a set of tuples < tl, t2, t3 > such that t1, t2 and t3 are terms and t3 is the least generalization of t1 and t2.\n\nDefinition 4 The domain of a set of generalizations {>, noted dom( {», is the set of tuples (t1, t2) for which there exists a t3 such that < t1, t2, t3 > E {>.\n\nDefinition 5 A set of generalizations {> is functional iff each (t1, t2) E dom({», there exists at most one t3 such that < t1, t2, t3 > E {>.\n\nIn the following, we only consider functional sets of generalization and we note {>(t1, t2), the unique t3, if it exists such that < t1, t2, t3 > E ~.\n\nIn the following, we assume that we have an infinite set of variables that can be used during the generalization algorithm. A new variable can be obtained by calling the function NV, which returns a variable v not in use at the time of the call. Note that these variables are not accessible from the user and hence will never be bound externally.\n\nThe size of a term is the total number of terms in each level of the term. For exam ple, the size of f(x, f(y), h(j(y))) is 7 because the set ofterms is ((x,j(y), y, h(j(y)), f(y), y,j( x, f(y), h(j(y))))} in total.\n\nThe rest of the paper is organized in the following way. Section 3 describes the static algorithm for this problem. Section 4 presents a dynamic algorithm which maintains a set of generalizations may need to be updated when a binding occurs. Section 5 gives a dynamic algorithm for updating generalizations in the presence of a binding. Section 6 discusses the supporting data structures and their impact on time complexity.\n\nThere are four cases of least generalizations depending on the types of the two terms as depicted in Figure 1. Figure 2 depicts an example including all cases. In example 1, the generalization of P(x,x,f(x),g(y,x)) and P(y,y,h(y),g(x,h(y))) is P(v 1, V 1, v2, g(v3, v4)). Each term in this generalization is obtained from the gener For the generalization of two terms tl and t2, there are four cases:\n\n• 1 If both tl and t2 are variables, <ll(tI, t2) is a variable. For example, <ll(x,y) = v!.\n\n• 2 If one of tl or t2 is a functor and the other is a variable, <ll(tI, t2) is a variable. For example, <ll(x, f(y)) = v2.\n\n• 3 If t1 and t2 are functors with different names, <ll(tI, t2) is a variable. For example, <ll(J(x), h(y)) = v3.\n\n• 4 If both tl and t2 are functors with the same name and tl = f(ti, ... )t~) and t2 = f(tL ... , t~), <ll(tI, t2) is a functor with name f and arguments <ll(t!, tn, 1 :S i :S n. <ll(tI, t2) = f(<ll(ti, tn, ... , <ll(t~, t~)).\n\n)\n\nThe generalization of the two predicates is:\n\nP(vI, vI) v2, g(v3, v4)). alization of the corresponding terms in the two predicates; vI is the generalization of\n\nx and y, v2 is the generalization of f( x) and h(y), v3 is the generalization of y and x, and v4 is the generalization of x and h(y). vI is given as the least general term of {x, y} because x and yare two variables. For the second column, which is also {x, y}, we should be able to recognize that vI has been given as their least general term and avoid generating a new term.\n\nThe third column, {f(x), h(y H, contains functors with different function names. Since neither h, f; nor any other function name can represent these terms, the least general term should be a variable, say v2. The fourth column, {g(y, x), g(x, h(y))}, contains terms with the same function name g, a variable is not enough to be their least general term. The least generalization should also begin with 9 and its two subterms should be the least general terms of {y, x} and {x, h(y H. Notice that although {y, x} contains exactly the same terms as {x, y}, their least general terms are different because they are in different order. v3 is given as the general term of {y, x}, v4 is given as the general term of {x, h(y Hand finally g(v3,v4) is created as the generalization of {g(y,x),g(x,h(y)H.\n\nThe static generalization algorithm can now be defined as follows.\n\nGeneralize(tl, t2):\n\nGiven two terms tl, t2, Generalize(tl, t2) returns a set of generalizations, <P, such that <P(tl, t2) is the least generalization of (tl, t2). We denote by functor(t) the function name of the functor t, type(t) the type of term t.\n\nGeneralize(tl, t2) begin\n\nGeneralize-aux(tl, t2, <p)\n\nend Generalize-aux(in tl, t2, inout <p) begin if (tl, t2) tfdom(<P) and tl =I-t2 then begin if type(tl) = type(t2) = variable then <P:= <P U {< tl,t2,NV >} else if type (tl) = variable then <P := <P U {< tl, t2, NV >} else if type(t2) = variable then <P := <P U {< tl, t2, NV >} else if functor( tl) =I-functor( t2) then <P:= <P U {< tl,t2,NV >} else begin let tl = j(tL , t~); t2 = j(t~, , t~); In for i := I to n do Generalization-aux(tI, t~, cp); cP := cP U {< tl, t2, j(cp(tL tn, ... , cp(t~, t~)) >} end end end\n\nThe algorithm above finds the generalization of any two terms. It can be gener ated easily to apply to an arbitrary set of terms. The basic idea is that it is possible to obtain the generalization of a set of terms {tl, ... , tm} by performing the least generalizations of pairs, e.g glb( ... , (glb(glb(tl, t2),glb(t3, t4)), .. )). A divide and con quer approach is used to organize the generalizations in the form of a binary tree. As we could see in Figure 3, several generalizations are produced as the footsteps to the generalization of the whole. This approach can be used as the basic step of an algorithm receiving any number of terms. Suppose that the basic step receives terms {x,h(y),j(w),j(z)}. The basic step first uses the algorithm above to produce the generalizations of (x,h(y)) and (j(w),j(z)). And it produces vI = cp(x,h(y)) as the generalization of the first pair and j(v2) = CP(j(w), j( z)) as the generalization of the second pair. Then, the basic step continues calling the algorithm for vI and j(v2), v3 is produced as the generalization of vI and j(v2). Since there is no other generalization in this level, v3 becomes the generalization of the four terms.\n\nFigure 3: A divide and conquer approach is used for the generalization of {tl, t2, t3, t4}\n\nOur main interest is to design an algorithm that would update the generalizations dynamically in the presence of new bindings.\n\nIn the static algorithm, when a binding occurs, we should either do the generaliza tions all over again, or scan through all the general terms to find out which ones need to be regenerated. A general term that is generated from a term which is or which contains the term being bound has to be reconsidered. But, for dynamic updating, it would be more appropriate to keep more information during the process of general ization. We should be able to know which generalizations may be reconsidered when bindings occur.\n\nWe now generalize the dynamic algorithm to produce, in addition to the set <I> , a list of the least generalizations (tl, t2, tr) where tr is the least generalization of tl, t2\n\nwhich may need to be reconsidered when a binding occurs. The generalization is straightforward and simply returns an element for each of the basic cases.\n\nGeneralize(inout tl, t2) begin Q:= 0; <I> := 0; Generalize-aux(tl, t2, <I> , Q)\n\nend Generalize-aux(in tl, t2, inout <I> , Q) begin if (tl, t2) (j. dom(<I» and tl i-t2 then begin if type(tl) = type(t2) = variable then Update(<I>, Q, tl, t2) else if type(tl) = variable then Update(<I>, Q, tl, t2) else if type(t2) = variable then Update(<I>, Q, tl, t2) else if funetor(tl) ifunetor(t2) then Update(<I>, Q, tl,t2) else begin let tl = f(ti, \"0' t~); t2 = f(t~, ... , t~); In for i := 1 to n do Generalization-aux(t;, t~, <I> , Q); <I>:= <I> U {< tl,t2,f(<I>(tLtn, ... ,<I>(t~,t~)) >} 5 end end end Update(inout ep , Q, in tI, t2) begin v:= Nll; ep:= ep U {< tI,t2,v >};\n\nThe kind of generalization that needs to be collected for reconsideration is the one with variable as generalization. For generalization like j(z) = ep(J(x), f(y)), there must also exist z = ep( x, y). A binding to x or y may affect z, but there is no direct affect on j( z). All j(x), j(y) and j( z) are terms bound to functor j, no binding could occur to them directly. Hence only generalizations with variable as generalization need to be reconsidered and they are collected to Q as we could see in the algorithm.\n\nQ is a set of tuples (tl, t2, tr) that may need to be reconsidered when bindings oc cur. Whenever a generalization is generated except in the case that the generalization is a functor, an element is added to Q.\n\nThe set Q produced by Generalization for {x,y,g(x),J(z),x,g(z),g(x),g(z)} is depicted in Figure 4 (They are organized by the basic step that we have discussed in the previous section).\n\nWhenever a binding occurs, there may be some generalizations that need to be up dated; When x is bound to t, all the tuples (tI, t2, tr) in Q, such that where x E tl or x E t2 should be reconsidered. As we could see in Figure 4, (x, y, vI), (g( x), j(z), v2), (x,g(z),v3) and (x,z,v4) will be affected if x is bound to another term, but only (x,y,vI) will be affected ify is bound.\n\nThe tuples to be reconsidered could be divided in several cases as depicted below.\n\nLet (tI, t2, tr) denotes the tuple with x inside and O[x/t] denotes the object 0 where each occurrence of x has been replaced by t.\n\nIn the following, tI' = t:l[x/t] and t2' = t2[x/t] . • If (tI/, t2/) E dom(ep), the generalization of tl and t2, tr, should be bound to ep(tI/, t2/) . • If (tI/, t2/) ~ dom( ep) and both tI' and t2' become functors with the same name, a new generalization should be generated for tI' and t2' and the old generalization, tr, of tl and t2, should be bound to the new generated term. • If (tl', t2') (j. dom(<P) and tl' and t2' are functors with different names or any one of tl' or t2' is a variable, since the generalization remains a variable, tr could remain unchangedj (tl, t2, tr) in Q is replaced by (tl', t2', tr).\n\nAs we can see, the behavior of regeneralization includes checking the domain of <P, generating more general terms, and binding one general term to another general term.\n\nWe are now in position to present the algorithm to update the generalizations in the case of a binding. First, all the tuples with the term being bound inside are collected from Q. Second, each of these tuples is examed and applied with different approach as depicted above. We note VAR(t) the set of variables in term t.\n\nt]; PropagateBinding(R, Q, <p) end PropagateBinding(inout R, Q, <p) begin while R =1= 0 do begin tu := DEQUEUE(R); Regenerate(tu, Q, <p) end end Regenerate(in (tl', t2', tr), inout Q, <p) begin if (tl', t2') E dom(<P) then UpdateGeneralization( <P, Q, tr, <p(tl', t2')) else if type(il') = functor and type(t2') = functor and functor( il') = functor(t2') then begin Generalize-aux(tl', t2', <P, Q)i UpdateGeneralization( <P, Q, tr, <P(tl', t2')) end else Q := QU {(t1', t2', tr)} end DEQUEUE(R):(t1, t2, tr) Post: (tl,t2,tr) E R o and R = R o \\ (t1,t2,tr).\n\nConsider Figure 4 again. Tuples (x,y,v1), (g(x),f(z),v2), (x,g(z),v3), and (x,z,v4) are in R if x is bound to g(w).\n\nFor (x,y,v1), which becomes (g(w),y,v1), there is no general term, which should be a variable, for (g( w ), y). Hence v1 remains unchanged. Similar to (x, y, v1), (g(x), f(z), v2) becomes (g(g( w)), f(z), v2) and v2 remains unchanged. For (x, g(y), v3), which becomes (g(w),g(y),v3), a new least general term should be generated because v3 could no longer qualify to be the least general term of g(w) and g(y). Suppose that g(v8) is generated as the least general term of g(w) and g(y), v3 should be bound to g(v8) by calling UpdateGeneralization recursively. The binding of v3 to g(v8) makes (v3,g(v4),v6) become (g(v8),g(v4),v6) and a new generated term g(v9) is given as the generalization of g(v8) and g(v4); therefore, v6 should be bound to g(v9). The only generalization relates to v6, (vS,v6,v7), becomes (vS,g(v9),v7). For (x,z,v4), which becomes (g(w),z,v4), v4 should remains unchanged. Figure S is the status of Q after the binding of x.\n\nSome operations in the algorithm are crucial to the timing of the problem. To •obtain an efficient algorithm, some proper data structures must be chosen. The following are the operations in our consideration.\n\n1 Binding Terms.\n\n2 The operations on ~, the set of generalizations.\n\n1. Checking the domain of ~.\n\n3 Retrieving the tuples in Q which need to be reconsidered when a variable is bound.\n\n1 (x,y,vl) 2 (g(x),J(z),v2) 3 (x,g(z),v3) 4 (x, z, v4) S (vl,v2,vS) 6 (v3,g(v4),v6) 7 (vS,v6,v7).  ,y,g(x),!(z),x,g(z),g(x),g(z)} 1 (g(w),y,vl) 2 (g(g(w)),J(z),v2) 3 (w,z,v8) 4 (g(w),z,v4) S (vl,v2,vS) 6 (v8, v4, v9) 7 (vS,g(9),v7).\n\nWhen a term is bound to another, all the terms which contain this term will be affected. For example, when x is bound to f(xl), f(x) and g(y,f(x)) will become f(f(xl)) and g(y, f(f(xl))). To avoid updating all the related terms whenever a binding occurs, we should choose a right representation for terms.\n\nA term could be represented by a name, which is either a variable name or a function name, and a set of pointers to the subterms of the term if the term is a functor. For instance, g(x,y) is represented by name 9 and pointers to x and y. In addition to the name and pointers to subterms, a term could also have a pointer to the term it is bound to; when x is bound to f(xl), the pointer of x will point to f(xl). All the terms relate to x, like f(x) and g(y,f(x)), will be automatically taken care of because they have pointers point to x (directly or through other terms) and\n\nx has pointed itself to f(xl). No individual effort is needed for each of these terms.\n\nWe could use a hash table to represent the generalization set, <1>. Suppose that HF is the hash function for this table, HF(tl, t2) leads to a location in the hash table where a pointer set containing pointers to tl, t2 and t3 will be put to represent the tuple\n\nA single location in the hash table may contain several pointer sets, each pointer set (ptl, pt2, pt3) such that ptl is the pointer to tl, pt2 is the pointer to t2 and pt3 is the pointer to t3 and t3 is the generalization of tl and t2.\n\nTo know if there is a generalization for tl and t2 (if (tl, t2) E dom(<1»), we simply check if there is a pointer set containing pointers to tl, t2 and the generalization of them in the location of the hash table assigned to by HF(tl, t2).\n\nSimilarly, to retrieve the generalization of tl and t2, the location in the hash table assigned to by HF(tl, t2) is searched until a pointer set containing pointers to tl , t2 and their generalization is found. We follow the third pointer and reach the generalization of tl and t2.\n\nThe above two operations on <1> require time proportional to the size of a term because we have to follow pointer to the term and scan through it to see if it is the tl or t2 we are looking for.\n\nTo add a tuple < tl, t2, t3 > to <1>, we simply add a pointer set which contains pointers to tl, t2 and t3 to the location in the hash table assigned to by HF(tl, t2).\n\nIn UpdateGeneralization, when a binding like x = t occurs, we need to retrieve those tuples in Q with x inside: R = { (tl, t2, tr)\n\nWithout any assistance, we have to scan through each tuple to see if it contains x, which requires time linear to the size of Q. By this way, no matter how many generalizations are actually affected, the time complexity will always be O(sN) where 7 N is the total number of generalizations and s is the size of a term. But, if we could provide knowledge of which tuples will be affected by the binding of a variable, these tuples could be accessed directly without checking all the generalization tuples.\n\nTo support direct accessing, each variable in the symbol table maintains a set of pointers and each pointer points to a tuple in Q that could be affected by the variable.\n\nWhen a binding occurs, all the generalizations produced from terms containing the variable being bound are affected, hence, whenever a generalization tuple is added to Q, the pointer of the tuple should be given to all the variables inside the two terms of the generalization. For example, when vl = ~(h(x,y),w) is generated and\n\n(h(x,y),w,vl) is added to Q, the pointer to (h(x,y),w,vl) should be added to the pointer sets of x, y and w. It is to say we have to scan through the two terms to obtain all the variables inside. Thus, the timing of Generalize-aux is proportional to the larger size of these two terms.\n\nAs we could see in Regenerate, time to regenerate a single general term is still proportional to the size of a term because we first have to make sure the generalization of the updated terms does not exist and then call Generalize-aux to obtain the new generalization. Both these two steps take time linear to the size of a term. But, the reconsideration of a generalization may bind a general term to another general term and then trigger more generalizations and bindings.\n\nIn our algorithm the time to generate the least general term of two terms is propor tional to the larger size of the two terms since the information for term updating must be kept during generalization.\n\nUpdating of one general term requires time linear to the size of a term because scanning through a term may be required by comparing terms or generating new general terms. But, exactly how much time is needed to update generalizations because of a, single term binding? In the worst case, all the general terms will be affected by a single binding. Suppose that the total number of general terms is N and the maximum size of a term is limited to s. This is still a O(sN) algorithm although in many cases it is . O(sM) such that M is the total number of generalizations updated and M < N.\n\nThe problem can be defined as: Given tl, t2 and a form t, we want to find T, the least generalization of tl and t2 with respect to t. The following is the definition of the generalization. We denote by glb(tl, t2) the least generalization of tl and t2, mgu(tl, t) the most general unification of tl and t. Definition 1 The least generalization of tl and t2 with respect to t, noted rglb(tl, t2, t), is T\n\nIt is not defined otherwise. Before we discuss the problem, it is necessary to know that a term t1 is compatible with a term t if there is a substitution 8 such that tl8 = t8.\n\nRemember the least generalization problem we have before, for any two terms we could find a proper term as their least generalization. But, suppose now the general term is bound to a certain term or it is required to be in a certain form, the original least generalization may not be able to satisfy this situation. For example, the least generalization of f(x) and h(y) is v. If v is bound to f(vI), there is no generalization of f( x) and h(y) could be in the form of f( vI) because h(y) is not compatible with f(vl)j thus, h(y) should be excluded and moreover f(x) and f(vl) should be unified and be the generalization of itself. The following are the different cases of generalization of tl and t2 with respect to t:\n\n• If both t1 and t2 are compatible with t, the generalization of tl and t2 should be the unification of the least generalization of (tl, t2) and t.\n\nFor example, the generalization of f( x) and f(y\n\n• If tl is compatible with t but t2 is not, the generalization is the unification of tl and t.\n\nFor example, the generalization of f( x) and h(y) with respect to f(J( z)) is Unify(J(x), f(J(z))) = f(J(z)).\n\n• If t2 is compatible with t but tl is not, the generalization is the uni£cation of t2 and t .\n\n• If both tl and t2 are not compatible with t, no generalization could be obtained. Now we de£ne a data structure, I:!., which will be used in our algorithm.\n\nDefinition 2 A set of generalizations I:!. is a set of tuples < tl, t2, t, T > such that T is the least general term of tl and t2 with respect to t.\n\nDefinition 3 The domain of a set of generalizations I:!. , noted dom(l:!.), is the set of tuples (tl, t2, t) for which there exists a T such that < tl, t2, t, T > E I:!.. Definition 4 A set of generalizations I:!. is functional iff each (tl, t2, t) E dom(l:!.), there exists at most one T such that < tl, t2, t, T > E I:!..\n\nIn the following, we only consider functional sets of generalization and we note I:!.(tl, t2, t), the unique T, if it exists such that < tl, t2, t, T > E I:!..\n\nThe rest of the paper is organized as follows. Section 2 presents the static al gorithm for this problem. Section 3 presents a dynamic algorithm for this problem which generates a set of generalizations that may need to be reconsidered.\n\nThe static generalization algorithm can now be de£ned as follows.\n\nGeneralizeF(tl, t2, t): Given two terms tl, t2 and a form t, GeneralizeF(tl, t2, t) returns a set of generaliza tions I:!. such that I:!. (tl, t2, t) is the generalization of (tl, t2) with respect to t.\n\nFirst let us assume that Unify(T, TI) makes T and TI the same term and returns the term itself.\n\nThis algorithm is based on the different cases discussed previously, but here we £nd out whether the form t is a variable before checking the compatibility of the two terms with the form. If the form t is a variable, no compatibility needs to be checked because a variable is compatible with any variable or functor.\n\naux(tl, t2, t, I:!.) end GeneralizeF-aux(in tl, t2, t, inout .6.) begin if (tl, t2, t) f/. dom(.6.) then begin if type(t) = variable then begin Generalize(tl, t2); .6. := .6. U {< tl, t2, t, ct>(tl, t2) >} end else if Compatible(tl, t) 1\\ Compatible(t2, t) then begin Generalize(tl, t2)j T := Unify(ct>(tl, t2), t); .6. := .6. U {< tl, t2, t, T >} end else if Compatible(tl, t) 1\\ --, Compatible(t2, t) then begin T := Unify(tl, t)j .6.:=.6. U {< tl,t2,t,T >} end else if --, Compatible(tl, t) 1\\ Compatible(t2, t) then begin T := Unify(t2, t)j .6.:=.6. U {< tl,t2,t,T >} end else if --, Compatible(tl, t) 1\\ --, Compatible(t2, t) then return FAILURE end end Compatible(in tl, t2):Bu begin 8:= 0j return Comp-aux(tl, t2, 8) end Comp-aux(in tl, t2, inout 8):Bu begin if type(tl) = variable if tl E VAR(t2) return FAILURE else 8 := {(tl/t2)} 3 else if type(t2) = variable if t2 E VAR(tl) return FAILURE else 8 := {(t2jtl)} else iffunctor(tl) =I-functor(t2) then return FAILURE else begin let tl = f(tL , t~); t2 = f(t~, ,t~)j In for i := 1 to n begin if (Comp-aux(tt, tt, 8)) = FAILURE then return FAILURE else begin tl := t18; t2 := t28 end end end return TRUE; end\n\nAs we could see in the static algorithm, in the case where only tl is compatible with t, the generalization is the unification of tl and t. Since tl and t become the same term as well as the generalization after the unification, whenever tl or t changes, the generalization changes automatically. It is similar in the case where only t2 is compatible with t. The generalizations produced in these two cases will never need to be reconsidered because they will be taken care of automatically. But, in the case where both tl and t2 are compatible with t, the generalization of tl and t2 remains open to be affected; Thus, these generalizations should be kept for reconsideration in the future. We will use a queue QU containing elements of the form (tl, t2, t, T), informally (tl, t2, t, T) E QU if T is the generalization of tl and t2 with respect to t and both tl and t2 are compatible with t. The dynamic generalization algorithm can now be defined as follows.\n\nGeneralizeF(tl, t2, t): Given two terms tl, t2 and a form t, GeneralizeF(tl, t2, t) returns a set of generaliza tions fj. such that fj. (tl, t2, t) is the generalization of (tl, t2) with respect to t, and QU, a set of generalizations (tl, t2, t, T) such that T is the least generalization of tl, t2 with respect to t which may need to be reconsidered when bindings occur.\n\n(inout tl, t2, t) begin QU:= 0j 1\\ U . -. -0. l GeneralizeF-aux(tl, t2, t, fj., QU) end GeneralizeF-aux(in tl, t2, t, inout fj., QU) begin if (tl, t2,t) tf. dom(fj.) then begin if type(t) = variable then begin Generalize(tl, t2)j fj. := fj. U {< tl, t2, t, <I>(tl, t2) >} end else if Compatible(tl, t) 1\\ Compatible(t2, t) then begin Generalize(tl, t2)j T := Unify(<I>(tl, t2), t)j Update(fj., QU, tl,t2,t,T) end else if Compatible(tl,t) 1\\ ..., Compatible(t2,t) then begin T := Unify(tl, t)j fj. := fj. U {< tl, t2, t, T >} end else if..., Compatible(tl, t) 1\\ Compatible(t2, t) then begin T := Unify(t2, t)j fj. := fj. U {< tl, t2, t, T >} end else if..., Compatible(tl, t) 1\\ ..., Compatible(t2, t) then return FAILURE end end 5 end end DEQUEUE(R):(tl, t2, t, T) Post: (tI, t2, t, T) E R o and R = R o \\ (tl, t2, t, T).\n\nIn GeneralizeF-aux, the key operations are Compatible, Generalize and Unify. Gen eralize is the same one we introduced before, which takes time proportional to the size of a term to produce the least generalization of any two terms. It is obvious as we read the Compatible algorithm that it also takes time proportional to the size of a term to decide if two terms are compatible with each other. And also Unify may require the same time complexity because we may need to scan through the two terms to be unified. All the three key operations take time proportional to the size of a term; thus, we could conclude that the time to generate a generalization of any two terms with respect to a form is proportional to the size of a term. Because GeneralizeF-aux is also called when a generalization needs to be changed, the time to update a single generalization is also linear to the size of a term. But, the update of a generalization might lead to more bindings because the old generalization needs to be bound to the new generalization; thus, it is possible in the worst case that a single binding affects all the generalizations. The total time of processing a single binding is O(sN) where N is the total number of general terms and s is the maximum size of a term. general predicates which are generated from predicates. Notice that the index to a term means the position of the term in the symbol table.\n\n• symtable: a symbol table such that each element contains the following.\n\n1. lexptr: the name of the term.\n\n2. type: the type of the term, variable or functor.\n\n3. fp: includes indices to the subterms of the term.\n\n4. nextp: index to the term it is bound to. 5. arg: number of subterms in the term.\n\n6. tolist: an array contains indices to elements in genTable, which are gener alizations could be affected by the binding of this term. When this term is bound to another term, this list is followed and all the generalizations pointed to by the indices should be reconsidered, thus, the list provides direct accessing for generalization update.\n\n• ht: a hash table for supporting symbol table. Each element contains:\n\n1. list: an array contains indices to the terms in the symbol table.\n\n• pred: a table contains predicates such that each element contains the following:\n\n1. lexptr: the name of the predicate.\n\n2. fp: includes indices to the terms in the predicate.\n\n3. arg: number of terms in the predicate.\n\n4. g: index to the general predicate relates to this predicate. In the first example, the g of p(f(x),y) is the index of p(vO,vl) in the preg table.\n\n• preg: a table contains general predicates. Each element contains:\n\n1. lexptr: the name of the predicate.\n\n2. fp: includes indices to the terms in the general predicate.\n\n3. arg: number of terms in the predicate.\n\n4. g: index to the general predicate relates to this general predicate. In the first example, the g of p(vO, v1) is the index of p(v4, v5) in the preg table.\n\n• Gen: a two dimensional table that records all the generalizations. If the least general term of the ith and the jth terms in the symbol table is the kth term in the symbol table then Gen[i] [j] = k. If there is no least general term generated for the ith term and the jth term then Gen[i][j] = 0. Whenever a generalization is generated, a proper element in this table will be updated.\n\n• genTable: a table contains generalizations which may need to be updated when bindings occur. Each element contains:\n\n1. one: index to the first term of the generalization.\n\n2. two: index to the second term of the generalization.\n\n3. gen: index to the general term of the first and the second terms.\n\nWhenever a generalization with variable as generalization is generated, a proper element will be added to this table.\n\n• queue: a queue contains new bindings which are generated during term update. Each element contains (old, new) such that the (old) term should be bound to the (new) term.\n\nThe program is organized in the following files:\n\n• global.h contains the definitions of the global data structures.\n\n• lex.c contains procedures for data initialization and procedures which receive input.\n\n• symbol.c contains procedures that manage the symbol table, hash table and predicate tablesj procedures for insertion and searching.\n\n• gene.c contains procedures for generalization.\n\n• change.c contains procedures for updating in the presence of a binding. New bindings which are generated during update are also taken care of automatically by these procedures.\n\nThe following are part of the table contents after the generalization of p(J(x, y), y) and p(J(z,w),z). p(J(x, y), y) p(J(z, w), z) p (J(vI, v2), v3) pred: the predicate table lexptr fp(terms) 1 p 1,3 (p(J(x, y ), y )) 2 p 4,5 (p(J(z, w), z)) preg: the general predicate table lexptr fp(terms) 1 p 9,10 (p(J( vI, v2), v3)) symtable: the symbol table lexptr type f p(subterms ) tolist nextp (the whole term) 1 f functor 2,3 (J(x,y)) 2 x variable <1> 3 y variable < 2,3 > 4 f functor 5,6 (J(z, w)) 5 z variable < 1,3 > 6 w variable <2> 7 vI variable 8 v2 variable 9 f functor 7,8 (J(vl, v2)) 10 v3 variable ht: the hash table Index to 1 (2) (x) 2 (3) (y) 3 (5)\n\n(z) 4 (6) (w) 5 (1) (f(x,y)) 6 (4) (J(z,w)) 7 (7) (vI) 8 (8) (v2) 9 (10) (v3) 10 (9) (f(vl,v2))\n\nGen: the generalization table\n\nGen [2][5] = 7; vI = <p(x, z). Gen [3][6] = 8; v2 = <p(y, w).\n\nGen[I] [4] = 9; f(vl, v2) = <p(f(x, y), f(z, w)).\n\nGen [3][5] = 10; v3 = <p(y, z). genTable: table for generalizations which may need to be updated.\n\n< one, two, gen > 1 < 2,5,7 > vI = <p(x,z).  The hash table supports term searching; for example, the hash function locates f( x, y) to the the fifth element of the hash table, which contains index 1 to the symbol table, thus the first term is compared with f(x, y), which takes time proportional to the size of the term to make sure it is the f(x,y) we are looking for. Without hash table, we may have to cQmpare all the terms in the symbol table with the term we are searching for.\n\nAlso notice the relationship between the tolist in each element of the symbol table and the elements in genTable; The tolist of z as we could see contains indices, 1 and 3, to the elements in the genTable because vI and v3 may need to be updated when z is bound to another term. The use of tolist makes it possible to access the generalizations directly without checking all the generalizations. To obtain the tolist of a term, an index should be inserted each time a reconsiderable generalization which relates to this term is generated.\n\nSuppose that x is bound to y, the nextp of x will be 3 (the index to y), and the index in the tolist of x, 1, leads us to the first element of genTable, thus, the generalization of x and z, which becomes the generalization of y and z, should be reconsidered. But from Gen [3] [5] = 10, we find out the generalization of y and z already exists, therefore, instead of generating new generalization, v1 should be bound to v3.\n\nWe should also be aware of the fact that when a binding occurs, the index of an element in the genTable sometimes needs to be added to the tolists of other terms.\n\nIn the example above, if x is bound to f( q, r), the first element of the genTable is reconsidered. Although the generalization, v1, remains the same, the index of this element should be added to the tolists of q and r because the generalization may be affected when the binding of q or r occurs.\n\nThe update of generalization will not directly affect predicates and general predi cates because the contents in both pred and preg table are referred through symbol table . The new status of a predicate could be obtained through the nextp indices of the terms in the predicate. No individual effort is needed to maintain the contents in the predicate and general predicate tables.\n\nThe following pages are the codes of the program, which also include some de scriptions for more details.\n\n#include <stdio.h> #include <ctype.h> #include <string.h> #define BSIZE 128 #define EOS '\\0' #define V 1 #define F 2 #define HSIZE 197 #define STRMAX 999 #define SYMMAX 100 #define FALSE 0 #define TRUE 1 #define MaxA 20 extern int tokenval; extern int tempv; extern int countg; extern int teminx [] ; extern int tempinx[]i extern char lexemes[]; extern int lastchari extern int lastgenT; extern int lastentry; extern int lastpre; extern int lastpg; extern int oldlastpre; struct gTable int one; int two; int gen; } i struct tlist { int geni int updw; struct pgtable { char *lexptri int g; int arg; int nump; int fp[BSIZE]i } ; struct entry { char *lexptr; char *lexptrl; int g; int gnum; int arg; int type; int nextp; int gpos; int pos; int place; int ingen; struct tlist tolist[20]; int fp[BSIZE]; } ; struct ht2 { char *name; int entryi } i struct ht1 { int num; struct ht2 list[20]i } i struct ht1 ht[HSIZE]i struct gTable genTable[SYMMAX]; struct entry symtable[SYMMAX]i struct entry pred[SYMMAX]; struct pgtable preg[SYMMAX]i int Gen[SYMMAX] [SYMMAX]i int inxt2[SYMMAX] [SYMMAX] i int inxt3[SYMMAX] [SYMMAX]i/* started from 1, 0 is the nurnber*/ int Contain [SYMMAX] [SYMMAX]i extern int checkT()i extern int hacon()i extern int insert()i extern int insertp(); extern void error()i extern int getpre()i extern int getfname()i extern int check()i extern int getf2()i extern int getarg()i extern int findfun() i extern int gent); extern int samet) i extern int chf(); extern void printgenp()i extern char *newT()i"
}